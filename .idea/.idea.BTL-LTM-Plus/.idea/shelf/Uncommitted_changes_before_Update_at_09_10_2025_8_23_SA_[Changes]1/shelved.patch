Index: Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: a4d1d7c2b1e94b3f8a7d9c6e5f403a21
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs b/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2231 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Security.Cryptography;
-using System.Text;
-using System.Net.Sockets;
-using System.Net;
-using System.IO;
-using System.Linq;
-using System.Runtime.InteropServices;
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Data;
-using MCPForUnity.Editor.Helpers;
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Windows
-{
-    public class MCPForUnityEditorWindow : EditorWindow
-    {
-        private bool isUnityBridgeRunning = false;
-        private Vector2 scrollPosition;
-        private string pythonServerInstallationStatus = "Not Installed";
-        private Color pythonServerInstallationStatusColor = Color.red;
-        private const int mcpPort = 6500; // MCP port (still hardcoded for MCP server)
-        private readonly McpClients mcpClients = new();
-        private bool autoRegisterEnabled;
-        private bool lastClientRegisteredOk;
-        private bool lastBridgeVerifiedOk;
-        private string pythonDirOverride = null;
-        private bool debugLogsEnabled;
-        private double lastRepaintTime = 0;
-        private int manualPortInput = 0;
-        private bool isEditingPort = false;
-
-        // Script validation settings
-        private int validationLevelIndex = 1; // Default to Standard
-        private readonly string[] validationLevelOptions = new string[]
-        {
-            "Basic - Only syntax checks",
-            "Standard - Syntax + Unity practices",
-            "Comprehensive - All checks + semantic analysis",
-            "Strict - Full semantic validation (requires Roslyn)"
-        };
-
-        // UI state
-        private int selectedClientIndex = 0;
-
-        [MenuItem("Window/MCP for Unity")]
-        public static void ShowWindow()
-        {
-            GetWindow<MCPForUnityEditorWindow>("MCP for Unity");
-        }
-
-        private void OnEnable()
-        {
-            UpdatePythonServerInstallationStatus();
-
-            // Refresh bridge status
-            isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-            autoRegisterEnabled = EditorPrefs.GetBool("MCPForUnity.AutoRegisterEnabled", true);
-            debugLogsEnabled = EditorPrefs.GetBool("MCPForUnity.DebugLogs", false);
-            if (debugLogsEnabled)
-            {
-                LogDebugPrefsState();
-            }
-            foreach (var mcpClient in mcpClients.clients)
-            {
-                CheckMcpConfiguration(mcpClient);
-            }
-
-            // Load validation level setting
-            LoadValidationLevelSetting();
-
-            // First-run auto-setup only if Claude CLI is available
-            if (autoRegisterEnabled && !string.IsNullOrEmpty(ExecPath.ResolveClaude()))
-            {
-                AutoFirstRunSetup();
-            }
-        }
-
-        private void OnFocus()
-        {
-            // Refresh bridge running state on focus in case initialization completed after domain reload
-            isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-            if (mcpClients.clients.Count > 0 && selectedClientIndex < mcpClients.clients.Count)
-            {
-                var selectedClient = mcpClients.clients[selectedClientIndex];
-                CheckMcpConfiguration(selectedClient);
-            }
-            Repaint();
-        }
-
-        private Color GetStatusColor(McpStatus status)
-        {
-            // Return appropriate color based on the status enum
-            return status switch
-            {
-                McpStatus.Configured => Color.green,
-                McpStatus.Running => Color.green,
-                McpStatus.Connected => Color.green,
-                McpStatus.IncorrectPath => Color.yellow,
-                McpStatus.CommunicationError => Color.yellow,
-                McpStatus.NoResponse => Color.yellow,
-                _ => Color.red, // Default to red for error states or not configured
-            };
-        }
-
-        private void UpdatePythonServerInstallationStatus()
-        {
-            try
-            {
-                var installedPath = ServerInstaller.GetServerPath();
-                var installedOk = !string.IsNullOrEmpty(installedPath) && File.Exists(Path.Combine(installedPath, "server.py"));
-                if (installedOk)
-                {
-                    pythonServerInstallationStatus = "Installed";
-                    pythonServerInstallationStatusColor = Color.green;
-                    return;
-                }
-
-                // Fall back to embedded/dev source via our existing resolution logic
-                var embeddedPath = FindPackagePythonDirectory();
-                var embeddedOk = !string.IsNullOrEmpty(embeddedPath) && File.Exists(Path.Combine(embeddedPath, "server.py"));
-                if (embeddedOk)
-                {
-                    pythonServerInstallationStatus = "Installed (Embedded)";
-                    pythonServerInstallationStatusColor = Color.green;
-                }
-                else
-                {
-                    pythonServerInstallationStatus = "Not Installed";
-                    pythonServerInstallationStatusColor = Color.red;
-                }
-            }
-            catch
-            {
-                pythonServerInstallationStatus = "Not Installed";
-                pythonServerInstallationStatusColor = Color.red;
-            }
-        }
-
-
-        private void DrawStatusDot(Rect statusRect, Color statusColor, float size = 12)
-        {
-            var offsetX = (statusRect.width - size) / 2;
-            var offsetY = (statusRect.height - size) / 2;
-            Rect dotRect = new(statusRect.x + offsetX, statusRect.y + offsetY, size, size);
-            Vector3 center = new(
-                dotRect.x + (dotRect.width / 2),
-                dotRect.y + (dotRect.height / 2),
-                0
-            );
-            var radius = size / 2;
-
-            // Draw the main dot
-            Handles.color = statusColor;
-            Handles.DrawSolidDisc(center, Vector3.forward, radius);
-
-            // Draw the border
-            Color borderColor = new(
-                statusColor.r * 0.7f,
-                statusColor.g * 0.7f,
-                statusColor.b * 0.7f
-            );
-            Handles.color = borderColor;
-            Handles.DrawWireDisc(center, Vector3.forward, radius);
-        }
-
-        private void OnGUI()
-        {
-            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
-
-            // Header
-            DrawHeader();
-
-            // Periodically refresh to catch port changes
-            if (Event.current.type == EventType.Layout)
-            {
-                // Schedule a repaint every second to catch port updates
-                var currentTime = EditorApplication.timeSinceStartup;
-                if (currentTime - lastRepaintTime > 1.0)
-                {
-                    lastRepaintTime = currentTime;
-                    Repaint();
-                }
-            }
-
-            // Compute equal column widths for uniform layout
-            var horizontalSpacing = 2f;
-            var outerPadding = 20f; // approximate padding
-            // Make columns a bit less wide for a tighter layout
-            var computed = (position.width - outerPadding - horizontalSpacing) / 2f;
-            var colWidth = Mathf.Clamp(computed, 220f, 340f);
-            // Use fixed heights per row so paired panels match exactly
-            var topPanelHeight = 190f;
-            var bottomPanelHeight = 230f;
-
-            // Top row: Server Status (left) and Unity Bridge (right)
-            EditorGUILayout.BeginHorizontal();
-            {
-                EditorGUILayout.BeginVertical(GUILayout.Width(colWidth), GUILayout.Height(topPanelHeight));
-                DrawServerStatusSection();
-                EditorGUILayout.EndVertical();
-
-                EditorGUILayout.Space(horizontalSpacing);
-
-                EditorGUILayout.BeginVertical(GUILayout.Width(colWidth), GUILayout.Height(topPanelHeight));
-                DrawBridgeSection();
-                EditorGUILayout.EndVertical();
-            }
-            EditorGUILayout.EndHorizontal();
-
-            EditorGUILayout.Space(10);
-
-            // Second row: MCP Client Configuration (left) and Script Validation (right)
-            EditorGUILayout.BeginHorizontal();
-            {
-                EditorGUILayout.BeginVertical(GUILayout.Width(colWidth), GUILayout.Height(bottomPanelHeight));
-                DrawUnifiedClientConfiguration();
-                EditorGUILayout.EndVertical();
-
-                EditorGUILayout.Space(horizontalSpacing);
-
-                EditorGUILayout.BeginVertical(GUILayout.Width(colWidth), GUILayout.Height(bottomPanelHeight));
-                DrawValidationSection();
-                EditorGUILayout.EndVertical();
-            }
-            EditorGUILayout.EndHorizontal();
-
-            // Minimal bottom padding
-            EditorGUILayout.Space(2);
-
-            EditorGUILayout.EndScrollView();
-        }
-
-        private void DrawHeader()
-        {
-            EditorGUILayout.Space(15);
-            var titleRect = EditorGUILayout.GetControlRect(false, 40);
-            EditorGUI.DrawRect(titleRect, new Color(0.2f, 0.2f, 0.2f, 0.1f));
-
-            var titleStyle = new GUIStyle(EditorStyles.boldLabel)
-            {
-                fontSize = 16,
-                alignment = TextAnchor.MiddleLeft
-            };
-
-            GUI.Label(
-                new Rect(titleRect.x + 15, titleRect.y + 8, titleRect.width - 30, titleRect.height),
-                "MCP for Unity Editor",
-                titleStyle
-            );
-
-            // Place the Show Debug Logs toggle on the same header row, right-aligned
-            var toggleWidth = 160f;
-            var toggleRect = new Rect(titleRect.xMax - toggleWidth - 12f, titleRect.y + 10f, toggleWidth, 20f);
-            var newDebug = GUI.Toggle(toggleRect, debugLogsEnabled, "Show Debug Logs");
-            if (newDebug != debugLogsEnabled)
-            {
-                debugLogsEnabled = newDebug;
-                EditorPrefs.SetBool("MCPForUnity.DebugLogs", debugLogsEnabled);
-                if (debugLogsEnabled)
-                {
-                    LogDebugPrefsState();
-                }
-            }
-            EditorGUILayout.Space(15);
-        }
-
-        private void LogDebugPrefsState()
-        {
-            try
-            {
-                var pythonDirOverridePref = SafeGetPrefString("MCPForUnity.PythonDirOverride");
-                var uvPathPref = SafeGetPrefString("MCPForUnity.UvPath");
-                var serverSrcPref = SafeGetPrefString("MCPForUnity.ServerSrc");
-                var useEmbedded = SafeGetPrefBool("MCPForUnity.UseEmbeddedServer");
-
-                // Version-scoped detection key
-                var embeddedVer = ReadEmbeddedVersionOrFallback();
-                var detectKey = $"MCPForUnity.LegacyDetectLogged:{embeddedVer}";
-                var detectLogged = SafeGetPrefBool(detectKey);
-
-                // Project-scoped auto-register key
-                var projectPath = Application.dataPath ?? string.Empty;
-                var autoKey = $"MCPForUnity.AutoRegistered.{ComputeSha1(projectPath)}";
-                var autoRegistered = SafeGetPrefBool(autoKey);
-
-                MCPForUnity.Editor.Helpers.McpLog.Info(
-                    "MCP Debug Prefs:\n" +
-                    $"  DebugLogs: {debugLogsEnabled}\n" +
-                    $"  PythonDirOverride: '{pythonDirOverridePref}'\n" +
-                    $"  UvPath: '{uvPathPref}'\n" +
-                    $"  ServerSrc: '{serverSrcPref}'\n" +
-                    $"  UseEmbeddedServer: {useEmbedded}\n" +
-                    $"  DetectOnceKey: '{detectKey}' => {detectLogged}\n" +
-                    $"  AutoRegisteredKey: '{autoKey}' => {autoRegistered}",
-                    always: false
-                );
-            }
-            catch (Exception ex)
-            {
-                UnityEngine.Debug.LogWarning($"MCP Debug Prefs logging failed: {ex.Message}");
-            }
-        }
-
-        private static string SafeGetPrefString(string key)
-        {
-            try { return EditorPrefs.GetString(key, string.Empty) ?? string.Empty; } catch { return string.Empty; }
-        }
-
-        private static bool SafeGetPrefBool(string key)
-        {
-            try { return EditorPrefs.GetBool(key, false); } catch { return false; }
-        }
-
-        private static string ReadEmbeddedVersionOrFallback()
-        {
-            try
-            {
-                if (ServerPathResolver.TryFindEmbeddedServerSource(out var embeddedSrc))
-                {
-                    var p = Path.Combine(embeddedSrc, "server_version.txt");
-                    if (File.Exists(p))
-                    {
-                        var s = File.ReadAllText(p)?.Trim();
-                        if (!string.IsNullOrEmpty(s)) return s;
-                    }
-                }
-            }
-            catch { }
-            return "unknown";
-        }
-
-        private void DrawServerStatusSection()
-        {
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            var sectionTitleStyle = new GUIStyle(EditorStyles.boldLabel)
-            {
-                fontSize = 14
-            };
-            EditorGUILayout.LabelField("Server Status", sectionTitleStyle);
-            EditorGUILayout.Space(8);
-
-            EditorGUILayout.BeginHorizontal();
-            var statusRect = GUILayoutUtility.GetRect(0, 28, GUILayout.Width(24));
-            DrawStatusDot(statusRect, pythonServerInstallationStatusColor, 16);
-
-            var statusStyle = new GUIStyle(EditorStyles.label)
-            {
-                fontSize = 12,
-                fontStyle = FontStyle.Bold
-            };
-            EditorGUILayout.LabelField(pythonServerInstallationStatus, statusStyle, GUILayout.Height(28));
-            EditorGUILayout.EndHorizontal();
-
-            EditorGUILayout.Space(5);
-
-            EditorGUILayout.BeginHorizontal();
-            var isAutoMode = MCPForUnityBridge.IsAutoConnectMode();
-            var modeStyle = new GUIStyle(EditorStyles.miniLabel) { fontSize = 11 };
-            EditorGUILayout.LabelField($"Mode: {(isAutoMode ? "Auto" : "Standard")}", modeStyle);
-            GUILayout.FlexibleSpace();
-            EditorGUILayout.EndHorizontal();
-
-            var currentUnityPort = MCPForUnityBridge.GetCurrentPort();
-
-            // Port display with edit capability
-            EditorGUILayout.BeginHorizontal();
-            var portStyle = new GUIStyle(EditorStyles.miniLabel)
-            {
-                fontSize = 11
-            };
-
-            if (!isEditingPort)
-            {
-                EditorGUILayout.LabelField($"Unity Port: {currentUnityPort}", portStyle, GUILayout.Width(100));
-                if (GUILayout.Button("Change", GUILayout.Width(60), GUILayout.Height(18)))
-                {
-                    isEditingPort = true;
-                    manualPortInput = currentUnityPort;
-                }
-            }
-            else
-            {
-                EditorGUILayout.LabelField("Unity Port:", portStyle, GUILayout.Width(70));
-                manualPortInput = EditorGUILayout.IntField(manualPortInput, GUILayout.Width(60));
-
-                if (GUILayout.Button("Set", GUILayout.Width(40), GUILayout.Height(18)))
-                {
-                    SetManualPort(manualPortInput);
-                    isEditingPort = false;
-                }
-                if (GUILayout.Button("Cancel", GUILayout.Width(50), GUILayout.Height(18)))
-                {
-                    isEditingPort = false;
-                }
-            }
-            EditorGUILayout.LabelField($"MCP: {mcpPort}", portStyle);
-            EditorGUILayout.EndHorizontal();
-            EditorGUILayout.Space(5);
-
-            /// Auto-Setup button below ports
-            var setupButtonText = (lastClientRegisteredOk && lastBridgeVerifiedOk) ? "Connected ✓" : "Auto-Setup";
-            if (GUILayout.Button(setupButtonText, GUILayout.Height(24)))
-            {
-                RunSetupNow();
-            }
-            EditorGUILayout.Space(4);
-
-            // Repair Python Env button with tooltip tag
-            using (new EditorGUILayout.HorizontalScope())
-            {
-                GUILayout.FlexibleSpace();
-                var repairLabel = new GUIContent(
-                    "Repair Python Env",
-                    "Deletes the server's .venv and runs 'uv sync' to rebuild a clean environment. Use this if modules are missing or Python upgraded."
-                );
-                if (GUILayout.Button(repairLabel, GUILayout.Width(160), GUILayout.Height(22)))
-                {
-                    var ok = global::MCPForUnity.Editor.Helpers.ServerInstaller.RepairPythonEnvironment();
-                    if (ok)
-                    {
-                        EditorUtility.DisplayDialog("MCP for Unity", "Python environment repaired.", "OK");
-                        UpdatePythonServerInstallationStatus();
-                    }
-                    else
-                    {
-                        EditorUtility.DisplayDialog("MCP for Unity", "Repair failed. Please check Console for details.", "OK");
-                    }
-                }
-            }
-            // (Removed descriptive tool tag under the Repair button)
-
-            // (Show Debug Logs toggle moved to header)
-            EditorGUILayout.Space(2);
-
-            // Python detection warning with link
-            if (!IsPythonDetected())
-            {
-                var warnStyle = new GUIStyle(EditorStyles.label) { richText = true, wordWrap = true };
-                EditorGUILayout.LabelField("<color=#cc3333><b>Warning:</b></color> No Python installation found.", warnStyle);
-                using (new EditorGUILayout.HorizontalScope())
-                {
-                    if (GUILayout.Button("Open Install Instructions", GUILayout.Width(200)))
-                    {
-                        Application.OpenURL("https://www.python.org/downloads/");
-                    }
-                }
-                EditorGUILayout.Space(4);
-            }
-
-            // Troubleshooting helpers
-            if (pythonServerInstallationStatusColor != Color.green)
-            {
-                using (new EditorGUILayout.HorizontalScope())
-                {
-                    if (GUILayout.Button("Select server folder…", GUILayout.Width(160)))
-                    {
-                        var picked = EditorUtility.OpenFolderPanel("Select UnityMcpServer/src", Application.dataPath, "");
-                        if (!string.IsNullOrEmpty(picked) && File.Exists(Path.Combine(picked, "server.py")))
-                        {
-                            pythonDirOverride = picked;
-                            EditorPrefs.SetString("MCPForUnity.PythonDirOverride", pythonDirOverride);
-                            UpdatePythonServerInstallationStatus();
-                        }
-                        else if (!string.IsNullOrEmpty(picked))
-                        {
-                            EditorUtility.DisplayDialog("Invalid Selection", "The selected folder does not contain server.py", "OK");
-                        }
-                    }
-                    if (GUILayout.Button("Verify again", GUILayout.Width(120)))
-                    {
-                        UpdatePythonServerInstallationStatus();
-                    }
-                }
-            }
-            EditorGUILayout.EndVertical();
-        }
-
-        private void DrawBridgeSection()
-        {
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            // Always reflect the live state each repaint to avoid stale UI after recompiles
-            isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-
-            // Force repaint if bridge status changed to update port display
-            if (isUnityBridgeRunning != MCPForUnityBridge.IsRunning)
-            {
-                Repaint();
-            }
-
-            var sectionTitleStyle = new GUIStyle(EditorStyles.boldLabel)
-            {
-                fontSize = 14
-            };
-            EditorGUILayout.LabelField("Unity Bridge", sectionTitleStyle);
-            EditorGUILayout.Space(8);
-
-            EditorGUILayout.BeginHorizontal();
-            var bridgeColor = isUnityBridgeRunning ? Color.green : Color.red;
-            var bridgeStatusRect = GUILayoutUtility.GetRect(0, 28, GUILayout.Width(24));
-            DrawStatusDot(bridgeStatusRect, bridgeColor, 16);
-
-            var bridgeStatusStyle = new GUIStyle(EditorStyles.label)
-            {
-                fontSize = 12,
-                fontStyle = FontStyle.Bold
-            };
-            EditorGUILayout.LabelField(isUnityBridgeRunning ? "Running" : "Stopped", bridgeStatusStyle, GUILayout.Height(28));
-            EditorGUILayout.EndHorizontal();
-
-            EditorGUILayout.Space(8);
-            if (GUILayout.Button(isUnityBridgeRunning ? "Stop Bridge" : "Start Bridge", GUILayout.Height(32)))
-            {
-                ToggleUnityBridge();
-            }
-            EditorGUILayout.Space(5);
-            EditorGUILayout.EndVertical();
-        }
-
-        private void DrawValidationSection()
-        {
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            var sectionTitleStyle = new GUIStyle(EditorStyles.boldLabel)
-            {
-                fontSize = 14
-            };
-            EditorGUILayout.LabelField("Script Validation", sectionTitleStyle);
-            EditorGUILayout.Space(8);
-
-            EditorGUI.BeginChangeCheck();
-            validationLevelIndex = EditorGUILayout.Popup("Validation Level", validationLevelIndex, validationLevelOptions, GUILayout.Height(20));
-            if (EditorGUI.EndChangeCheck())
-            {
-                SaveValidationLevelSetting();
-            }
-
-            EditorGUILayout.Space(8);
-            var description = GetValidationLevelDescription(validationLevelIndex);
-            EditorGUILayout.HelpBox(description, MessageType.Info);
-            EditorGUILayout.Space(4);
-            // (Show Debug Logs toggle moved to header)
-            EditorGUILayout.Space(2);
-            EditorGUILayout.EndVertical();
-        }
-
-        private void DrawUnifiedClientConfiguration()
-        {
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            var sectionTitleStyle = new GUIStyle(EditorStyles.boldLabel)
-            {
-                fontSize = 14
-            };
-            EditorGUILayout.LabelField("MCP Client Configuration", sectionTitleStyle);
-            EditorGUILayout.Space(10);
-
-			// (Auto-connect toggle removed per design)
-
-            // Client selector
-            var clientNames = mcpClients.clients.Select(c => c.name).ToArray();
-            EditorGUI.BeginChangeCheck();
-            selectedClientIndex = EditorGUILayout.Popup("Select Client", selectedClientIndex, clientNames, GUILayout.Height(20));
-            if (EditorGUI.EndChangeCheck())
-            {
-                selectedClientIndex = Mathf.Clamp(selectedClientIndex, 0, mcpClients.clients.Count - 1);
-            }
-
-            EditorGUILayout.Space(10);
-
-            if (mcpClients.clients.Count > 0 && selectedClientIndex < mcpClients.clients.Count)
-            {
-                var selectedClient = mcpClients.clients[selectedClientIndex];
-                DrawClientConfigurationCompact(selectedClient);
-            }
-
-            EditorGUILayout.Space(5);
-            EditorGUILayout.EndVertical();
-        }
-
-        private void AutoFirstRunSetup()
-        {
-            try
-            {
-                // Project-scoped one-time flag
-                var projectPath = Application.dataPath ?? string.Empty;
-                var key = $"MCPForUnity.AutoRegistered.{ComputeSha1(projectPath)}";
-                if (EditorPrefs.GetBool(key, false))
-                {
-                    return;
-                }
-
-                // Attempt client registration using discovered Python server dir
-                pythonDirOverride ??= EditorPrefs.GetString("MCPForUnity.PythonDirOverride", null);
-                var pythonDir = !string.IsNullOrEmpty(pythonDirOverride) ? pythonDirOverride : FindPackagePythonDirectory();
-                if (!string.IsNullOrEmpty(pythonDir) && File.Exists(Path.Combine(pythonDir, "server.py")))
-                {
-                    var anyRegistered = false;
-                    foreach (var client in mcpClients.clients)
-                    {
-                        try
-                        {
-                            if (client.mcpType == McpTypes.ClaudeCode)
-                            {
-                                // Only attempt if Claude CLI is present
-                                if (!IsClaudeConfigured() && !string.IsNullOrEmpty(ExecPath.ResolveClaude()))
-                                {
-                                    RegisterWithClaudeCode(pythonDir);
-                                    anyRegistered = true;
-                                }
-                            }
-                            else
-                            {
-                                // For Cursor/others, skip if already configured
-                                if (!IsCursorConfigured(pythonDir))
-                                {
-                                    ConfigureMcpClient(client);
-                                    anyRegistered = true;
-                                }
-                            }
-                        }
-                        catch (Exception ex)
-                        {
-                            MCPForUnity.Editor.Helpers.McpLog.Warn($"Auto-setup client '{client.name}' failed: {ex.Message}");
-                        }
-                    }
-                    lastClientRegisteredOk = anyRegistered || IsCursorConfigured(pythonDir) || IsClaudeConfigured();
-                }
-
-                // Ensure the bridge is listening and has a fresh saved port
-                if (!MCPForUnityBridge.IsRunning)
-                {
-                    try
-                    {
-                        MCPForUnityBridge.StartAutoConnect();
-                        isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-                        Repaint();
-                    }
-                    catch (Exception ex)
-                    {
-                        MCPForUnity.Editor.Helpers.McpLog.Warn($"Auto-setup StartAutoConnect failed: {ex.Message}");
-                    }
-                }
-
-                // Verify bridge with a quick ping
-                lastBridgeVerifiedOk = VerifyBridgePing(MCPForUnityBridge.GetCurrentPort());
-
-                EditorPrefs.SetBool(key, true);
-            }
-            catch (Exception e)
-            {
-                MCPForUnity.Editor.Helpers.McpLog.Warn($"MCP for Unity auto-setup skipped: {e.Message}");
-            }
-        }
-
-        private static string ComputeSha1(string input)
-        {
-            try
-            {
-                using var sha1 = SHA1.Create();
-                var bytes = Encoding.UTF8.GetBytes(input ?? string.Empty);
-                var hash = sha1.ComputeHash(bytes);
-                var sb = new StringBuilder(hash.Length * 2);
-                foreach (var b in hash)
-                {
-                    sb.Append(b.ToString("x2"));
-                }
-                return sb.ToString();
-            }
-            catch
-            {
-                return "";
-            }
-        }
-
-        private void SetManualPort(int newPort)
-        {
-            if (newPort < 1024 || newPort > 65535)
-            {
-                EditorUtility.DisplayDialog("Invalid Port", "Port must be between 1024 and 65535", "OK");
-                return;
-            }
-
-            // Save the new port for this project
-            var projectHash = ComputeSha1(Application.dataPath).Substring(0, 8);
-            var portFile = Path.Combine(
-                Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                ".unity-mcp",
-                $"unity-mcp-port-{projectHash}.json"
-            );
-
-            try
-            {
-                // Create directory if needed
-                var dir = Path.GetDirectoryName(portFile);
-                if (!Directory.Exists(dir))
-                    Directory.CreateDirectory(dir);
-
-                // Write new port config
-                var config = new
-                {
-                    unity_port = newPort,
-                    created_date = DateTime.UtcNow.ToString("o"),
-                    project_path = Application.dataPath
-                };
-                var json = JsonConvert.SerializeObject(config, Formatting.Indented);
-                File.WriteAllText(portFile, json);
-
-                // If bridge is running, restart it with new port
-                if (MCPForUnityBridge.IsRunning)
-                {
-                    MCPForUnityBridge.Stop();
-                    EditorApplication.delayCall += () =>
-                    {
-                        MCPForUnityBridge.Start();
-                        Repaint();
-                    };
-                }
-
-                EditorUtility.DisplayDialog("Port Changed", $"Unity Bridge port set to {newPort}. Bridge will restart if running.", "OK");
-            }
-            catch (Exception ex)
-            {
-                EditorUtility.DisplayDialog("Error", $"Failed to set port: {ex.Message}", "OK");
-            }
-        }
-
-        private void RunSetupNow()
-        {
-            // Force a one-shot setup regardless of first-run flag
-            try
-            {
-                pythonDirOverride ??= EditorPrefs.GetString("MCPForUnity.PythonDirOverride", null);
-                var pythonDir = !string.IsNullOrEmpty(pythonDirOverride) ? pythonDirOverride : FindPackagePythonDirectory();
-                if (string.IsNullOrEmpty(pythonDir) || !File.Exists(Path.Combine(pythonDir, "server.py")))
-                {
-                    EditorUtility.DisplayDialog("Setup", "Python server not found. Please select UnityMcpServer/src.", "OK");
-                    return;
-                }
-
-                var anyRegistered = false;
-                foreach (var client in mcpClients.clients)
-                {
-                    try
-                    {
-                        if (client.mcpType == McpTypes.ClaudeCode)
-                        {
-                            if (!IsClaudeConfigured())
-                            {
-                                RegisterWithClaudeCode(pythonDir);
-                                anyRegistered = true;
-                            }
-                        }
-                        else
-                        {
-                            if (!IsCursorConfigured(pythonDir))
-                            {
-                                ConfigureMcpClient(client);
-                                anyRegistered = true;
-                            }
-                        }
-                    }
-                    catch (Exception ex)
-                    {
-                        UnityEngine.Debug.LogWarning($"Setup client '{client.name}' failed: {ex.Message}");
-                    }
-                }
-                lastClientRegisteredOk = anyRegistered || IsCursorConfigured(pythonDir) || IsClaudeConfigured();
-
-                // Restart/ensure bridge
-                MCPForUnityBridge.StartAutoConnect();
-                isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-
-                // Verify
-                lastBridgeVerifiedOk = VerifyBridgePing(MCPForUnityBridge.GetCurrentPort());
-                Repaint();
-            }
-            catch (Exception e)
-            {
-                EditorUtility.DisplayDialog("Setup Failed", e.Message, "OK");
-            }
-        }
-
-        private static bool IsCursorConfigured(string pythonDir)
-        {
-            try
-            {
-                var configPath = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
-                    ? Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                        ".cursor", "mcp.json")
-                    : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                        ".cursor", "mcp.json");
-                if (!File.Exists(configPath)) return false;
-                var json = File.ReadAllText(configPath);
-                dynamic cfg = JsonConvert.DeserializeObject(json);
-                var servers = cfg?.mcpServers;
-                if (servers == null) return false;
-                var unity = servers.unityMCP ?? servers.UnityMCP;
-                if (unity == null) return false;
-                var args = unity.args;
-                if (args == null) return false;
-                // Prefer exact extraction of the --directory value and compare normalized paths
-                var strArgs = ((System.Collections.Generic.IEnumerable<object>)args)
-                    .Select(x => x?.ToString() ?? string.Empty)
-                    .ToArray();
-                var dir = ExtractDirectoryArg(strArgs);
-                if (string.IsNullOrEmpty(dir)) return false;
-                return PathsEqual(dir, pythonDir);
-            }
-            catch { return false; }
-        }
-
-        private static bool PathsEqual(string a, string b)
-        {
-            if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return false;
-            try
-            {
-                var na = System.IO.Path.GetFullPath(a.Trim());
-                var nb = System.IO.Path.GetFullPath(b.Trim());
-                if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows))
-                    return string.Equals(na, nb, StringComparison.OrdinalIgnoreCase);
-                // Default to ordinal on Unix; optionally detect FS case-sensitivity at runtime if needed
-                return string.Equals(na, nb, StringComparison.Ordinal);
-            }
-            catch { return false; }
-        }
-
-        private static bool IsClaudeConfigured()
-        {
-            try
-            {
-                var claudePath = ExecPath.ResolveClaude();
-                if (string.IsNullOrEmpty(claudePath)) return false;
-
-                // Only prepend PATH on Unix
-                string pathPrepend = null;
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX) || RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
-                {
-                    pathPrepend = RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
-                        ? "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin"
-                        : "/usr/local/bin:/usr/bin:/bin";
-                }
-
-                if (!ExecPath.TryRun(claudePath, "mcp list", workingDir: null, out var stdout, out var stderr, 5000, pathPrepend))
-                {
-                    return false;
-                }
-                return (stdout ?? string.Empty).IndexOf("UnityMCP", StringComparison.OrdinalIgnoreCase) >= 0;
-            }
-            catch { return false; }
-        }
-
-        private static bool VerifyBridgePing(int port)
-        {
-            // Use strict framed protocol to match bridge (FRAMING=1)
-            const int ConnectTimeoutMs = 1000;
-            const int FrameTimeoutMs = 30000; // match bridge frame I/O timeout
-
-            try
-            {
-                using var client = new TcpClient();
-                var connectTask = client.ConnectAsync(IPAddress.Loopback, port);
-                if (!connectTask.Wait(ConnectTimeoutMs)) return false;
-
-                using var stream = client.GetStream();
-                try { client.NoDelay = true; } catch { }
-
-                // 1) Read handshake line (ASCII, newline-terminated)
-                var handshake = ReadLineAscii(stream, 2000);
-                if (string.IsNullOrEmpty(handshake) || handshake.IndexOf("FRAMING=1", StringComparison.OrdinalIgnoreCase) < 0)
-                {
-                    UnityEngine.Debug.LogWarning("MCP for Unity: Bridge handshake missing FRAMING=1");
-                    return false;
-                }
-
-                // 2) Send framed "ping"
-                var payload = Encoding.UTF8.GetBytes("ping");
-                WriteFrame(stream, payload, FrameTimeoutMs);
-
-                // 3) Read framed response and check for pong
-                var response = ReadFrameUtf8(stream, FrameTimeoutMs);
-                var ok = !string.IsNullOrEmpty(response) && response.IndexOf("pong", StringComparison.OrdinalIgnoreCase) >= 0;
-                if (!ok)
-                {
-                    UnityEngine.Debug.LogWarning($"MCP for Unity: Framed ping failed; response='{response}'");
-                }
-                return ok;
-            }
-            catch (Exception ex)
-            {
-                UnityEngine.Debug.LogWarning($"MCP for Unity: VerifyBridgePing error: {ex.Message}");
-                return false;
-            }
-        }
-
-        // Minimal framing helpers (8-byte big-endian length prefix), blocking with timeouts
-        private static void WriteFrame(NetworkStream stream, byte[] payload, int timeoutMs)
-        {
-            if (payload == null) throw new ArgumentNullException(nameof(payload));
-            if (payload.LongLength < 1) throw new IOException("Zero-length frames are not allowed");
-            var header = new byte[8];
-            var len = (ulong)payload.LongLength;
-            header[0] = (byte)(len >> 56);
-            header[1] = (byte)(len >> 48);
-            header[2] = (byte)(len >> 40);
-            header[3] = (byte)(len >> 32);
-            header[4] = (byte)(len >> 24);
-            header[5] = (byte)(len >> 16);
-            header[6] = (byte)(len >> 8);
-            header[7] = (byte)(len);
-
-            stream.WriteTimeout = timeoutMs;
-            stream.Write(header, 0, header.Length);
-            stream.Write(payload, 0, payload.Length);
-        }
-
-        private static string ReadFrameUtf8(NetworkStream stream, int timeoutMs)
-        {
-            var header = ReadExact(stream, 8, timeoutMs);
-            var len = ((ulong)header[0] << 56)
-                      | ((ulong)header[1] << 48)
-                      | ((ulong)header[2] << 40)
-                      | ((ulong)header[3] << 32)
-                      | ((ulong)header[4] << 24)
-                      | ((ulong)header[5] << 16)
-                      | ((ulong)header[6] << 8)
-                      | header[7];
-            if (len == 0UL) throw new IOException("Zero-length frames are not allowed");
-            if (len > int.MaxValue) throw new IOException("Frame too large");
-            var payload = ReadExact(stream, (int)len, timeoutMs);
-            return Encoding.UTF8.GetString(payload);
-        }
-
-        private static byte[] ReadExact(NetworkStream stream, int count, int timeoutMs)
-        {
-            var buffer = new byte[count];
-            var offset = 0;
-            stream.ReadTimeout = timeoutMs;
-            while (offset < count)
-            {
-                var read = stream.Read(buffer, offset, count - offset);
-                if (read <= 0) throw new IOException("Connection closed before reading expected bytes");
-                offset += read;
-            }
-            return buffer;
-        }
-
-        private static string ReadLineAscii(NetworkStream stream, int timeoutMs, int maxLen = 512)
-        {
-            stream.ReadTimeout = timeoutMs;
-            using var ms = new MemoryStream();
-            var one = new byte[1];
-            while (ms.Length < maxLen)
-            {
-                var n = stream.Read(one, 0, 1);
-                if (n <= 0) break;
-                if (one[0] == (byte)'\n') break;
-                ms.WriteByte(one[0]);
-            }
-            return Encoding.ASCII.GetString(ms.ToArray());
-        }
-
-        private void DrawClientConfigurationCompact(McpClient mcpClient)
-        {
-			// Special pre-check for Claude Code: if CLI missing, reflect in status UI
-			if (mcpClient.mcpType == McpTypes.ClaudeCode)
-			{
-				var claudeCheck = ExecPath.ResolveClaude();
-				if (string.IsNullOrEmpty(claudeCheck))
-				{
-					mcpClient.configStatus = "Claude Not Found";
-					mcpClient.status = McpStatus.NotConfigured;
-				}
-			}
-
-			// Pre-check for clients that require uv (all except Claude Code)
-			var uvRequired = mcpClient.mcpType != McpTypes.ClaudeCode;
-			var uvMissingEarly = false;
-			if (uvRequired)
-			{
-				var uvPathEarly = FindUvPath();
-				if (string.IsNullOrEmpty(uvPathEarly))
-				{
-					uvMissingEarly = true;
-					mcpClient.configStatus = "uv Not Found";
-					mcpClient.status = McpStatus.NotConfigured;
-				}
-			}
-
-            // Status display
-            EditorGUILayout.BeginHorizontal();
-            var statusRect = GUILayoutUtility.GetRect(0, 28, GUILayout.Width(24));
-            var statusColor = GetStatusColor(mcpClient.status);
-            DrawStatusDot(statusRect, statusColor, 16);
-
-            var clientStatusStyle = new GUIStyle(EditorStyles.label)
-            {
-                fontSize = 12,
-                fontStyle = FontStyle.Bold
-            };
-            EditorGUILayout.LabelField(mcpClient.configStatus, clientStatusStyle, GUILayout.Height(28));
-            EditorGUILayout.EndHorizontal();
-			// When Claude CLI is missing, show a clear install hint directly below status
-			if (mcpClient.mcpType == McpTypes.ClaudeCode && string.IsNullOrEmpty(ExecPath.ResolveClaude()))
-			{
-				var installHintStyle = new GUIStyle(clientStatusStyle);
-				installHintStyle.normal.textColor = new Color(1f, 0.5f, 0f); // orange
-				EditorGUILayout.BeginHorizontal();
-				var installText = new GUIContent("Make sure Claude Code is installed!");
-				var textSize = installHintStyle.CalcSize(installText);
-				EditorGUILayout.LabelField(installText, installHintStyle, GUILayout.Height(22), GUILayout.Width(textSize.x + 2), GUILayout.ExpandWidth(false));
-				var helpLinkStyle = new GUIStyle(EditorStyles.linkLabel) { fontStyle = FontStyle.Bold };
-				GUILayout.Space(6);
-				if (GUILayout.Button("[HELP]", helpLinkStyle, GUILayout.Height(22), GUILayout.ExpandWidth(false)))
-				{
-					Application.OpenURL("https://github.com/CoplayDev/unity-mcp/wiki/Troubleshooting-Unity-MCP-and-Claude-Code");
-				}
-				EditorGUILayout.EndHorizontal();
-			}
-
-			EditorGUILayout.Space(10);
-
-			// If uv is missing for required clients, show hint and picker then exit early to avoid showing other controls
-			if (uvRequired && uvMissingEarly)
-			{
-				var installHintStyle2 = new GUIStyle(EditorStyles.label)
-				{
-					fontSize = 12,
-					fontStyle = FontStyle.Bold,
-					wordWrap = false
-				};
-				installHintStyle2.normal.textColor = new Color(1f, 0.5f, 0f);
-				EditorGUILayout.BeginHorizontal();
-				var installText2 = new GUIContent("Make sure uv is installed!");
-				var sz = installHintStyle2.CalcSize(installText2);
-				EditorGUILayout.LabelField(installText2, installHintStyle2, GUILayout.Height(22), GUILayout.Width(sz.x + 2), GUILayout.ExpandWidth(false));
-				var helpLinkStyle2 = new GUIStyle(EditorStyles.linkLabel) { fontStyle = FontStyle.Bold };
-				GUILayout.Space(6);
-				if (GUILayout.Button("[HELP]", helpLinkStyle2, GUILayout.Height(22), GUILayout.ExpandWidth(false)))
-				{
-					Application.OpenURL("https://github.com/CoplayDev/unity-mcp/wiki/Troubleshooting-Unity-MCP-and-Cursor,-VSCode-&-Windsurf");
-				}
-				EditorGUILayout.EndHorizontal();
-
-				EditorGUILayout.Space(8);
-				EditorGUILayout.BeginHorizontal();
-				if (GUILayout.Button("Choose uv Install Location", GUILayout.Width(260), GUILayout.Height(22)))
-				{
-					var suggested = RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "/opt/homebrew/bin" : Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
-					var picked = EditorUtility.OpenFilePanel("Select 'uv' binary", suggested, "");
-					if (!string.IsNullOrEmpty(picked))
-					{
-						EditorPrefs.SetString("MCPForUnity.UvPath", picked);
-						ConfigureMcpClient(mcpClient);
-						Repaint();
-					}
-				}
-				EditorGUILayout.EndHorizontal();
-				return;
-			}
-
-            // Action buttons in horizontal layout
-            EditorGUILayout.BeginHorizontal();
-
-            if (mcpClient.mcpType == McpTypes.VSCode)
-            {
-                if (GUILayout.Button("Auto Configure", GUILayout.Height(32)))
-                {
-                    ConfigureMcpClient(mcpClient);
-                }
-            }
-			else if (mcpClient.mcpType == McpTypes.ClaudeCode)
-			{
-				var claudeAvailable = !string.IsNullOrEmpty(ExecPath.ResolveClaude());
-				if (claudeAvailable)
-				{
-					var isConfigured = mcpClient.status == McpStatus.Configured;
-					var buttonText = isConfigured ? "Unregister MCP for Unity with Claude Code" : "Register with Claude Code";
-					if (GUILayout.Button(buttonText, GUILayout.Height(32)))
-					{
-						if (isConfigured)
-						{
-							UnregisterWithClaudeCode();
-						}
-						else
-						{
-							var pythonDir = FindPackagePythonDirectory();
-							RegisterWithClaudeCode(pythonDir);
-						}
-					}
-					// Hide the picker once a valid binary is available
-					EditorGUILayout.EndHorizontal();
-					EditorGUILayout.BeginHorizontal();
-					var pathLabelStyle = new GUIStyle(EditorStyles.miniLabel) { wordWrap = true };
-					var resolvedClaude = ExecPath.ResolveClaude();
-					EditorGUILayout.LabelField($"Claude CLI: {resolvedClaude}", pathLabelStyle);
-					EditorGUILayout.EndHorizontal();
-					EditorGUILayout.BeginHorizontal();
-				}
-				// CLI picker row (only when not found)
-				EditorGUILayout.EndHorizontal();
-				EditorGUILayout.BeginHorizontal();
-				if (!claudeAvailable)
-				{
-					// Only show the picker button in not-found state (no redundant "not found" label)
-					if (GUILayout.Button("Choose Claude Install Location", GUILayout.Width(260), GUILayout.Height(22)))
-					{
-						var suggested = RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "/opt/homebrew/bin" : Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
-						var picked = EditorUtility.OpenFilePanel("Select 'claude' CLI", suggested, "");
-						if (!string.IsNullOrEmpty(picked))
-						{
-							ExecPath.SetClaudeCliPath(picked);
-							// Auto-register after setting a valid path
-							var pythonDir = FindPackagePythonDirectory();
-							RegisterWithClaudeCode(pythonDir);
-							Repaint();
-						}
-					}
-				}
-				EditorGUILayout.EndHorizontal();
-				EditorGUILayout.BeginHorizontal();
-			}
-            else
-            {
-                if (GUILayout.Button($"Auto Configure", GUILayout.Height(32)))
-                {
-                    ConfigureMcpClient(mcpClient);
-                }
-            }
-
-            if (mcpClient.mcpType != McpTypes.ClaudeCode)
-            {
-                if (GUILayout.Button("Manual Setup", GUILayout.Height(32)))
-                {
-                    var configPath = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
-                        ? mcpClient.windowsConfigPath
-                        : mcpClient.linuxConfigPath;
-
-                    if (mcpClient.mcpType == McpTypes.VSCode)
-                    {
-                        var pythonDir = FindPackagePythonDirectory();
-                        var uvPath = FindUvPath();
-                        if (uvPath == null)
-                        {
-                            UnityEngine.Debug.LogError("UV package manager not found. Cannot configure VSCode.");
-                            return;
-                        }
-                        // VSCode now reads from mcp.json with a top-level "servers" block
-                        var vscodeConfig = new
-                        {
-                            servers = new
-                            {
-                                unityMCP = new
-                                {
-                                    command = uvPath,
-                                    args = new[] { "run", "--directory", pythonDir, "server.py" }
-                                }
-                            }
-                        };
-                        JsonSerializerSettings jsonSettings = new() { Formatting = Formatting.Indented };
-                        var manualConfigJson = JsonConvert.SerializeObject(vscodeConfig, jsonSettings);
-                        VSCodeManualSetupWindow.ShowWindow(configPath, manualConfigJson);
-                    }
-                    else
-                    {
-                        ShowManualInstructionsWindow(configPath, mcpClient);
-                    }
-                }
-            }
-
-            EditorGUILayout.EndHorizontal();
-
-			EditorGUILayout.Space(8);
-			// Quick info (hide when Claude is not found to avoid confusion)
-			var hideConfigInfo =
-				(mcpClient.mcpType == McpTypes.ClaudeCode && string.IsNullOrEmpty(ExecPath.ResolveClaude()))
-				|| ((mcpClient.mcpType != McpTypes.ClaudeCode) && string.IsNullOrEmpty(FindUvPath()));
-			if (!hideConfigInfo)
-			{
-				var configInfoStyle = new GUIStyle(EditorStyles.miniLabel)
-				{
-					fontSize = 10
-				};
-				EditorGUILayout.LabelField($"Config: {Path.GetFileName(RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? mcpClient.windowsConfigPath : mcpClient.linuxConfigPath)}", configInfoStyle);
-			}
-        }
-
-        private void ToggleUnityBridge()
-        {
-            if (isUnityBridgeRunning)
-            {
-                MCPForUnityBridge.Stop();
-            }
-            else
-            {
-                MCPForUnityBridge.Start();
-            }
-            // Reflect the actual state post-operation (avoid optimistic toggle)
-            isUnityBridgeRunning = MCPForUnityBridge.IsRunning;
-            Repaint();
-        }
-
-		private static bool IsValidUv(string path)
-		{
-			return !string.IsNullOrEmpty(path)
-				&& System.IO.Path.IsPathRooted(path)
-				&& System.IO.File.Exists(path);
-		}
-
-		private static bool ValidateUvBinarySafe(string path)
-		{
-			try
-			{
-				if (string.IsNullOrEmpty(path) || !System.IO.File.Exists(path)) return false;
-				var psi = new System.Diagnostics.ProcessStartInfo
-				{
-					FileName = path,
-					Arguments = "--version",
-					UseShellExecute = false,
-					RedirectStandardOutput = true,
-					RedirectStandardError = true,
-					CreateNoWindow = true
-				};
-				using var p = System.Diagnostics.Process.Start(psi);
-				if (p == null) return false;
-				if (!p.WaitForExit(3000)) { try { p.Kill(); } catch { } return false; }
-				if (p.ExitCode != 0) return false;
-				var output = p.StandardOutput.ReadToEnd().Trim();
-				return output.StartsWith("uv ");
-			}
-			catch { return false; }
-		}
-
-		private static string ExtractDirectoryArg(string[] args)
-		{
-			if (args == null) return null;
-			for (var i = 0; i < args.Length - 1; i++)
-			{
-				if (string.Equals(args[i], "--directory", StringComparison.OrdinalIgnoreCase))
-				{
-					return args[i + 1];
-				}
-			}
-			return null;
-		}
-
-		private static bool ArgsEqual(string[] a, string[] b)
-		{
-			if (a == null || b == null) return a == b;
-			if (a.Length != b.Length) return false;
-			for (var i = 0; i < a.Length; i++)
-			{
-				if (!string.Equals(a[i], b[i], StringComparison.Ordinal)) return false;
-			}
-			return true;
-		}
-
-        private string WriteToConfig(string pythonDir, string configPath, McpClient mcpClient = null)
-        {
-			// 0) Respect explicit lock (hidden pref or UI toggle)
-			try { if (UnityEditor.EditorPrefs.GetBool("MCPForUnity.LockCursorConfig", false)) return "Skipped (locked)"; } catch { }
-
-            JsonSerializerSettings jsonSettings = new() { Formatting = Formatting.Indented };
-
-            // Read existing config if it exists
-            var existingJson = "{}";
-            if (File.Exists(configPath))
-            {
-                try
-                {
-                    existingJson = File.ReadAllText(configPath);
-                }
-                catch (Exception e)
-                {
-                    UnityEngine.Debug.LogWarning($"Error reading existing config: {e.Message}.");
-                }
-            }
-
-            // Parse the existing JSON while preserving all properties
-            dynamic existingConfig;
-            try
-            {
-                if (string.IsNullOrWhiteSpace(existingJson))
-                {
-                    existingConfig = new Newtonsoft.Json.Linq.JObject();
-                }
-                else
-                {
-                    existingConfig = JsonConvert.DeserializeObject(existingJson) ?? new Newtonsoft.Json.Linq.JObject();
-                }
-            }
-            catch
-            {
-                // If user has partial/invalid JSON (e.g., mid-edit), start from a fresh object
-                if (!string.IsNullOrWhiteSpace(existingJson))
-                {
-                    UnityEngine.Debug.LogWarning("UnityMCP: VSCode mcp.json could not be parsed; rewriting servers block.");
-                }
-                existingConfig = new Newtonsoft.Json.Linq.JObject();
-            }
-
-			// Determine existing entry references (command/args)
-			string existingCommand = null;
-			string[] existingArgs = null;
-			var isVSCode = (mcpClient?.mcpType == McpTypes.VSCode);
-			try
-			{
-				if (isVSCode)
-				{
-					existingCommand = existingConfig?.servers?.unityMCP?.command?.ToString();
-					existingArgs = existingConfig?.servers?.unityMCP?.args?.ToObject<string[]>();
-				}
-				else
-				{
-					existingCommand = existingConfig?.mcpServers?.unityMCP?.command?.ToString();
-					existingArgs = existingConfig?.mcpServers?.unityMCP?.args?.ToObject<string[]>();
-				}
-			}
-			catch { }
-
-			// 1) Start from existing, only fill gaps (prefer trusted resolver)
-			var uvPath = ServerInstaller.FindUvPath();
-			// Optionally trust existingCommand if it looks like uv/uv.exe
-			try
-			{
-				var name = System.IO.Path.GetFileName((existingCommand ?? string.Empty).Trim()).ToLowerInvariant();
-				if ((name == "uv" || name == "uv.exe") && ValidateUvBinarySafe(existingCommand))
-				{
-					uvPath = existingCommand;
-				}
-			}
-			catch { }
-			if (uvPath == null) return "UV package manager not found. Please install UV first.";
-			var serverSrc = ExtractDirectoryArg(existingArgs);
-			var serverValid = !string.IsNullOrEmpty(serverSrc)
-				&& System.IO.File.Exists(System.IO.Path.Combine(serverSrc, "server.py"));
-			if (!serverValid)
-			{
-				// Prefer the provided pythonDir if valid; fall back to resolver
-				if (!string.IsNullOrEmpty(pythonDir) && System.IO.File.Exists(System.IO.Path.Combine(pythonDir, "server.py")))
-				{
-					serverSrc = pythonDir;
-				}
-				else
-				{
-					serverSrc = ResolveServerSrc();
-				}
-			}
-
-			// macOS normalization: map XDG-style ~/.local/share to canonical Application Support
-			try
-			{
-				if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.OSX)
-					&& !string.IsNullOrEmpty(serverSrc))
-				{
-					var norm = serverSrc.Replace('\\', '/');
-					var idx = norm.IndexOf("/.local/share/UnityMCP/", StringComparison.Ordinal);
-					if (idx >= 0)
-					{
-						var home = Environment.GetFolderPath(Environment.SpecialFolder.Personal) ?? string.Empty;
-						var suffix = norm.Substring(idx + "/.local/share/".Length); // UnityMCP/...
-						serverSrc = System.IO.Path.Combine(home, "Library", "Application Support", suffix);
-					}
-				}
-			}
-			catch { }
-
-			// Hard-block PackageCache on Windows unless dev override is set
-			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
-				&& !string.IsNullOrEmpty(serverSrc)
-				&& serverSrc.IndexOf(@"\Library\PackageCache\", StringComparison.OrdinalIgnoreCase) >= 0
-				&& !UnityEditor.EditorPrefs.GetBool("MCPForUnity.UseEmbeddedServer", false))
-			{
-				serverSrc = ServerInstaller.GetServerPath();
-			}
-
-			// 2) Canonical args order
-			var newArgs = new[] { "run", "--directory", serverSrc, "server.py" };
-
-			// 3) Only write if changed
-			var changed = !string.Equals(existingCommand, uvPath, StringComparison.Ordinal)
-				|| !ArgsEqual(existingArgs, newArgs);
-			if (!changed)
-			{
-				return "Configured successfully"; // nothing to do
-			}
-
-			// 4) Ensure containers exist and write back minimal changes
-            JObject existingRoot;
-            if (existingConfig is JObject eo)
-                existingRoot = eo;
-            else
-                existingRoot = JObject.FromObject(existingConfig);
-
-            existingRoot = ConfigJsonBuilder.ApplyUnityServerToExistingConfig(existingRoot, uvPath, serverSrc, mcpClient);
-
-			var mergedJson = JsonConvert.SerializeObject(existingRoot, jsonSettings);
-
-			// Robust atomic write without redundant backup or race on existence
-			var tmp = configPath + ".tmp";
-			var backup = configPath + ".backup";
-			var writeDone = false;
-			try
-			{
-				// Write to temp file first (in same directory for atomicity)
-				System.IO.File.WriteAllText(tmp, mergedJson, new System.Text.UTF8Encoding(false));
-
-				try
-				{
-					// Try atomic replace; creates 'backup' only on success (platform-dependent)
-					System.IO.File.Replace(tmp, configPath, backup);
-					writeDone = true;
-				}
-				catch (System.IO.FileNotFoundException)
-				{
-					// Destination didn't exist; fall back to move
-					System.IO.File.Move(tmp, configPath);
-                    writeDone = true;
-				}
-				catch (System.PlatformNotSupportedException)
-				{
-					// Fallback: rename existing to backup, then move tmp into place
-					if (System.IO.File.Exists(configPath))
-					{
-						try { if (System.IO.File.Exists(backup)) System.IO.File.Delete(backup); } catch { }
-						System.IO.File.Move(configPath, backup);
-					}
-					System.IO.File.Move(tmp, configPath);
-					writeDone = true;
-				}
-			}
-			catch (Exception ex)
-			{
-
-				// If write did not complete, attempt restore from backup without deleting current file first
-				try
-				{
-					if (!writeDone && System.IO.File.Exists(backup))
-					{
-						try { System.IO.File.Copy(backup, configPath, true); } catch { }
-					}
-				}
-				catch { }
-				throw new Exception($"Failed to write config file '{configPath}': {ex.Message}", ex);
-			}
-			finally
-			{
-				// Best-effort cleanup of temp
-				try { if (System.IO.File.Exists(tmp)) System.IO.File.Delete(tmp); } catch { }
-				// Only remove backup after a confirmed successful write
-				try { if (writeDone && System.IO.File.Exists(backup)) System.IO.File.Delete(backup); } catch { }
-			}
-
-			try
-			{
-				if (IsValidUv(uvPath)) UnityEditor.EditorPrefs.SetString("MCPForUnity.UvPath", uvPath);
-				UnityEditor.EditorPrefs.SetString("MCPForUnity.ServerSrc", serverSrc);
-			}
-			catch { }
-
-			return "Configured successfully";
-        }
-
-        private void ShowManualConfigurationInstructions(
-            string configPath,
-            McpClient mcpClient
-        )
-        {
-            mcpClient.SetStatus(McpStatus.Error, "Manual configuration required");
-
-            ShowManualInstructionsWindow(configPath, mcpClient);
-        }
-
-        // New method to show manual instructions without changing status
-        private void ShowManualInstructionsWindow(string configPath, McpClient mcpClient)
-        {
-            // Get the Python directory path using Package Manager API
-            var pythonDir = FindPackagePythonDirectory();
-            // Build manual JSON centrally using the shared builder
-            var uvPathForManual = FindUvPath();
-            if (uvPathForManual == null)
-            {
-                UnityEngine.Debug.LogError("UV package manager not found. Cannot generate manual configuration.");
-                return;
-            }
-
-            var manualConfigJson = ConfigJsonBuilder.BuildManualConfigJson(uvPathForManual, pythonDir, mcpClient);
-            ManualConfigEditorWindow.ShowWindow(configPath, manualConfigJson, mcpClient);
-        }
-
-		private static string ResolveServerSrc()
-		{
-			try
-			{
-				var remembered = UnityEditor.EditorPrefs.GetString("MCPForUnity.ServerSrc", string.Empty);
-				if (!string.IsNullOrEmpty(remembered) && File.Exists(Path.Combine(remembered, "server.py")))
-				{
-					return remembered;
-				}
-
-				ServerInstaller.EnsureServerInstalled();
-				var installed = ServerInstaller.GetServerPath();
-				if (File.Exists(Path.Combine(installed, "server.py")))
-				{
-					return installed;
-				}
-
-				var useEmbedded = UnityEditor.EditorPrefs.GetBool("MCPForUnity.UseEmbeddedServer", false);
-				if (useEmbedded && ServerPathResolver.TryFindEmbeddedServerSource(out var embedded)
-					&& File.Exists(Path.Combine(embedded, "server.py")))
-				{
-					return embedded;
-				}
-
-				return installed;
-			}
-			catch { return ServerInstaller.GetServerPath(); }
-		}
-
-		private string FindPackagePythonDirectory()
-        {
-			var pythonDir = ResolveServerSrc();
-
-            try
-            {
-                // Only check dev paths if we're using a file-based package (development mode)
-                var isDevelopmentMode = IsDevelopmentMode();
-                if (isDevelopmentMode)
-                {
-                    var currentPackagePath = Path.GetDirectoryName(Application.dataPath);
-                    string[] devPaths = {
-                        Path.Combine(currentPackagePath, "unity-mcp", "UnityMcpServer", "src"),
-                        Path.Combine(Path.GetDirectoryName(currentPackagePath), "unity-mcp", "UnityMcpServer", "src"),
-                    };
-
-                    foreach (var devPath in devPaths)
-                    {
-                        if (Directory.Exists(devPath) && File.Exists(Path.Combine(devPath, "server.py")))
-                        {
-                            if (debugLogsEnabled)
-                            {
-                                UnityEngine.Debug.Log($"Currently in development mode. Package: {devPath}");
-                            }
-                            return devPath;
-                        }
-                    }
-                }
-
-				// Resolve via shared helper (handles local registry and older fallback) only if dev override on
-				if (UnityEditor.EditorPrefs.GetBool("MCPForUnity.UseEmbeddedServer", false))
-				{
-					if (ServerPathResolver.TryFindEmbeddedServerSource(out var embedded))
-					{
-						return embedded;
-					}
-				}
-
-				// Log only if the resolved path does not actually contain server.py
-				if (debugLogsEnabled)
-				{
-					var hasServer = false;
-					try { hasServer = File.Exists(Path.Combine(pythonDir, "server.py")); } catch { }
-					if (!hasServer)
-					{
-						UnityEngine.Debug.LogWarning("Could not find Python directory with server.py; falling back to installed path");
-					}
-				}
-            }
-            catch (Exception e)
-            {
-                UnityEngine.Debug.LogError($"Error finding package path: {e.Message}");
-            }
-
-            return pythonDir;
-        }
-
-        private bool IsDevelopmentMode()
-        {
-            try
-            {
-                // Only treat as development if manifest explicitly references a local file path for the package
-                var manifestPath = Path.Combine(Application.dataPath, "..", "Packages", "manifest.json");
-                if (!File.Exists(manifestPath)) return false;
-
-                var manifestContent = File.ReadAllText(manifestPath);
-                // Look specifically for our package dependency set to a file: URL
-                // This avoids auto-enabling dev mode just because a repo exists elsewhere on disk
-                if (manifestContent.IndexOf("\"com.justinpbarnett.unity-mcp\"", StringComparison.OrdinalIgnoreCase) >= 0)
-                {
-                    var idx = manifestContent.IndexOf("com.justinpbarnett.unity-mcp", StringComparison.OrdinalIgnoreCase);
-                    // Crude but effective: check for "file:" in the same line/value
-                    if (manifestContent.IndexOf("file:", idx, StringComparison.OrdinalIgnoreCase) >= 0
-                        && manifestContent.IndexOf("\n", idx, StringComparison.OrdinalIgnoreCase) > manifestContent.IndexOf("file:", idx, StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                }
-                return false;
-            }
-            catch
-            {
-                return false;
-            }
-        }
-
-        private string ConfigureMcpClient(McpClient mcpClient)
-        {
-            try
-            {
-                // Determine the config file path based on OS
-                string configPath;
-
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    configPath = mcpClient.windowsConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
-                )
-                {
-                    configPath = string.IsNullOrEmpty(mcpClient.macConfigPath)
-                        ? mcpClient.linuxConfigPath
-                        : mcpClient.macConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
-                )
-                {
-                    configPath = mcpClient.linuxConfigPath;
-                }
-                else
-                {
-                    return "Unsupported OS";
-                }
-
-                // Create directory if it doesn't exist
-                Directory.CreateDirectory(Path.GetDirectoryName(configPath));
-
-                // Find the server.py file location using the same logic as FindPackagePythonDirectory
-                var pythonDir = FindPackagePythonDirectory();
-
-                if (pythonDir == null || !File.Exists(Path.Combine(pythonDir, "server.py")))
-                {
-                    ShowManualInstructionsWindow(configPath, mcpClient);
-                    return "Manual Configuration Required";
-                }
-
-                var result = WriteToConfig(pythonDir, configPath, mcpClient);
-
-                // Update the client status after successful configuration
-                if (result == "Configured successfully")
-                {
-                    mcpClient.SetStatus(McpStatus.Configured);
-                }
-
-                return result;
-            }
-            catch (Exception e)
-            {
-                // Determine the config file path based on OS for error message
-                var configPath = "";
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    configPath = mcpClient.windowsConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
-                )
-                {
-                    configPath = string.IsNullOrEmpty(mcpClient.macConfigPath)
-                        ? mcpClient.linuxConfigPath
-                        : mcpClient.macConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
-                )
-                {
-                    configPath = mcpClient.linuxConfigPath;
-                }
-
-                ShowManualInstructionsWindow(configPath, mcpClient);
-                UnityEngine.Debug.LogError(
-                    $"Failed to configure {mcpClient.name}: {e.Message}\n{e.StackTrace}"
-                );
-                return $"Failed to configure {mcpClient.name}";
-            }
-        }
-
-        private void ShowCursorManualConfigurationInstructions(
-            string configPath,
-            McpClient mcpClient
-        )
-        {
-            mcpClient.SetStatus(McpStatus.Error, "Manual configuration required");
-
-            // Get the Python directory path using Package Manager API
-            var pythonDir = FindPackagePythonDirectory();
-
-            // Create the manual configuration message
-            var uvPath = FindUvPath();
-            if (uvPath == null)
-            {
-                UnityEngine.Debug.LogError("UV package manager not found. Cannot configure manual setup.");
-                return;
-            }
-
-            McpConfig jsonConfig = new()
-            {
-                mcpServers = new McpConfigServers
-                {
-                    unityMCP = new McpConfigServer
-                    {
-                        command = uvPath,
-                        args = new[] { "run", "--directory", pythonDir, "server.py" },
-                    },
-                },
-            };
-
-            JsonSerializerSettings jsonSettings = new() { Formatting = Formatting.Indented };
-            var manualConfigJson = JsonConvert.SerializeObject(jsonConfig, jsonSettings);
-
-            ManualConfigEditorWindow.ShowWindow(configPath, manualConfigJson, mcpClient);
-        }
-
-        private void LoadValidationLevelSetting()
-        {
-            var savedLevel = EditorPrefs.GetString("MCPForUnity_ScriptValidationLevel", "standard");
-            validationLevelIndex = savedLevel.ToLower() switch
-            {
-                "basic" => 0,
-                "standard" => 1,
-                "comprehensive" => 2,
-                "strict" => 3,
-                _ => 1 // Default to Standard
-            };
-        }
-
-        private void SaveValidationLevelSetting()
-        {
-            var levelString = validationLevelIndex switch
-            {
-                0 => "basic",
-                1 => "standard",
-                2 => "comprehensive",
-                3 => "strict",
-                _ => "standard"
-            };
-            EditorPrefs.SetString("MCPForUnity_ScriptValidationLevel", levelString);
-        }
-
-        private string GetValidationLevelDescription(int index)
-        {
-            return index switch
-            {
-                0 => "Only basic syntax checks (braces, quotes, comments)",
-                1 => "Syntax checks + Unity best practices and warnings",
-                2 => "All checks + semantic analysis and performance warnings",
-                3 => "Full semantic validation with namespace/type resolution (requires Roslyn)",
-                _ => "Standard validation"
-            };
-        }
-
-        public static string GetCurrentValidationLevel()
-        {
-            var savedLevel = EditorPrefs.GetString("MCPForUnity_ScriptValidationLevel", "standard");
-            return savedLevel;
-        }
-
-        private void CheckMcpConfiguration(McpClient mcpClient)
-        {
-            try
-            {
-                // Special handling for Claude Code
-                if (mcpClient.mcpType == McpTypes.ClaudeCode)
-                {
-                    CheckClaudeCodeConfiguration(mcpClient);
-                    return;
-                }
-
-                string configPath;
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    configPath = mcpClient.windowsConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
-                )
-                {
-                    configPath = string.IsNullOrEmpty(mcpClient.macConfigPath)
-                        ? mcpClient.linuxConfigPath
-                        : mcpClient.macConfigPath;
-                }
-                else if (
-                    RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
-                )
-                {
-                    configPath = mcpClient.linuxConfigPath;
-                }
-                else
-                {
-                    mcpClient.SetStatus(McpStatus.UnsupportedOS);
-                    return;
-                }
-
-                if (!File.Exists(configPath))
-                {
-                    mcpClient.SetStatus(McpStatus.NotConfigured);
-                    return;
-                }
-
-                var configJson = File.ReadAllText(configPath);
-                // Use the same path resolution as configuration to avoid false "Incorrect Path" in dev mode
-                var pythonDir = FindPackagePythonDirectory();
-
-                // Use switch statement to handle different client types, extracting common logic
-                string[] args = null;
-                var configExists = false;
-
-                switch (mcpClient.mcpType)
-                {
-                    case McpTypes.VSCode:
-                        dynamic config = JsonConvert.DeserializeObject(configJson);
-
-                        // New schema: top-level servers
-                        if (config?.servers?.unityMCP != null)
-                        {
-                            args = config.servers.unityMCP.args.ToObject<string[]>();
-                            configExists = true;
-                        }
-                        // Back-compat: legacy mcp.servers
-                        else if (config?.mcp?.servers?.unityMCP != null)
-                        {
-                            args = config.mcp.servers.unityMCP.args.ToObject<string[]>();
-                            configExists = true;
-                        }
-                        break;
-
-                    default:
-                        // Standard MCP configuration check for Claude Desktop, Cursor, etc.
-                        var standardConfig = JsonConvert.DeserializeObject<McpConfig>(configJson);
-
-                        if (standardConfig?.mcpServers?.unityMCP != null)
-                        {
-                            args = standardConfig.mcpServers.unityMCP.args;
-                            configExists = true;
-                        }
-                        break;
-                }
-
-                // Common logic for checking configuration status
-                if (configExists)
-                {
-                    var configuredDir = ExtractDirectoryArg(args);
-                    var matches = !string.IsNullOrEmpty(configuredDir) && PathsEqual(configuredDir, pythonDir);
-                    if (matches)
-                    {
-                        mcpClient.SetStatus(McpStatus.Configured);
-                    }
-                    else
-                    {
-                        // Attempt auto-rewrite once if the package path changed
-                        try
-                        {
-                            var rewriteResult = WriteToConfig(pythonDir, configPath, mcpClient);
-                            if (rewriteResult == "Configured successfully")
-                            {
-                                if (debugLogsEnabled)
-                                {
-                                    MCPForUnity.Editor.Helpers.McpLog.Info($"Auto-updated MCP config for '{mcpClient.name}' to new path: {pythonDir}", always: false);
-                                }
-                                mcpClient.SetStatus(McpStatus.Configured);
-                            }
-                            else
-                            {
-                                mcpClient.SetStatus(McpStatus.IncorrectPath);
-                            }
-                        }
-                        catch (Exception ex)
-                        {
-                            mcpClient.SetStatus(McpStatus.IncorrectPath);
-                            if (debugLogsEnabled)
-                            {
-                                UnityEngine.Debug.LogWarning($"MCP for Unity: Auto-config rewrite failed for '{mcpClient.name}': {ex.Message}");
-                            }
-                        }
-                    }
-                }
-                else
-                {
-                    mcpClient.SetStatus(McpStatus.MissingConfig);
-                }
-            }
-            catch (Exception e)
-            {
-                mcpClient.SetStatus(McpStatus.Error, e.Message);
-            }
-        }
-
-        private void RegisterWithClaudeCode(string pythonDir)
-        {
-            // Resolve claude and uv; then run register command
-            var claudePath = ExecPath.ResolveClaude();
-            if (string.IsNullOrEmpty(claudePath))
-            {
-                UnityEngine.Debug.LogError("MCP for Unity: Claude CLI not found. Set a path in this window or install the CLI, then try again.");
-                return;
-            }
-            var uvPath = ExecPath.ResolveUv() ?? "uv";
-
-            // Prefer embedded/dev path when available
-            var srcDir = !string.IsNullOrEmpty(pythonDirOverride) ? pythonDirOverride : FindPackagePythonDirectory();
-            if (string.IsNullOrEmpty(srcDir)) srcDir = pythonDir;
-
-            var args = $"mcp add UnityMCP -- \"{uvPath}\" run --directory \"{srcDir}\" server.py";
-
-            var projectDir = Path.GetDirectoryName(Application.dataPath);
-            // Ensure PATH includes common locations on Unix; on Windows leave PATH as-is
-            string pathPrepend = null;
-            if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.LinuxEditor)
-            {
-                pathPrepend = Application.platform == RuntimePlatform.OSXEditor
-                    ? "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin"
-                    : "/usr/local/bin:/usr/bin:/bin";
-            }
-            if (!ExecPath.TryRun(claudePath, args, projectDir, out var stdout, out var stderr, 15000, pathPrepend))
-            {
-                var combined = ($"{stdout}\n{stderr}") ?? string.Empty;
-                if (combined.IndexOf("already exists", StringComparison.OrdinalIgnoreCase) >= 0)
-                {
-                    // Treat as success if Claude reports existing registration
-                    var existingClient = mcpClients.clients.FirstOrDefault(c => c.mcpType == McpTypes.ClaudeCode);
-                    if (existingClient != null) CheckClaudeCodeConfiguration(existingClient);
-                    Repaint();
-                    UnityEngine.Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: MCP for Unity already registered with Claude Code.");
-                }
-                else
-                {
-                    UnityEngine.Debug.LogError($"MCP for Unity: Failed to start Claude CLI.\n{stderr}\n{stdout}");
-                }
-                return;
-            }
-
-            // Update status
-            var claudeClient = mcpClients.clients.FirstOrDefault(c => c.mcpType == McpTypes.ClaudeCode);
-            if (claudeClient != null) CheckClaudeCodeConfiguration(claudeClient);
-            Repaint();
-            UnityEngine.Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Registered with Claude Code.");
-        }
-
-        private void UnregisterWithClaudeCode()
-        {
-            var claudePath = ExecPath.ResolveClaude();
-            if (string.IsNullOrEmpty(claudePath))
-            {
-                UnityEngine.Debug.LogError("MCP for Unity: Claude CLI not found. Set a path in this window or install the CLI, then try again.");
-                return;
-            }
-
-            var projectDir = Path.GetDirectoryName(Application.dataPath);
-            var pathPrepend = Application.platform == RuntimePlatform.OSXEditor
-                ? "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin"
-                : null; // On Windows, don't modify PATH - use system PATH as-is
-
-			// Determine if Claude has a "UnityMCP" server registered by using exit codes from `claude mcp get <name>`
-			string[] candidateNamesForGet = { "UnityMCP", "unityMCP", "unity-mcp", "UnityMcpServer" };
-			var existingNames = new List<string>();
-			foreach (var candidate in candidateNamesForGet)
-			{
-				if (ExecPath.TryRun(claudePath, $"mcp get {candidate}", projectDir, out var getStdout, out var getStderr, 7000, pathPrepend))
-				{
-					// Success exit code indicates the server exists
-					existingNames.Add(candidate);
-				}
-			}
-
-			if (existingNames.Count == 0)
-			{
-				// Nothing to unregister – set status and bail early
-				var claudeClient = mcpClients.clients.FirstOrDefault(c => c.mcpType == McpTypes.ClaudeCode);
-				if (claudeClient != null)
-				{
-					claudeClient.SetStatus(McpStatus.NotConfigured);
-					UnityEngine.Debug.Log("Claude CLI reports no MCP for Unity server via 'mcp get' - setting status to NotConfigured and aborting unregister.");
-					Repaint();
-				}
-				return;
-			}
-
-            // Try different possible server names
-            string[] possibleNames = { "UnityMCP", "unityMCP", "unity-mcp", "UnityMcpServer" };
-            var success = false;
-
-            foreach (var serverName in possibleNames)
-            {
-                if (ExecPath.TryRun(claudePath, $"mcp remove {serverName}", projectDir, out var stdout, out var stderr, 10000, pathPrepend))
-                {
-                    success = true;
-                    UnityEngine.Debug.Log($"MCP for Unity: Successfully removed MCP server: {serverName}");
-                    break;
-                }
-                else if (!string.IsNullOrEmpty(stderr) &&
-                         !stderr.Contains("No MCP server found", StringComparison.OrdinalIgnoreCase))
-                {
-                    // If it's not a "not found" error, log it and stop trying
-                    UnityEngine.Debug.LogWarning($"Error removing {serverName}: {stderr}");
-                    break;
-                }
-            }
-
-            if (success)
-            {
-                var claudeClient = mcpClients.clients.FirstOrDefault(c => c.mcpType == McpTypes.ClaudeCode);
-                if (claudeClient != null)
-                {
-                    // Optimistically flip to NotConfigured; then verify
-                    claudeClient.SetStatus(McpStatus.NotConfigured);
-                    CheckClaudeCodeConfiguration(claudeClient);
-                }
-                Repaint();
-                UnityEngine.Debug.Log("MCP for Unity: MCP server successfully unregistered from Claude Code.");
-            }
-            else
-            {
-                // If no servers were found to remove, they're already unregistered
-                // Force status to NotConfigured and update the UI
-                UnityEngine.Debug.Log("No MCP servers found to unregister - already unregistered.");
-                var claudeClient = mcpClients.clients.FirstOrDefault(c => c.mcpType == McpTypes.ClaudeCode);
-                if (claudeClient != null)
-                {
-                    claudeClient.SetStatus(McpStatus.NotConfigured);
-                    CheckClaudeCodeConfiguration(claudeClient);
-                }
-                Repaint();
-            }
-        }
-
-        // Removed unused ParseTextOutput
-
-        private string FindUvPath()
-        {
-            try { return MCPForUnity.Editor.Helpers.ServerInstaller.FindUvPath(); } catch { return null; }
-        }
-
-        // Validation and platform-specific scanning are handled by ServerInstaller.FindUvPath()
-
-        // Windows-specific discovery removed; use ServerInstaller.FindUvPath() instead
-
-        // Removed unused FindClaudeCommand
-
-        private void CheckClaudeCodeConfiguration(McpClient mcpClient)
-        {
-            try
-            {
-                // Get the Unity project directory to check project-specific config
-                var unityProjectDir = Application.dataPath;
-                var projectDir = Path.GetDirectoryName(unityProjectDir);
-
-                // Read the global Claude config file (honor macConfigPath on macOS)
-                string configPath;
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                    configPath = mcpClient.windowsConfigPath;
-                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
-                    configPath = string.IsNullOrEmpty(mcpClient.macConfigPath) ? mcpClient.linuxConfigPath : mcpClient.macConfigPath;
-                else
-                    configPath = mcpClient.linuxConfigPath;
-
-                if (debugLogsEnabled)
-                {
-                    MCPForUnity.Editor.Helpers.McpLog.Info($"Checking Claude config at: {configPath}", always: false);
-                }
-
-                if (!File.Exists(configPath))
-                {
-                    UnityEngine.Debug.LogWarning($"Claude config file not found at: {configPath}");
-                    mcpClient.SetStatus(McpStatus.NotConfigured);
-                    return;
-                }
-
-                var configJson = File.ReadAllText(configPath);
-                dynamic claudeConfig = JsonConvert.DeserializeObject(configJson);
-
-                // Check for "UnityMCP" server in the mcpServers section (current format)
-                if (claudeConfig?.mcpServers != null)
-                {
-                    var servers = claudeConfig.mcpServers;
-                    if (servers.UnityMCP != null || servers.unityMCP != null)
-                    {
-                        // Found MCP for Unity configured
-                        mcpClient.SetStatus(McpStatus.Configured);
-                        return;
-                    }
-                }
-
-                // Also check if there's a project-specific configuration for this Unity project (legacy format)
-                if (claudeConfig?.projects != null)
-                {
-                    // Look for the project path in the config
-                    foreach (var project in claudeConfig.projects)
-                    {
-                        string projectPath = project.Name;
-
-                        // Normalize paths for comparison (handle forward/back slash differences)
-                        var normalizedProjectPath = Path.GetFullPath(projectPath).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
-                        var normalizedProjectDir = Path.GetFullPath(projectDir).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
-
-                        if (string.Equals(normalizedProjectPath, normalizedProjectDir, StringComparison.OrdinalIgnoreCase) && project.Value?.mcpServers != null)
-                        {
-                            // Check for "UnityMCP" (case variations)
-                            var servers = project.Value.mcpServers;
-                            if (servers.UnityMCP != null || servers.unityMCP != null)
-                            {
-                                // Found MCP for Unity configured for this project
-                                mcpClient.SetStatus(McpStatus.Configured);
-                                return;
-                            }
-                        }
-                    }
-                }
-
-                // No configuration found for this project
-                mcpClient.SetStatus(McpStatus.NotConfigured);
-            }
-            catch (Exception e)
-            {
-                UnityEngine.Debug.LogWarning($"Error checking Claude Code config: {e.Message}");
-                mcpClient.SetStatus(McpStatus.Error, e.Message);
-            }
-        }
-
-        private bool IsPythonDetected()
-        {
-            try
-            {
-                // Windows-specific Python detection
-                if (Application.platform == RuntimePlatform.WindowsEditor)
-                {
-                    // Common Windows Python installation paths
-                    string[] windowsCandidates =
-                    {
-                        @"C:\Python313\python.exe",
-                        @"C:\Python312\python.exe",
-                        @"C:\Python311\python.exe",
-                        @"C:\Python310\python.exe",
-                        @"C:\Python39\python.exe",
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Programs\Python\Python313\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Programs\Python\Python312\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Programs\Python\Python311\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Programs\Python\Python310\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Programs\Python\Python39\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Python313\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Python312\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Python311\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Python310\python.exe"),
-                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Python39\python.exe"),
-                    };
-
-                    foreach (var c in windowsCandidates)
-                    {
-                        if (File.Exists(c)) return true;
-                    }
-
-                    // Try 'where python' command (Windows equivalent of 'which')
-                    var psi = new ProcessStartInfo
-                    {
-                        FileName = "where",
-                        Arguments = "python",
-                        UseShellExecute = false,
-                        RedirectStandardOutput = true,
-                        RedirectStandardError = true,
-                        CreateNoWindow = true
-                    };
-                    using var p = Process.Start(psi);
-                    var outp = p.StandardOutput.ReadToEnd().Trim();
-                    p.WaitForExit(2000);
-                    if (p.ExitCode == 0 && !string.IsNullOrEmpty(outp))
-                    {
-                        var lines = outp.Split('\n');
-                        foreach (var line in lines)
-                        {
-                            var trimmed = line.Trim();
-                            if (File.Exists(trimmed)) return true;
-                        }
-                    }
-                }
-                else
-                {
-                    // macOS/Linux detection (existing code)
-                    var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                    string[] candidates =
-                    {
-                        "/opt/homebrew/bin/python3",
-                        "/usr/local/bin/python3",
-                        "/usr/bin/python3",
-                        "/opt/local/bin/python3",
-                        Path.Combine(home, ".local", "bin", "python3"),
-                        "/Library/Frameworks/Python.framework/Versions/3.13/bin/python3",
-                        "/Library/Frameworks/Python.framework/Versions/3.12/bin/python3",
-                    };
-                    foreach (var c in candidates)
-                    {
-                        if (File.Exists(c)) return true;
-                    }
-
-                    // Try 'which python3'
-                    var psi = new ProcessStartInfo
-                    {
-                        FileName = "/usr/bin/which",
-                        Arguments = "python3",
-                        UseShellExecute = false,
-                        RedirectStandardOutput = true,
-                        RedirectStandardError = true,
-                        CreateNoWindow = true
-                    };
-                    using var p = Process.Start(psi);
-                    var outp = p.StandardOutput.ReadToEnd().Trim();
-                    p.WaitForExit(2000);
-                    if (p.ExitCode == 0 && !string.IsNullOrEmpty(outp) && File.Exists(outp)) return true;
-                }
-            }
-            catch { }
-            return false;
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/README.md.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/README.md.meta b/Packages/UnityMcpBridge/README.md.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/README.md.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,7 +0,0 @@
-fileFormatVersion: 2
-guid: c3d9e362fb93e46f59ce7213fbe4f2b1
-TextScriptImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Data.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Data.meta b/Packages/UnityMcpBridge/Editor/Data.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Data.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: e59036660cc33d24596fbbf6d4657a83
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/McpConfig.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs b/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,12 +0,0 @@
-using System;
-using Newtonsoft.Json;
-
-namespace MCPForUnity.Editor.Models
-{
-    [Serializable]
-    public class McpConfig
-    {
-        [JsonProperty("mcpServers")]
-        public McpConfigServers mcpServers;
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Models/McpConfig.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs.meta b/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpConfig.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: c17c09908f0c1524daa8b6957ce1f7f5
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Windows.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows.meta b/Packages/UnityMcpBridge/Editor/Windows.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: d2ee39f5d4171184eb208e865c1ef4c1
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs b/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,280 +0,0 @@
-using System;
-using System.Diagnostics;
-using System.IO;
-using System.Linq;
-using System.Text;
-using System.Runtime.InteropServices;
-using UnityEditor;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    internal static class ExecPath
-    {
-        private const string PrefClaude = "MCPForUnity.ClaudeCliPath";
-
-        // Resolve Claude CLI absolute path. Pref → env → common locations → PATH.
-        internal static string ResolveClaude()
-        {
-            try
-            {
-                var pref = EditorPrefs.GetString(PrefClaude, string.Empty);
-                if (!string.IsNullOrEmpty(pref) && File.Exists(pref)) return pref;
-            }
-            catch { }
-
-            var env = Environment.GetEnvironmentVariable("CLAUDE_CLI");
-            if (!string.IsNullOrEmpty(env) && File.Exists(env)) return env;
-
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
-            {
-                var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                string[] candidates =
-                {
-                    "/opt/homebrew/bin/claude",
-                    "/usr/local/bin/claude",
-                    Path.Combine(home, ".local", "bin", "claude"),
-                };
-                foreach (var c in candidates) { if (File.Exists(c)) return c; }
-                // Try NVM-installed claude under ~/.nvm/versions/node/*/bin/claude
-                var nvmClaude = ResolveClaudeFromNvm(home);
-                if (!string.IsNullOrEmpty(nvmClaude)) return nvmClaude;
-#if UNITY_EDITOR_OSX || UNITY_EDITOR_LINUX
-                return Which("claude", "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin");
-#else
-                return null;
-#endif
-            }
-
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-#if UNITY_EDITOR_WIN
-                // Common npm global locations
-                string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) ?? string.Empty;
-                string localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) ?? string.Empty;
-                string[] candidates =
-                {
-                    // Prefer .cmd (most reliable from non-interactive processes)
-                    Path.Combine(appData, "npm", "claude.cmd"),
-                    Path.Combine(localAppData, "npm", "claude.cmd"),
-                    // Fall back to PowerShell shim if only .ps1 is present
-                    Path.Combine(appData, "npm", "claude.ps1"),
-                    Path.Combine(localAppData, "npm", "claude.ps1"),
-                };
-                foreach (string c in candidates) { if (File.Exists(c)) return c; }
-                string fromWhere = Where("claude.exe") ?? Where("claude.cmd") ?? Where("claude.ps1") ?? Where("claude");
-                if (!string.IsNullOrEmpty(fromWhere)) return fromWhere;
-#endif
-                return null;
-            }
-
-            // Linux
-            {
-                var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                string[] candidates =
-                {
-                    "/usr/local/bin/claude",
-                    "/usr/bin/claude",
-                    Path.Combine(home, ".local", "bin", "claude"),
-                };
-                foreach (var c in candidates) { if (File.Exists(c)) return c; }
-                // Try NVM-installed claude under ~/.nvm/versions/node/*/bin/claude
-                var nvmClaude = ResolveClaudeFromNvm(home);
-                if (!string.IsNullOrEmpty(nvmClaude)) return nvmClaude;
-#if UNITY_EDITOR_OSX || UNITY_EDITOR_LINUX
-                return Which("claude", "/usr/local/bin:/usr/bin:/bin");
-#else
-                return null;
-#endif
-            }
-        }
-
-        // Attempt to resolve claude from NVM-managed Node installations, choosing the newest version
-        private static string ResolveClaudeFromNvm(string home)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(home)) return null;
-                var nvmNodeDir = Path.Combine(home, ".nvm", "versions", "node");
-                if (!Directory.Exists(nvmNodeDir)) return null;
-
-                string bestPath = null;
-                Version bestVersion = null;
-                foreach (var versionDir in Directory.EnumerateDirectories(nvmNodeDir))
-                {
-                    var name = Path.GetFileName(versionDir);
-                    if (string.IsNullOrEmpty(name)) continue;
-                    if (name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
-                    {
-                        // Extract numeric portion: e.g., v18.19.0-nightly -> 18.19.0
-                        var versionStr = name.Substring(1);
-                        var dashIndex = versionStr.IndexOf('-');
-                        if (dashIndex > 0)
-                        {
-                            versionStr = versionStr.Substring(0, dashIndex);
-                        }
-                        if (Version.TryParse(versionStr, out var parsed))
-                        {
-                            var candidate = Path.Combine(versionDir, "bin", "claude");
-                            if (File.Exists(candidate))
-                            {
-                                if (bestVersion == null || parsed > bestVersion)
-                                {
-                                    bestVersion = parsed;
-                                    bestPath = candidate;
-                                }
-                            }
-                        }
-                    }
-                }
-                return bestPath;
-            }
-            catch { return null; }
-        }
-
-        // Explicitly set the Claude CLI absolute path override in EditorPrefs
-        internal static void SetClaudeCliPath(string absolutePath)
-        {
-            try
-            {
-                if (!string.IsNullOrEmpty(absolutePath) && File.Exists(absolutePath))
-                {
-                    EditorPrefs.SetString(PrefClaude, absolutePath);
-                }
-            }
-            catch { }
-        }
-
-        // Clear any previously set Claude CLI override path
-        internal static void ClearClaudeCliPath()
-        {
-            try
-            {
-                if (EditorPrefs.HasKey(PrefClaude))
-                {
-                    EditorPrefs.DeleteKey(PrefClaude);
-                }
-            }
-            catch { }
-        }
-
-        // Use existing UV resolver; returns absolute path or null.
-        internal static string ResolveUv()
-        {
-            return ServerInstaller.FindUvPath();
-        }
-
-        internal static bool TryRun(
-            string file,
-            string args,
-            string workingDir,
-            out string stdout,
-            out string stderr,
-            int timeoutMs = 15000,
-            string extraPathPrepend = null)
-        {
-            stdout = string.Empty;
-            stderr = string.Empty;
-            try
-            {
-                // Handle PowerShell scripts on Windows by invoking through powershell.exe
-                var isPs1 = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) &&
-                             file.EndsWith(".ps1", StringComparison.OrdinalIgnoreCase);
-
-                var psi = new ProcessStartInfo
-                {
-                    FileName = isPs1 ? "powershell.exe" : file,
-                    Arguments = isPs1
-                        ? $"-NoProfile -ExecutionPolicy Bypass -File \"{file}\" {args}".Trim()
-                        : args,
-                    WorkingDirectory = string.IsNullOrEmpty(workingDir) ? Environment.CurrentDirectory : workingDir,
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    RedirectStandardError = true,
-                    CreateNoWindow = true,
-                };
-                if (!string.IsNullOrEmpty(extraPathPrepend))
-                {
-                    var currentPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
-                    psi.EnvironmentVariables["PATH"] = string.IsNullOrEmpty(currentPath)
-                        ? extraPathPrepend
-                        : (extraPathPrepend + System.IO.Path.PathSeparator + currentPath);
-                }
-
-                using var process = new Process { StartInfo = psi, EnableRaisingEvents = false };
-
-                var so = new StringBuilder();
-                var se = new StringBuilder();
-                process.OutputDataReceived += (_, e) => { if (e.Data != null) so.AppendLine(e.Data); };
-                process.ErrorDataReceived  += (_, e) => { if (e.Data != null) se.AppendLine(e.Data); };
-
-                if (!process.Start()) return false;
-
-                process.BeginOutputReadLine();
-                process.BeginErrorReadLine();
-
-                if (!process.WaitForExit(timeoutMs))
-                {
-                    try { process.Kill(); } catch { }
-                    return false;
-                }
-
-                // Ensure async buffers are flushed
-                process.WaitForExit();
-
-                stdout = so.ToString();
-                stderr = se.ToString();
-                return process.ExitCode == 0;
-            }
-            catch
-            {
-                return false;
-            }
-        }
-
-#if UNITY_EDITOR_OSX || UNITY_EDITOR_LINUX
-        private static string Which(string exe, string prependPath)
-        {
-            try
-            {
-                var psi = new ProcessStartInfo("/usr/bin/which", exe)
-                {
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    CreateNoWindow = true,
-                };
-                var path = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
-                psi.EnvironmentVariables["PATH"] = string.IsNullOrEmpty(path) ? prependPath : (prependPath + Path.PathSeparator + path);
-                using var p = Process.Start(psi);
-                var output = p?.StandardOutput.ReadToEnd().Trim();
-                p?.WaitForExit(1500);
-                return (!string.IsNullOrEmpty(output) && File.Exists(output)) ? output : null;
-            }
-            catch { return null; }
-        }
-#endif
-
-#if UNITY_EDITOR_WIN
-        private static string Where(string exe)
-        {
-            try
-            {
-                var psi = new ProcessStartInfo("where", exe)
-                {
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    CreateNoWindow = true,
-                };
-                using var p = Process.Start(psi);
-                string first = p?.StandardOutput.ReadToEnd()
-                    .Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
-                    .FirstOrDefault();
-                p?.WaitForExit(1500);
-                return (!string.IsNullOrEmpty(first) && File.Exists(first)) ? first : null;
-            }
-            catch { return null; }
-        }
-#endif
-    }
-}
-
-
Index: Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs.meta b/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 5fae9d995f514e9498e9613e2cdbeca9
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs b/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,109 +0,0 @@
-using UnityEditor;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Auto-runs legacy/older install detection on package load/update (log-only).
-    /// Runs once per embedded server version using an EditorPrefs version-scoped key.
-    /// </summary>
-    [InitializeOnLoad]
-    public static class PackageDetector
-    {
-        private const string DetectOnceFlagKeyPrefix = "MCPForUnity.LegacyDetectLogged:";
-
-        static PackageDetector()
-        {
-            try
-            {
-                var pkgVer = ReadPackageVersionOrFallback();
-                var key = DetectOnceFlagKeyPrefix + pkgVer;
-
-                // Always force-run if legacy roots exist or canonical install is missing
-                var legacyPresent = LegacyRootsExist();
-                var canonicalMissing = !System.IO.File.Exists(System.IO.Path.Combine(ServerInstaller.GetServerPath(), "server.py"));
-
-                if (!EditorPrefs.GetBool(key, false) || legacyPresent || canonicalMissing)
-                {
-                    // Marshal the entire flow to the main thread. EnsureServerInstalled may touch Unity APIs.
-                    EditorApplication.delayCall += () =>
-                    {
-                        string error = null;
-                        System.Exception capturedEx = null;
-                        try
-                        {
-                            // Ensure any UnityEditor API usage inside runs on the main thread
-                            ServerInstaller.EnsureServerInstalled();
-                        }
-                        catch (System.Exception ex)
-                        {
-                            error = ex.Message;
-                            capturedEx = ex;
-                        }
-
-                        // Unity APIs must stay on main thread
-                        try { EditorPrefs.SetBool(key, true); } catch { }
-                        // Ensure prefs cleanup happens on main thread
-                        try { EditorPrefs.DeleteKey("MCPForUnity.ServerSrc"); } catch { }
-                        try { EditorPrefs.DeleteKey("MCPForUnity.PythonDirOverride"); } catch { }
-
-                        if (!string.IsNullOrEmpty(error))
-                        {
-                            Debug.LogWarning($"MCP for Unity: Auto-detect on load failed: {capturedEx}");
-                            // Alternatively: Debug.LogException(capturedEx);
-                        }
-                    };
-                }
-            }
-            catch { /* ignore */ }
-        }
-
-        private static string ReadEmbeddedVersionOrFallback()
-        {
-            try
-            {
-                if (ServerPathResolver.TryFindEmbeddedServerSource(out var embeddedSrc))
-                {
-                    var p = System.IO.Path.Combine(embeddedSrc, "server_version.txt");
-                    if (System.IO.File.Exists(p))
-                        return (System.IO.File.ReadAllText(p)?.Trim() ?? "unknown");
-                }
-            }
-            catch { }
-            return "unknown";
-        }
-
-        private static string ReadPackageVersionOrFallback()
-        {
-            try
-            {
-                var info = UnityEditor.PackageManager.PackageInfo.FindForAssembly(typeof(PackageDetector).Assembly);
-                if (info != null && !string.IsNullOrEmpty(info.version)) return info.version;
-            }
-            catch { }
-            // Fallback to embedded server version if package info unavailable
-            return ReadEmbeddedVersionOrFallback();
-        }
-
-        private static bool LegacyRootsExist()
-        {
-            try
-            {
-                var home = System.Environment.GetFolderPath(System.Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                string[] roots =
-                {
-                    System.IO.Path.Combine(home, ".config", "UnityMCP", "UnityMcpServer", "src"),
-                    System.IO.Path.Combine(home, ".local", "share", "UnityMCP", "UnityMcpServer", "src"),
-                };
-                foreach (var r in roots)
-                {
-                    try { if (System.IO.File.Exists(System.IO.Path.Combine(r, "server.py"))) return true; } catch { }
-                }
-            }
-            catch { }
-            return false;
-        }
-    }
-}
-
-
Index: Packages/UnityMcpBridge/Editor/Models.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models.meta b/Packages/UnityMcpBridge/Editor/Models.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: 16d3ab36890b6c14f9afeabee30e03e3
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/package.json
===================================================================
diff --git a/Packages/UnityMcpBridge/package.json b/Packages/UnityMcpBridge/package.json
deleted file mode 100644
--- a/Packages/UnityMcpBridge/package.json	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,37 +0,0 @@
-{
-  "name": "com.theonegamestudio.unity-mcp",
-  "version": "3.3.2-studio.1",
-  "displayName": "MCP for Unity - The One Game Studio Edition",
-  "description": "The One Game Studio's enhanced fork of MCP for Unity. A bridge that connects an LLM to Unity via the MCP (Model Context Protocol) with additional studio features for automation testing, Addressables management, and more.\n\nOriginal project by Coplay: https://github.com/CoplayDev/unity-mcp",
-  "unity": "2021.3",
-  "documentationUrl": "https://github.com/CoplayDev/unity-mcp",
-  "licensesUrl": "https://github.com/CoplayDev/unity-mcp/blob/main/LICENSE",
-  "dependencies": {
-    "com.unity.nuget.newtonsoft-json": "3.0.2"
-  },
-  "keywords": [
-    "unity",
-    "ai",
-    "llm",
-    "mcp",
-    "model-context-protocol",
-    "mcp-server",
-    "mcp-client",
-    "automation",
-    "testing",
-    "addressables",
-    "the-one-game-studio"
-  ],
-  "author": {
-    "name": "The One Game Studio",
-    "email": "dev@theonegamestudio.com",
-    "url": "https://theonegamestudio.com"
-  },
-  "contributors": [
-    {
-      "name": "Coplay (Original Author)",
-      "email": "support@coplay.dev",
-      "url": "https://coplay.dev"
-    }
-  ]
-}
Index: Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs b/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,47 +0,0 @@
-using System;
-using System.Collections.Generic;
-using Newtonsoft.Json.Linq;
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Registry for all MCP command handlers (Refactored Version)
-    /// </summary>
-    public static class CommandRegistry
-    {
-        // Maps command names (matching those called from Python via ctx.bridge.unity_editor.HandlerName)
-        // to the corresponding static HandleCommand method in the appropriate tool class.
-        private static readonly Dictionary<string, Func<JObject, object>> _handlers = new()
-        {
-            { "HandleManageScript", ManageScript.HandleCommand },
-            { "HandleManageScene", ManageScene.HandleCommand },
-            { "HandleManageEditor", ManageEditor.HandleCommand },
-            { "HandleManageGameObject", ManageGameObject.HandleCommand },
-            { "HandleManageAsset", ManageAsset.HandleCommand },
-            { "HandleReadConsole", ReadConsole.HandleCommand },
-            { "HandleExecuteMenuItem", ExecuteMenuItem.HandleCommand },
-            { "HandleManageShader", ManageShader.HandleCommand},
-        };
-
-        /// <summary>
-        /// Gets a command handler by name.
-        /// </summary>
-        /// <param name="commandName">Name of the command handler (e.g., "HandleManageAsset").</param>
-        /// <returns>The command handler function if found, null otherwise.</returns>
-        public static Func<JObject, object> GetHandler(string commandName)
-        {
-            // Use case-insensitive comparison for flexibility, although Python side should be consistent
-            return _handlers.TryGetValue(commandName, out var handler) ? handler : null;
-            // Consider adding logging here if a handler is not found
-            /*
-            if (_handlers.TryGetValue(commandName, out var handler)) {
-                return handler;
-            } else {
-                UnityEngine.Debug.LogError($\"[CommandRegistry] No handler found for command: {commandName}\");
-                return null;
-            }
-            */
-        }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs b/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,12 +0,0 @@
-using System;
-using Newtonsoft.Json;
-
-namespace MCPForUnity.Editor.Models
-{
-    [Serializable]
-    public class McpConfigServers
-    {
-        [JsonProperty("unityMCP")]
-        public McpConfigServer unityMCP;
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: a1b2c3d4e5f6789012345678901234ab
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Models/McpTypes.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs b/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,13 +0,0 @@
-namespace MCPForUnity.Editor.Models
-{
-    public enum McpTypes
-    {
-        ClaudeCode,
-        ClaudeDesktop,
-        Cursor,
-        VSCode,
-        Windsurf,
-        Kiro,
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs b/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,130 +0,0 @@
-using System;
-using System.Collections.Generic; // Added for HashSet
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers; // For Response class
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles executing Unity Editor menu items by path.
-    /// </summary>
-    public static class ExecuteMenuItem
-    {
-        // Basic blacklist to prevent accidental execution of potentially disruptive menu items.
-        // This can be expanded based on needs.
-        private static readonly HashSet<string> _menuPathBlacklist = new HashSet<string>(
-            StringComparer.OrdinalIgnoreCase
-        )
-        {
-            "File/Quit",
-            // Add other potentially dangerous items like "Edit/Preferences...", "File/Build Settings..." if needed
-        };
-
-        /// <summary>
-        /// Main handler for executing menu items or getting available ones.
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            var action = (@params["action"]?.ToString())?.ToLowerInvariant() ?? "execute"; // Default action
-
-            try
-            {
-                switch (action)
-                {
-                    case "execute":
-                        return ExecuteItem(@params);
-                    case "get_available_menus":
-                        // Getting a comprehensive list of *all* menu items dynamically is very difficult
-                        // and often requires complex reflection or maintaining a manual list.
-                        // Returning a placeholder/acknowledgement for now.
-                        Debug.LogWarning(
-                            "[ExecuteMenuItem] 'get_available_menus' action is not fully implemented. Dynamically listing all menu items is complex."
-                        );
-                        // Returning an empty list as per the refactor plan's requirements.
-                        return Response.Success(
-                            "'get_available_menus' action is not fully implemented. Returning empty list.",
-                            new List<string>()
-                        );
-                    // TODO: Consider implementing a basic list of common/known menu items or exploring reflection techniques if this feature becomes critical.
-                    default:
-                        return Response.Error(
-                            $"Unknown action: '{action}'. Valid actions are 'execute', 'get_available_menus'."
-                        );
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ExecuteMenuItem] Action '{action}' failed: {e}");
-                return Response.Error($"Internal error processing action '{action}': {e.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Executes a specific menu item.
-        /// </summary>
-        private static object ExecuteItem(JObject @params)
-        {
-            // Try both naming conventions: snake_case and camelCase
-            var menuPath = @params["menu_path"]?.ToString() ?? @params["menuPath"]?.ToString();
-            // Optional future param retained for API compatibility; not used in synchronous mode
-            // int timeoutMs = Math.Max(0, (@params["timeout_ms"]?.ToObject<int>() ?? 2000));
-
-            // string alias = @params["alias"]?.ToString(); // TODO: Implement alias mapping based on refactor plan requirements.
-            // JObject parameters = @params["parameters"] as JObject; // TODO: Investigate parameter passing (often not directly supported by ExecuteMenuItem).
-
-            if (string.IsNullOrWhiteSpace(menuPath))
-            {
-                return Response.Error("Required parameter 'menu_path' or 'menuPath' is missing or empty.");
-            }
-
-            // Validate against blacklist
-            if (_menuPathBlacklist.Contains(menuPath))
-            {
-                return Response.Error(
-                    $"Execution of menu item '{menuPath}' is blocked for safety reasons."
-                );
-            }
-
-            // TODO: Implement alias lookup here if needed (Map alias to actual menuPath).
-            // if (!string.IsNullOrEmpty(alias)) { menuPath = LookupAlias(alias); if(menuPath == null) return Response.Error(...); }
-
-            // TODO: Handle parameters ('parameters' object) if a viable method is found.
-            // This is complex as EditorApplication.ExecuteMenuItem doesn't take arguments directly.
-            // It might require finding the underlying EditorWindow or command if parameters are needed.
-
-            try
-            {
-                // Trace incoming execute requests (debug-gated)
-                McpLog.Info($"[ExecuteMenuItem] Request to execute menu: '{menuPath}'", always: false);
-
-                // Execute synchronously. This code runs on the Editor main thread in our bridge path.
-                var executed = EditorApplication.ExecuteMenuItem(menuPath);
-                if (executed)
-                {
-                    // Success trace (debug-gated)
-                    McpLog.Info($"[ExecuteMenuItem] Executed successfully: '{menuPath}'", always: false);
-                    return Response.Success(
-                        $"Executed menu item: '{menuPath}'",
-                        new { executed = true, menuPath }
-                    );
-                }
-                Debug.LogWarning($"[ExecuteMenuItem] Failed (not found/disabled): '{menuPath}'");
-                return Response.Error(
-                    $"Failed to execute menu item (not found or disabled): '{menuPath}'",
-                    new { executed = false, menuPath }
-                );
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ExecuteMenuItem] Error executing '{menuPath}': {e}");
-                return Response.Error($"Error executing menu item '{menuPath}': {e.Message}");
-            }
-        }
-
-        // TODO: Add helper for alias lookup if implementing aliases.
-        // private static string LookupAlias(string alias) { ... return actualMenuPath or null ... }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs.meta b/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 377fe73d52cf0435fabead5f50a0d204
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs b/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,18 +0,0 @@
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Data
-{
-    public class DefaultServerConfig : ServerConfig
-    {
-        public new string unityHost = "localhost";
-        public new int unityPort = 6400;
-        public new int mcpPort = 6500;
-        public new float connectionTimeout = 15.0f;
-        public new int bufferSize = 32768;
-        public new string logLevel = "INFO";
-        public new string logFormat = "%(asctime)s - %(name)s - %(levelname)s - %(message)s";
-        public new int maxRetries = 3;
-        public new float retryDelay = 1.0f;
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs b/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ServerPathResolver.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,150 +0,0 @@
-using System;
-using System.IO;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    public static class ServerPathResolver
-    {
-        /// <summary>
-        /// Attempts to locate the embedded UnityMcpServer/src directory inside the installed package
-        /// or common development locations. Returns true if found and sets srcPath to the folder
-        /// containing server.py.
-        /// </summary>
-        public static bool TryFindEmbeddedServerSource(out string srcPath, bool warnOnLegacyPackageId = true)
-        {
-            // 1) Repo development layouts commonly used alongside this package
-            try
-            {
-                var projectRoot = Path.GetDirectoryName(Application.dataPath);
-                string[] devCandidates =
-                {
-                    Path.Combine(projectRoot ?? string.Empty, "unity-mcp", "UnityMcpServer", "src"),
-                    Path.Combine(projectRoot ?? string.Empty, "..", "unity-mcp", "UnityMcpServer", "src"),
-                };
-                foreach (var candidate in devCandidates)
-                {
-                    var full = Path.GetFullPath(candidate);
-                    if (Directory.Exists(full) && File.Exists(Path.Combine(full, "server.py")))
-                    {
-                        srcPath = full;
-                        return true;
-                    }
-                }
-            }
-            catch { /* ignore */ }
-
-            // 2) Resolve via local package info (no network). Fall back to Client.List on older editors.
-            try
-            {
-#if UNITY_2021_2_OR_NEWER
-                // Primary: the package that owns this assembly
-                var owner = UnityEditor.PackageManager.PackageInfo.FindForAssembly(typeof(ServerPathResolver).Assembly);
-                if (owner != null)
-                {
-                    if (TryResolveWithinPackage(owner, out srcPath, warnOnLegacyPackageId))
-                    {
-                        return true;
-                    }
-                }
-
-                // Secondary: scan all registered packages locally
-                foreach (var p in UnityEditor.PackageManager.PackageInfo.GetAllRegisteredPackages())
-                {
-                    if (TryResolveWithinPackage(p, out srcPath, warnOnLegacyPackageId))
-                    {
-                        return true;
-                    }
-                }
-#else
-                // Older Unity versions: use Package Manager Client.List as a fallback
-                var list = UnityEditor.PackageManager.Client.List();
-                while (!list.IsCompleted) { }
-                if (list.Status == UnityEditor.PackageManager.StatusCode.Success)
-                {
-                    foreach (var pkg in list.Result)
-                    {
-                        if (TryResolveWithinPackage(pkg, out srcPath, warnOnLegacyPackageId))
-                        {
-                            return true;
-                        }
-                    }
-                }
-#endif
-            }
-            catch { /* ignore */ }
-
-            // 3) Fallback to previous common install locations
-            try
-            {
-                var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                string[] candidates =
-                {
-                    Path.Combine(home, "unity-mcp", "UnityMcpServer", "src"),
-                    Path.Combine(home, "Applications", "UnityMCP", "UnityMcpServer", "src"),
-                };
-                foreach (var candidate in candidates)
-                {
-                    if (Directory.Exists(candidate) && File.Exists(Path.Combine(candidate, "server.py")))
-                    {
-                        srcPath = candidate;
-                        return true;
-                    }
-                }
-            }
-            catch { /* ignore */ }
-
-            srcPath = null;
-            return false;
-        }
-
-        private static bool TryResolveWithinPackage(UnityEditor.PackageManager.PackageInfo p, out string srcPath, bool warnOnLegacyPackageId)
-        {
-            const string CurrentId = "com.theonegamestudio.unity-mcp";
-            const string LegacyId = "com.justinpbarnett.unity-mcp";
-
-            srcPath = null;
-            if (p == null || (p.name != CurrentId && p.name != LegacyId))
-            {
-                return false;
-            }
-
-            if (warnOnLegacyPackageId && p.name == LegacyId)
-            {
-                Debug.LogWarning(
-                    "MCP for Unity: Detected legacy package id 'com.justinpbarnett.unity-mcp'. " +
-                    "Please update Packages/manifest.json to 'com.theonegamestudio.unity-mcp' (The One Game Studio fork) to avoid future breakage.");
-            }
-
-            var packagePath = p.resolvedPath;
-
-            // Preferred tilde folder (embedded but excluded from import)
-            var embeddedTilde = Path.Combine(packagePath, "UnityMcpServer~", "src");
-            if (Directory.Exists(embeddedTilde) && File.Exists(Path.Combine(embeddedTilde, "server.py")))
-            {
-                srcPath = embeddedTilde;
-                return true;
-            }
-
-            // Legacy non-tilde folder
-            var embedded = Path.Combine(packagePath, "UnityMcpServer", "src");
-            if (Directory.Exists(embedded) && File.Exists(Path.Combine(embedded, "server.py")))
-            {
-                srcPath = embedded;
-                return true;
-            }
-
-            // Dev-linked sibling of the package folder
-            var sibling = Path.Combine(Path.GetDirectoryName(packagePath) ?? string.Empty, "UnityMcpServer", "src");
-            if (Directory.Exists(sibling) && File.Exists(Path.Combine(sibling, "server.py")))
-            {
-                srcPath = sibling;
-                return true;
-            }
-
-            return false;
-        }
-    }
-}
-
-
Index: Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs.meta b/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 96dc847eb7f7a45e0b91241db934a4be
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Runtime/Serialization.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime/Serialization.meta b/Packages/UnityMcpBridge/Runtime/Serialization.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime/Serialization.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: c7e33d6224fe6473f9bc69fe6d40e508
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/McpClient.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpClient.cs.meta b/Packages/UnityMcpBridge/Editor/Models/McpClient.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpClient.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: b1afa56984aec0d41808edcebf805e6a
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: bcf4f1f3110494344b2af9324cf5c571
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs b/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,25 +0,0 @@
-using Newtonsoft.Json.Linq;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Helper class for Vector3 operations
-    /// </summary>
-    public static class Vector3Helper
-    {
-        /// <summary>
-        /// Parses a JArray into a Vector3
-        /// </summary>
-        /// <param name="array">The array containing x, y, z coordinates</param>
-        /// <returns>A Vector3 with the parsed coordinates</returns>
-        /// <exception cref="System.Exception">Thrown when array is invalid</exception>
-        public static Vector3 ParseVector3(JArray array)
-        {
-            if (array == null || array.Count != 3)
-                throw new System.Exception("Vector3 must be an array of 3 floats [x, y, z].");
-            return new Vector3((float)array[0], (float)array[1], (float)array[2]);
-        }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs b/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/MCPForUnityBridge.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,1020 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Net;
-using System.Net.Sockets;
-using System.Threading;
-using System.Threading.Tasks;
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers;
-using MCPForUnity.Editor.Models;
-using MCPForUnity.Editor.Tools;
-
-namespace MCPForUnity.Editor
-{
-    [InitializeOnLoad]
-    public static partial class MCPForUnityBridge
-    {
-        private static TcpListener listener;
-        private static bool isRunning = false;
-        private static readonly object lockObj = new();
-        private static readonly object startStopLock = new();
-        private static readonly object clientsLock = new();
-        private static readonly System.Collections.Generic.HashSet<TcpClient> activeClients = new();
-        private static CancellationTokenSource cts;
-        private static Task listenerTask;
-        private static int processingCommands = 0;
-        private static bool initScheduled = false;
-        private static bool ensureUpdateHooked = false;
-        private static bool isStarting = false;
-        private static double nextStartAt = 0.0f;
-        private static double nextHeartbeatAt = 0.0f;
-        private static int heartbeatSeq = 0;
-        private static Dictionary<
-            string,
-            (string commandJson, TaskCompletionSource<string> tcs)
-        > commandQueue = new();
-        private static int currentUnityPort = 6400; // Dynamic port, starts with default
-        private static bool isAutoConnectMode = false;
-        private const ulong MaxFrameBytes = 64UL * 1024 * 1024; // 64 MiB hard cap for framed payloads
-        private const int FrameIOTimeoutMs = 30000; // Per-read timeout to avoid stalled clients
-
-        // Debug helpers
-        private static bool IsDebugEnabled()
-        {
-            try { return EditorPrefs.GetBool("MCPForUnity.DebugLogs", false); } catch { return false; }
-        }
-
-        private static void LogBreadcrumb(string stage)
-        {
-            if (IsDebugEnabled())
-            {
-                McpLog.Info($"[{stage}]", always: false);
-            }
-        }
-
-        public static bool IsRunning => isRunning;
-        public static int GetCurrentPort() => currentUnityPort;
-        public static bool IsAutoConnectMode() => isAutoConnectMode;
-
-        /// <summary>
-        /// Start with Auto-Connect mode - discovers new port and saves it
-        /// </summary>
-        public static void StartAutoConnect()
-        {
-            Stop(); // Stop current connection
-
-            try
-            {
-                // Prefer stored project port and start using the robust Start() path (with retries/options)
-                currentUnityPort = PortManager.GetPortWithFallback();
-                Start();
-                isAutoConnectMode = true;
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError($"Auto-connect failed: {ex.Message}");
-                throw;
-            }
-        }
-
-        public static bool FolderExists(string path)
-        {
-            if (string.IsNullOrEmpty(path))
-            {
-                return false;
-            }
-
-            if (path.Equals("Assets", StringComparison.OrdinalIgnoreCase))
-            {
-                return true;
-            }
-
-            var fullPath = Path.Combine(
-                Application.dataPath,
-                path.StartsWith("Assets/") ? path[7..] : path
-            );
-            return Directory.Exists(fullPath);
-        }
-
-        static MCPForUnityBridge()
-        {
-            // Skip bridge in headless/batch environments (CI/builds) unless explicitly allowed via env
-            // CI override: set UNITY_MCP_ALLOW_BATCH=1 to allow the bridge in batch mode
-            if (Application.isBatchMode && string.IsNullOrWhiteSpace(Environment.GetEnvironmentVariable("UNITY_MCP_ALLOW_BATCH")))
-            {
-                return;
-            }
-            // Defer start until the editor is idle and not compiling
-            ScheduleInitRetry();
-            // Add a safety net update hook in case delayCall is missed during reload churn
-            if (!ensureUpdateHooked)
-            {
-                ensureUpdateHooked = true;
-                EditorApplication.update += EnsureStartedOnEditorIdle;
-            }
-            EditorApplication.quitting += Stop;
-            AssemblyReloadEvents.beforeAssemblyReload += OnBeforeAssemblyReload;
-            AssemblyReloadEvents.afterAssemblyReload += OnAfterAssemblyReload;
-            // Also coalesce play mode transitions into a deferred init
-            EditorApplication.playModeStateChanged += _ => ScheduleInitRetry();
-        }
-
-        /// <summary>
-        /// Initialize the MCP bridge after Unity is fully loaded and compilation is complete.
-        /// This prevents repeated restarts during script compilation that cause port hopping.
-        /// </summary>
-        private static void InitializeAfterCompilation()
-        {
-            initScheduled = false;
-
-            // Play-mode friendly: allow starting in play mode; only defer while compiling
-            if (IsCompiling())
-            {
-                ScheduleInitRetry();
-                return;
-            }
-
-            if (!isRunning)
-            {
-                Start();
-                if (!isRunning)
-                {
-                    // If a race prevented start, retry later
-                    ScheduleInitRetry();
-                }
-            }
-        }
-
-        private static void ScheduleInitRetry()
-        {
-            if (initScheduled)
-            {
-                return;
-            }
-            initScheduled = true;
-            // Debounce: start ~200ms after the last trigger
-            nextStartAt = EditorApplication.timeSinceStartup + 0.20f;
-            // Ensure the update pump is active
-            if (!ensureUpdateHooked)
-            {
-                ensureUpdateHooked = true;
-                EditorApplication.update += EnsureStartedOnEditorIdle;
-            }
-            // Keep the original delayCall as a secondary path
-            EditorApplication.delayCall += InitializeAfterCompilation;
-        }
-
-        // Safety net: ensure the bridge starts shortly after domain reload when editor is idle
-        private static void EnsureStartedOnEditorIdle()
-        {
-            // Do nothing while compiling
-            if (IsCompiling())
-            {
-                return;
-            }
-
-            // If already running, remove the hook
-            if (isRunning)
-            {
-                EditorApplication.update -= EnsureStartedOnEditorIdle;
-                ensureUpdateHooked = false;
-                return;
-            }
-
-            // Debounced start: wait until the scheduled time
-            if (nextStartAt > 0 && EditorApplication.timeSinceStartup < nextStartAt)
-            {
-                return;
-            }
-
-            if (isStarting)
-            {
-                return;
-            }
-
-            isStarting = true;
-            try
-            {
-                // Attempt start; if it succeeds, remove the hook to avoid overhead
-                Start();
-            }
-            finally
-            {
-                isStarting = false;
-            }
-            if (isRunning)
-            {
-                EditorApplication.update -= EnsureStartedOnEditorIdle;
-                ensureUpdateHooked = false;
-            }
-        }
-
-        // Helper to check compilation status across Unity versions
-        private static bool IsCompiling()
-        {
-            if (EditorApplication.isCompiling)
-            {
-                return true;
-            }
-            try
-            {
-                var pipeline = System.Type.GetType("UnityEditor.Compilation.CompilationPipeline, UnityEditor");
-                var prop = pipeline?.GetProperty("isCompiling", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
-                if (prop != null)
-                {
-                    return (bool)prop.GetValue(null);
-                }
-            }
-            catch { }
-            return false;
-        }
-
-        public static void Start()
-        {
-            lock (startStopLock)
-            {
-                // Don't restart if already running on a working port
-                if (isRunning && listener != null)
-                {
-                    if (IsDebugEnabled())
-                    {
-                        Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: MCPForUnityBridge already running on port {currentUnityPort}");
-                    }
-                    return;
-                }
-
-                Stop();
-
-                // Attempt fast bind with stored-port preference (sticky per-project)
-                try
-                {
-                    // Always consult PortManager first so we prefer the persisted project port
-                    currentUnityPort = PortManager.GetPortWithFallback();
-
-                    // Breadcrumb: Start
-                    LogBreadcrumb("Start");
-
-                    const int maxImmediateRetries = 3;
-                    const int retrySleepMs = 75;
-                    var attempt = 0;
-                    for (;;)
-                    {
-                        try
-                        {
-                            listener = new TcpListener(IPAddress.Loopback, currentUnityPort);
-                            listener.Server.SetSocketOption(
-                                SocketOptionLevel.Socket,
-                                SocketOptionName.ReuseAddress,
-                                true
-                            );
-#if UNITY_EDITOR_WIN
-                            try
-                            {
-                                listener.ExclusiveAddressUse = false;
-                            }
-                            catch { }
-#endif
-                            // Minimize TIME_WAIT by sending RST on close
-                            try
-                            {
-                                listener.Server.LingerState = new LingerOption(true, 0);
-                            }
-                            catch (Exception)
-                            {
-                                // Ignore if not supported on platform
-                            }
-                            listener.Start();
-                            break;
-                        }
-                        catch (SocketException se) when (se.SocketErrorCode == SocketError.AddressAlreadyInUse && attempt < maxImmediateRetries)
-                        {
-                            attempt++;
-                            Thread.Sleep(retrySleepMs);
-                            continue;
-                        }
-                        catch (SocketException se) when (se.SocketErrorCode == SocketError.AddressAlreadyInUse && attempt >= maxImmediateRetries)
-                        {
-                            currentUnityPort = PortManager.GetPortWithFallback();
-                            listener = new TcpListener(IPAddress.Loopback, currentUnityPort);
-                            listener.Server.SetSocketOption(
-                                SocketOptionLevel.Socket,
-                                SocketOptionName.ReuseAddress,
-                                true
-                            );
-#if UNITY_EDITOR_WIN
-                            try
-                            {
-                                listener.ExclusiveAddressUse = false;
-                            }
-                            catch { }
-#endif
-                            try
-                            {
-                                listener.Server.LingerState = new LingerOption(true, 0);
-                            }
-                            catch (Exception)
-                            {
-                            }
-                            listener.Start();
-                            break;
-                        }
-                    }
-
-                    isRunning = true;
-                    isAutoConnectMode = false;
-                    var platform = Application.platform.ToString();
-                    var serverVer = ReadInstalledServerVersionSafe();
-                    Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: MCPForUnityBridge started on port {currentUnityPort}. (OS={platform}, server={serverVer})");
-                    // Start background listener with cooperative cancellation
-                    cts = new CancellationTokenSource();
-                    listenerTask = Task.Run(() => ListenerLoopAsync(cts.Token));
-                    EditorApplication.update += ProcessCommands;
-                    // Ensure lifecycle events are (re)subscribed in case Stop() removed them earlier in-domain
-                    try { AssemblyReloadEvents.beforeAssemblyReload -= OnBeforeAssemblyReload; } catch { }
-                    try { AssemblyReloadEvents.beforeAssemblyReload += OnBeforeAssemblyReload; } catch { }
-                    try { AssemblyReloadEvents.afterAssemblyReload -= OnAfterAssemblyReload; } catch { }
-                    try { AssemblyReloadEvents.afterAssemblyReload += OnAfterAssemblyReload; } catch { }
-                    try { EditorApplication.quitting -= Stop; } catch { }
-                    try { EditorApplication.quitting += Stop; } catch { }
-                    // Write initial heartbeat immediately
-                    heartbeatSeq++;
-                    WriteHeartbeat(false, "ready");
-                    nextHeartbeatAt = EditorApplication.timeSinceStartup + 0.5f;
-                }
-                catch (SocketException ex)
-                {
-                    Debug.LogError($"Failed to start TCP listener: {ex.Message}");
-                }
-            }
-        }
-
-        public static void Stop()
-        {
-            Task toWait = null;
-            lock (startStopLock)
-            {
-                if (!isRunning)
-                {
-                    return;
-                }
-
-                try
-                {
-                    // Mark as stopping early to avoid accept logging during disposal
-                    isRunning = false;
-
-                    // Quiesce background listener quickly
-                    var cancel = cts;
-                    cts = null;
-                    try { cancel?.Cancel(); } catch { }
-
-                    try { listener?.Stop(); } catch { }
-                    listener = null;
-
-                    // Capture background task to wait briefly outside the lock
-                    toWait = listenerTask;
-                    listenerTask = null;
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogError($"Error stopping MCPForUnityBridge: {ex.Message}");
-                }
-            }
-
-            // Proactively close all active client sockets to unblock any pending reads
-            TcpClient[] toClose;
-            lock (clientsLock)
-            {
-                toClose = activeClients.ToArray();
-                activeClients.Clear();
-            }
-            foreach (var c in toClose)
-            {
-                try { c.Close(); } catch { }
-            }
-
-            // Give the background loop a short window to exit without blocking the editor
-            if (toWait != null)
-            {
-                try { toWait.Wait(100); } catch { }
-            }
-
-            // Now unhook editor events safely
-            try { EditorApplication.update -= ProcessCommands; } catch { }
-            try { AssemblyReloadEvents.beforeAssemblyReload -= OnBeforeAssemblyReload; } catch { }
-            try { AssemblyReloadEvents.afterAssemblyReload -= OnAfterAssemblyReload; } catch { }
-            try { EditorApplication.quitting -= Stop; } catch { }
-
-            if (IsDebugEnabled()) Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: MCPForUnityBridge stopped.");
-        }
-
-        private static async Task ListenerLoopAsync(CancellationToken token)
-        {
-            while (isRunning && !token.IsCancellationRequested)
-            {
-                try
-                {
-                    var client = await listener.AcceptTcpClientAsync();
-                    // Enable basic socket keepalive
-                    client.Client.SetSocketOption(
-                        SocketOptionLevel.Socket,
-                        SocketOptionName.KeepAlive,
-                        true
-                    );
-
-                    // Set longer receive timeout to prevent quick disconnections
-                    client.ReceiveTimeout = 60000; // 60 seconds
-
-                    // Fire and forget each client connection
-                    _ = Task.Run(() => HandleClientAsync(client, token), token);
-                }
-                catch (ObjectDisposedException)
-                {
-                    // Listener was disposed during stop/reload; exit quietly
-                    if (!isRunning || token.IsCancellationRequested)
-                    {
-                        break;
-                    }
-                }
-                catch (OperationCanceledException)
-                {
-                    break;
-                }
-                catch (Exception ex)
-                {
-                    if (isRunning && !token.IsCancellationRequested)
-                    {
-                        if (IsDebugEnabled()) Debug.LogError($"Listener error: {ex.Message}");
-                    }
-                }
-            }
-        }
-
-        private static async Task HandleClientAsync(TcpClient client, CancellationToken token)
-        {
-            using (client)
-            using (var stream = client.GetStream())
-            {
-                lock (clientsLock) { activeClients.Add(client); }
-                try
-                {
-                // Framed I/O only; legacy mode removed
-                try
-                {
-                    if (IsDebugEnabled())
-                    {
-                        var ep = client.Client?.RemoteEndPoint?.ToString() ?? "unknown";
-                        Debug.Log($"<b><color=#2EA3FF>UNITY-MCP</color></b>: Client connected {ep}");
-                    }
-                }
-                catch { }
-                // Strict framing: always require FRAMING=1 and frame all I/O
-                try
-                {
-                    client.NoDelay = true;
-                }
-                catch { }
-                try
-                {
-                    var handshake = "WELCOME UNITY-MCP 1 FRAMING=1\n";
-                    var handshakeBytes = System.Text.Encoding.ASCII.GetBytes(handshake);
-                    using var cts = new CancellationTokenSource(FrameIOTimeoutMs);
-#if NETSTANDARD2_1 || NET6_0_OR_GREATER
-                    await stream.WriteAsync(handshakeBytes.AsMemory(0, handshakeBytes.Length), cts.Token).ConfigureAwait(false);
-#else
-                    await stream.WriteAsync(handshakeBytes, 0, handshakeBytes.Length, cts.Token).ConfigureAwait(false);
-#endif
-                    if (IsDebugEnabled()) MCPForUnity.Editor.Helpers.McpLog.Info("Sent handshake FRAMING=1 (strict)", always: false);
-                }
-                catch (Exception ex)
-                {
-                    if (IsDebugEnabled()) MCPForUnity.Editor.Helpers.McpLog.Warn($"Handshake failed: {ex.Message}");
-                    return; // abort this client
-                }
-
-                while (isRunning && !token.IsCancellationRequested)
-                {
-                    try
-                    {
-                        // Strict framed mode only: enforced framed I/O for this connection
-                        var commandText = await ReadFrameAsUtf8Async(stream, FrameIOTimeoutMs, token).ConfigureAwait(false);
-
-                        try
-                        {
-                            if (IsDebugEnabled())
-                            {
-                                var preview = commandText.Length > 120 ? commandText.Substring(0, 120) + "…" : commandText;
-                                MCPForUnity.Editor.Helpers.McpLog.Info($"recv framed: {preview}", always: false);
-                            }
-                        }
-                        catch { }
-                        var commandId = Guid.NewGuid().ToString();
-                        var tcs = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
-
-                        // Special handling for ping command to avoid JSON parsing
-                        if (commandText.Trim() == "ping")
-                        {
-                            // Direct response to ping without going through JSON parsing
-                            var pingResponseBytes = System.Text.Encoding.UTF8.GetBytes(
-                                /*lang=json,strict*/
-                                "{\"status\":\"success\",\"result\":{\"message\":\"pong\"}}"
-                            );
-                            await WriteFrameAsync(stream, pingResponseBytes);
-                            continue;
-                        }
-
-                        lock (lockObj)
-                        {
-                            commandQueue[commandId] = (commandText, tcs);
-                        }
-
-                        var response = await tcs.Task.ConfigureAwait(false);
-                        var responseBytes = System.Text.Encoding.UTF8.GetBytes(response);
-                        await WriteFrameAsync(stream, responseBytes);
-                    }
-                    catch (Exception ex)
-                    {
-                        // Treat common disconnects/timeouts as benign; only surface hard errors
-                        var msg = ex.Message ?? string.Empty;
-                        var isBenign =
-                            msg.IndexOf("Connection closed before reading expected bytes", StringComparison.OrdinalIgnoreCase) >= 0
-                            || msg.IndexOf("Read timed out", StringComparison.OrdinalIgnoreCase) >= 0
-                            || ex is System.IO.IOException;
-                        if (isBenign)
-                        {
-                            if (IsDebugEnabled()) MCPForUnity.Editor.Helpers.McpLog.Info($"Client handler: {msg}", always: false);
-                        }
-                        else
-                        {
-                            MCPForUnity.Editor.Helpers.McpLog.Error($"Client handler error: {msg}");
-                        }
-                        break;
-                    }
-                }
-                }
-                finally
-                {
-                    lock (clientsLock) { activeClients.Remove(client); }
-                }
-            }
-        }
-
-        // Timeout-aware exact read helper with cancellation; avoids indefinite stalls and background task leaks
-        private static async System.Threading.Tasks.Task<byte[]> ReadExactAsync(NetworkStream stream, int count, int timeoutMs, CancellationToken cancel = default)
-        {
-            var buffer = new byte[count];
-            var offset = 0;
-            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
-
-            while (offset < count)
-            {
-                var remaining = count - offset;
-                var remainingTimeout = timeoutMs <= 0
-                    ? Timeout.Infinite
-                    : timeoutMs - (int)stopwatch.ElapsedMilliseconds;
-
-                // If a finite timeout is configured and already elapsed, fail immediately
-                if (remainingTimeout != Timeout.Infinite && remainingTimeout <= 0)
-                {
-                    throw new System.IO.IOException("Read timed out");
-                }
-
-                using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancel);
-                if (remainingTimeout != Timeout.Infinite)
-                {
-                    cts.CancelAfter(remainingTimeout);
-                }
-
-                try
-                {
-#if NETSTANDARD2_1 || NET6_0_OR_GREATER
-                    int read = await stream.ReadAsync(buffer.AsMemory(offset, remaining), cts.Token).ConfigureAwait(false);
-#else
-                    var read = await stream.ReadAsync(buffer, offset, remaining, cts.Token).ConfigureAwait(false);
-#endif
-                    if (read == 0)
-                    {
-                        throw new System.IO.IOException("Connection closed before reading expected bytes");
-                    }
-                    offset += read;
-                }
-                catch (OperationCanceledException) when (!cancel.IsCancellationRequested)
-                {
-                    throw new System.IO.IOException("Read timed out");
-                }
-            }
-
-            return buffer;
-        }
-
-        private static async System.Threading.Tasks.Task WriteFrameAsync(NetworkStream stream, byte[] payload)
-        {
-            using var cts = new CancellationTokenSource(FrameIOTimeoutMs);
-            await WriteFrameAsync(stream, payload, cts.Token);
-        }
-
-        private static async System.Threading.Tasks.Task WriteFrameAsync(NetworkStream stream, byte[] payload, CancellationToken cancel)
-        {
-            if (payload == null)
-            {
-                throw new System.ArgumentNullException(nameof(payload));
-            }
-            if ((ulong)payload.LongLength > MaxFrameBytes)
-            {
-                throw new System.IO.IOException($"Frame too large: {payload.LongLength}");
-            }
-            var header = new byte[8];
-            WriteUInt64BigEndian(header, (ulong)payload.LongLength);
-#if NETSTANDARD2_1 || NET6_0_OR_GREATER
-            await stream.WriteAsync(header.AsMemory(0, header.Length), cancel).ConfigureAwait(false);
-            await stream.WriteAsync(payload.AsMemory(0, payload.Length), cancel).ConfigureAwait(false);
-#else
-            await stream.WriteAsync(header, 0, header.Length, cancel).ConfigureAwait(false);
-            await stream.WriteAsync(payload, 0, payload.Length, cancel).ConfigureAwait(false);
-#endif
-        }
-
-        private static async System.Threading.Tasks.Task<string> ReadFrameAsUtf8Async(NetworkStream stream, int timeoutMs, CancellationToken cancel)
-        {
-            var header = await ReadExactAsync(stream, 8, timeoutMs, cancel).ConfigureAwait(false);
-            var payloadLen = ReadUInt64BigEndian(header);
-             if (payloadLen > MaxFrameBytes)
-            {
-                throw new System.IO.IOException($"Invalid framed length: {payloadLen}");
-            }
-            if (payloadLen == 0UL)
-                throw new System.IO.IOException("Zero-length frames are not allowed");
-            if (payloadLen > int.MaxValue)
-            {
-                throw new System.IO.IOException("Frame too large for buffer");
-            }
-            var count = (int)payloadLen;
-            var payload = await ReadExactAsync(stream, count, timeoutMs, cancel).ConfigureAwait(false);
-            return System.Text.Encoding.UTF8.GetString(payload);
-        }
-
-        private static ulong ReadUInt64BigEndian(byte[] buffer)
-        {
-            if (buffer == null || buffer.Length < 8) return 0UL;
-            return ((ulong)buffer[0] << 56)
-                 | ((ulong)buffer[1] << 48)
-                 | ((ulong)buffer[2] << 40)
-                 | ((ulong)buffer[3] << 32)
-                 | ((ulong)buffer[4] << 24)
-                 | ((ulong)buffer[5] << 16)
-                 | ((ulong)buffer[6] << 8)
-                 | buffer[7];
-        }
-
-        private static void WriteUInt64BigEndian(byte[] dest, ulong value)
-        {
-            if (dest == null || dest.Length < 8)
-            {
-                throw new System.ArgumentException("Destination buffer too small for UInt64");
-            }
-            dest[0] = (byte)(value >> 56);
-            dest[1] = (byte)(value >> 48);
-            dest[2] = (byte)(value >> 40);
-            dest[3] = (byte)(value >> 32);
-            dest[4] = (byte)(value >> 24);
-            dest[5] = (byte)(value >> 16);
-            dest[6] = (byte)(value >> 8);
-            dest[7] = (byte)(value);
-        }
-
-        private static void ProcessCommands()
-        {
-            if (!isRunning) return;
-            if (Interlocked.Exchange(ref processingCommands, 1) == 1) return; // reentrancy guard
-            try
-            {
-            // Heartbeat without holding the queue lock
-            var now = EditorApplication.timeSinceStartup;
-            if (now >= nextHeartbeatAt)
-            {
-                WriteHeartbeat(false);
-                nextHeartbeatAt = now + 0.5f;
-            }
-
-            // Snapshot under lock, then process outside to reduce contention
-            List<(string id, string text, TaskCompletionSource<string> tcs)> work;
-            lock (lockObj)
-            {
-                work = commandQueue
-                    .Select(kvp => (kvp.Key, kvp.Value.commandJson, kvp.Value.tcs))
-                    .ToList();
-            }
-
-            foreach (var item in work)
-            {
-                var id = item.id;
-                var commandText = item.text;
-                var tcs = item.tcs;
-
-                try
-                {
-                    // Special case handling
-                    if (string.IsNullOrEmpty(commandText))
-                    {
-                        var emptyResponse = new
-                        {
-                            status = "error",
-                            error = "Empty command received",
-                        };
-                        tcs.SetResult(JsonConvert.SerializeObject(emptyResponse));
-                        // Remove quickly under lock
-                        lock (lockObj) { commandQueue.Remove(id); }
-                        continue;
-                    }
-
-                    // Trim the command text to remove any whitespace
-                    commandText = commandText.Trim();
-
-                    // Non-JSON direct commands handling (like ping)
-                    if (commandText == "ping")
-                    {
-                        var pingResponse = new
-                        {
-                            status = "success",
-                            result = new { message = "pong" },
-                        };
-                        tcs.SetResult(JsonConvert.SerializeObject(pingResponse));
-                        lock (lockObj) { commandQueue.Remove(id); }
-                        continue;
-                    }
-
-                    // Check if the command is valid JSON before attempting to deserialize
-                    if (!IsValidJson(commandText))
-                    {
-                        var invalidJsonResponse = new
-                        {
-                            status = "error",
-                            error = "Invalid JSON format",
-                            receivedText = commandText.Length > 50
-                                ? commandText[..50] + "..."
-                                : commandText,
-                        };
-                        tcs.SetResult(JsonConvert.SerializeObject(invalidJsonResponse));
-                        lock (lockObj) { commandQueue.Remove(id); }
-                        continue;
-                    }
-
-                    // Normal JSON command processing
-                    var command = JsonConvert.DeserializeObject<Command>(commandText);
-
-                    if (command == null)
-                    {
-                        var nullCommandResponse = new
-                        {
-                            status = "error",
-                            error = "Command deserialized to null",
-                            details = "The command was valid JSON but could not be deserialized to a Command object",
-                        };
-                        tcs.SetResult(JsonConvert.SerializeObject(nullCommandResponse));
-                    }
-                    else
-                    {
-                        var responseJson = ExecuteCommand(command);
-                        tcs.SetResult(responseJson);
-                    }
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogError($"Error processing command: {ex.Message}\n{ex.StackTrace}");
-
-                    var response = new
-                    {
-                        status = "error",
-                        error = ex.Message,
-                        commandType = "Unknown (error during processing)",
-                        receivedText = commandText?.Length > 50
-                            ? commandText[..50] + "..."
-                            : commandText,
-                    };
-                    var responseJson = JsonConvert.SerializeObject(response);
-                    tcs.SetResult(responseJson);
-                }
-
-                // Remove quickly under lock
-                lock (lockObj) { commandQueue.Remove(id); }
-            }
-            }
-            finally
-            {
-                Interlocked.Exchange(ref processingCommands, 0);
-            }
-        }
-
-        // Helper method to check if a string is valid JSON
-        private static bool IsValidJson(string text)
-        {
-            if (string.IsNullOrWhiteSpace(text))
-            {
-                return false;
-            }
-
-            text = text.Trim();
-            if (
-                (text.StartsWith("{") && text.EndsWith("}"))
-                || // Object
-                (text.StartsWith("[") && text.EndsWith("]"))
-            ) // Array
-            {
-                try
-                {
-                    JToken.Parse(text);
-                    return true;
-                }
-                catch
-                {
-                    return false;
-                }
-            }
-
-            return false;
-        }
-
-        private static string ExecuteCommand(Command command)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(command.type))
-                {
-                    var errorResponse = new
-                    {
-                        status = "error",
-                        error = "Command type cannot be empty",
-                        details = "A valid command type is required for processing",
-                    };
-                    return JsonConvert.SerializeObject(errorResponse);
-                }
-
-                // Handle ping command for connection verification
-                if (command.type.Equals("ping", StringComparison.OrdinalIgnoreCase))
-                {
-                    var pingResponse = new
-                    {
-                        status = "success",
-                        result = new { message = "pong" },
-                    };
-                    return JsonConvert.SerializeObject(pingResponse);
-                }
-
-                // Use JObject for parameters as the new handlers likely expect this
-                var paramsObject = command.@params ?? new JObject();
-
-                // Route command based on the new tool structure from the refactor plan
-                var result = command.type switch
-                {
-                    // Maps the command type (tool name) to the corresponding handler's static HandleCommand method
-                    // Assumes each handler class has a static method named 'HandleCommand' that takes JObject parameters
-                    "manage_script" => ManageScript.HandleCommand(paramsObject),
-                    "manage_scene" => ManageScene.HandleCommand(paramsObject),
-                    "manage_editor" => ManageEditor.HandleCommand(paramsObject),
-                    "manage_gameobject" => ManageGameObject.HandleCommand(paramsObject),
-                    "manage_asset" => ManageAsset.HandleCommand(paramsObject),
-                    "manage_shader" => ManageShader.HandleCommand(paramsObject),
-                    "manage_queue" => ManageQueue.HandleCommand(paramsObject), // STUDIO: Operation queuing system
-                    "read_console" => ReadConsole.HandleCommand(paramsObject),
-                    "execute_menu_item" => ExecuteMenuItem.HandleCommand(paramsObject),
-                    _ => throw new ArgumentException(
-                        $"Unknown or unsupported command type: {command.type}"
-                    ),
-                };
-
-                // Standard success response format
-                var response = new { status = "success", result };
-                return JsonConvert.SerializeObject(response);
-            }
-            catch (Exception ex)
-            {
-                // Log the detailed error in Unity for debugging
-                Debug.LogError(
-                    $"Error executing command '{command?.type ?? "Unknown"}': {ex.Message}\n{ex.StackTrace}"
-                );
-
-                // Standard error response format
-                var response = new
-                {
-                    status = "error",
-                    error = ex.Message, // Provide the specific error message
-                    command = command?.type ?? "Unknown", // Include the command type if available
-                    stackTrace = ex.StackTrace, // Include stack trace for detailed debugging
-                    paramsSummary = command?.@params != null
-                        ? GetParamsSummary(command.@params)
-                        : "No parameters", // Summarize parameters for context
-                };
-                return JsonConvert.SerializeObject(response);
-            }
-        }
-
-        // Helper method to get a summary of parameters for error reporting
-        private static string GetParamsSummary(JObject @params)
-        {
-            try
-            {
-                return @params == null || !@params.HasValues
-                    ? "No parameters"
-                    : string.Join(
-                        ", ",
-                        @params
-                            .Properties()
-                            .Select(static p =>
-                                $"{p.Name}: {p.Value?.ToString()?[..Math.Min(20, p.Value?.ToString()?.Length ?? 0)]}"
-                            )
-                    );
-            }
-            catch
-            {
-                return "Could not summarize parameters";
-            }
-        }
-
-        // Heartbeat/status helpers
-        private static void OnBeforeAssemblyReload()
-        {
-            // Stop cleanly before reload so sockets close and clients see 'reloading'
-            try { Stop(); } catch { }
-            // Avoid file I/O or heavy work here
-        }
-
-        private static void OnAfterAssemblyReload()
-        {
-            // Will be overwritten by Start(), but mark as alive quickly
-            WriteHeartbeat(false, "idle");
-            LogBreadcrumb("Idle");
-            // Schedule a safe restart after reload to avoid races during compilation
-            ScheduleInitRetry();
-        }
-
-        private static void WriteHeartbeat(bool reloading, string reason = null)
-        {
-            try
-            {
-                // Allow override of status directory (useful in CI/containers)
-                var dir = Environment.GetEnvironmentVariable("UNITY_MCP_STATUS_DIR");
-                if (string.IsNullOrWhiteSpace(dir))
-                {
-                    dir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".unity-mcp");
-                }
-                Directory.CreateDirectory(dir);
-                var filePath = Path.Combine(dir, $"unity-mcp-status-{ComputeProjectHash(Application.dataPath)}.json");
-                var payload = new
-                {
-                    unity_port = currentUnityPort,
-                    reloading,
-                    reason = reason ?? (reloading ? "reloading" : "ready"),
-                    seq = heartbeatSeq,
-                    project_path = Application.dataPath,
-                    last_heartbeat = DateTime.UtcNow.ToString("O")
-                };
-                File.WriteAllText(filePath, JsonConvert.SerializeObject(payload), new System.Text.UTF8Encoding(false));
-            }
-            catch (Exception)
-            {
-                // Best-effort only
-            }
-        }
-
-        private static string ReadInstalledServerVersionSafe()
-        {
-            try
-            {
-                var serverSrc = ServerInstaller.GetServerPath();
-                var verFile = Path.Combine(serverSrc, "server_version.txt");
-                if (File.Exists(verFile))
-                {
-                    var v = File.ReadAllText(verFile)?.Trim();
-                    if (!string.IsNullOrEmpty(v)) return v;
-                }
-            }
-            catch { }
-            return "unknown";
-        }
-
-        private static string ComputeProjectHash(string input)
-        {
-            try
-            {
-                using var sha1 = System.Security.Cryptography.SHA1.Create();
-                var bytes = System.Text.Encoding.UTF8.GetBytes(input ?? string.Empty);
-                var hashBytes = sha1.ComputeHash(bytes);
-                var sb = new System.Text.StringBuilder();
-                foreach (var b in hashBytes)
-                {
-                    sb.Append(b.ToString("x2"));
-                }
-                return sb.ToString()[..8];
-            }
-            catch
-            {
-                return "default";
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 5862c6a6d0a914f4d83224f8d039cf7b
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/UnityMcpServer~/src/pyrightconfig.json
===================================================================
diff --git a/Packages/UnityMcpBridge/UnityMcpServer~/src/pyrightconfig.json b/Packages/UnityMcpBridge/UnityMcpServer~/src/pyrightconfig.json
deleted file mode 100644
--- a/Packages/UnityMcpBridge/UnityMcpServer~/src/pyrightconfig.json	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-{
-  "typeCheckingMode": "basic",
-  "reportMissingImports": "none",
-  "pythonVersion": "3.11",
-  "executionEnvironments": [
-    {
-      "root": ".",
-      "pythonVersion": "3.11"
-    }
-  ]
-}
Index: Packages/UnityMcpBridge/Editor/Data/McpClients.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Data/McpClients.cs.meta b/Packages/UnityMcpBridge/Editor/Data/McpClients.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Data/McpClients.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 711b86bbc1f661e4fb2c822e14970e16
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/Command.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/Command.cs b/Packages/UnityMcpBridge/Editor/Models/Command.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/Command.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,21 +0,0 @@
-using Newtonsoft.Json.Linq;
-
-namespace MCPForUnity.Editor.Models
-{
-    /// <summary>
-    /// Represents a command received from the MCP client
-    /// </summary>
-    public class Command
-    {
-        /// <summary>
-        /// The type of command to execute
-        /// </summary>
-        public string type { get; set; }
-
-        /// <summary>
-        /// The parameters for the command
-        /// </summary>
-        public JObject @params { get; set; }
-    }
-}
-
Index: Packages/UnityMcpBridge/Runtime.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime.meta b/Packages/UnityMcpBridge/Runtime.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: b5cc10fd969474b3680332e542416860
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/McpTypes.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs.meta b/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpTypes.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 9ca97c5ff5ed74c4fbb65cfa9d2bfed1
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: 017cb36cf6bcbfdeaab50ab444fc9dc8
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/Vector3Helper.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: f8514fd42f23cb641a36e52550825b35
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef.meta b/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,7 +0,0 @@
-fileFormatVersion: 2
-guid: 562a750ff18ee4193928e885c708fee1
-AssemblyDefinitionImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ExecPath.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 8f2b7b3e9c3e4a0f9b2a1d4c7e6f5a12
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs b/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,43 +0,0 @@
-using UnityEditor;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Handles automatic installation of the Python server when the package is first installed.
-    /// </summary>
-    [InitializeOnLoad]
-    public static class PackageInstaller
-    {
-        private const string InstallationFlagKey = "MCPForUnity.ServerInstalled";
-
-        static PackageInstaller()
-        {
-            // Check if this is the first time the package is loaded
-            if (!EditorPrefs.GetBool(InstallationFlagKey, false))
-            {
-                // Schedule the installation for after Unity is fully loaded
-                EditorApplication.delayCall += InstallServerOnFirstLoad;
-            }
-        }
-
-        private static void InstallServerOnFirstLoad()
-        {
-            try
-            {
-                Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Installing Python server...");
-                ServerInstaller.EnsureServerInstalled();
-
-                // Mark as installed
-                EditorPrefs.SetBool(InstallationFlagKey, true);
-
-                Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Python server installation completed successfully.");
-            }
-            catch (System.Exception ex)
-            {
-                Debug.LogError($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Failed to install Python server: {ex.Message}");
-                Debug.LogWarning("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: You may need to manually install the Python server. Check the MCP for Unity Editor Window for instructions.");
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs b/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,267 +0,0 @@
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using System;
-using UnityEngine;
-#if UNITY_EDITOR
-
-// Required for AssetDatabase and EditorUtility
-#endif
-
-namespace MCPForUnity.Runtime.Serialization
-{
-    public class Vector3Converter : JsonConverter<Vector3>
-    {
-        public override void WriteJson(JsonWriter writer, Vector3 value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("x");
-            writer.WriteValue(value.x);
-            writer.WritePropertyName("y");
-            writer.WriteValue(value.y);
-            writer.WritePropertyName("z");
-            writer.WriteValue(value.z);
-            writer.WriteEndObject();
-        }
-
-        public override Vector3 ReadJson(JsonReader reader, Type objectType, Vector3 existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            return new Vector3(
-                (float)jo["x"],
-                (float)jo["y"],
-                (float)jo["z"]
-            );
-        }
-    }
-
-    public class Vector2Converter : JsonConverter<Vector2>
-    {
-        public override void WriteJson(JsonWriter writer, Vector2 value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("x");
-            writer.WriteValue(value.x);
-            writer.WritePropertyName("y");
-            writer.WriteValue(value.y);
-            writer.WriteEndObject();
-        }
-
-        public override Vector2 ReadJson(JsonReader reader, Type objectType, Vector2 existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            return new Vector2(
-                (float)jo["x"],
-                (float)jo["y"]
-            );
-        }
-    }
-
-    public class QuaternionConverter : JsonConverter<Quaternion>
-    {
-        public override void WriteJson(JsonWriter writer, Quaternion value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("x");
-            writer.WriteValue(value.x);
-            writer.WritePropertyName("y");
-            writer.WriteValue(value.y);
-            writer.WritePropertyName("z");
-            writer.WriteValue(value.z);
-            writer.WritePropertyName("w");
-            writer.WriteValue(value.w);
-            writer.WriteEndObject();
-        }
-
-        public override Quaternion ReadJson(JsonReader reader, Type objectType, Quaternion existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            return new Quaternion(
-                (float)jo["x"],
-                (float)jo["y"],
-                (float)jo["z"],
-                (float)jo["w"]
-            );
-        }
-    }
-
-    public class ColorConverter : JsonConverter<Color>
-    {
-        public override void WriteJson(JsonWriter writer, Color value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("r");
-            writer.WriteValue(value.r);
-            writer.WritePropertyName("g");
-            writer.WriteValue(value.g);
-            writer.WritePropertyName("b");
-            writer.WriteValue(value.b);
-            writer.WritePropertyName("a");
-            writer.WriteValue(value.a);
-            writer.WriteEndObject();
-        }
-
-        public override Color ReadJson(JsonReader reader, Type objectType, Color existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            return new Color(
-                (float)jo["r"],
-                (float)jo["g"],
-                (float)jo["b"],
-                (float)jo["a"]
-            );
-        }
-    }
-
-    public class RectConverter : JsonConverter<Rect>
-    {
-        public override void WriteJson(JsonWriter writer, Rect value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("x");
-            writer.WriteValue(value.x);
-            writer.WritePropertyName("y");
-            writer.WriteValue(value.y);
-            writer.WritePropertyName("width");
-            writer.WriteValue(value.width);
-            writer.WritePropertyName("height");
-            writer.WriteValue(value.height);
-            writer.WriteEndObject();
-        }
-
-        public override Rect ReadJson(JsonReader reader, Type objectType, Rect existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            return new Rect(
-                (float)jo["x"],
-                (float)jo["y"],
-                (float)jo["width"],
-                (float)jo["height"]
-            );
-        }
-    }
-
-    public class BoundsConverter : JsonConverter<Bounds>
-    {
-        public override void WriteJson(JsonWriter writer, Bounds value, JsonSerializer serializer)
-        {
-            writer.WriteStartObject();
-            writer.WritePropertyName("center");
-            serializer.Serialize(writer, value.center); // Use serializer to handle nested Vector3
-            writer.WritePropertyName("size");
-            serializer.Serialize(writer, value.size);   // Use serializer to handle nested Vector3
-            writer.WriteEndObject();
-        }
-
-        public override Bounds ReadJson(JsonReader reader, Type objectType, Bounds existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            var jo = JObject.Load(reader);
-            var center = jo["center"].ToObject<Vector3>(serializer); // Use serializer to handle nested Vector3
-            var size = jo["size"].ToObject<Vector3>(serializer);     // Use serializer to handle nested Vector3
-            return new Bounds(center, size);
-        }
-    }
-
-    // Converter for UnityEngine.Object references (GameObjects, Components, Materials, Textures, etc.)
-    public class UnityEngineObjectConverter : JsonConverter<UnityEngine.Object>
-    {
-        public override bool CanRead => true; // We need to implement ReadJson
-        public override bool CanWrite => true;
-
-        public override void WriteJson(JsonWriter writer, UnityEngine.Object value, JsonSerializer serializer)
-        {
-            if (value == null)
-            {
-                writer.WriteNull();
-                return;
-            }
-
-#if UNITY_EDITOR // AssetDatabase and EditorUtility are Editor-only
-            if (UnityEditor.AssetDatabase.Contains(value))
-            {
-                // It's an asset (Material, Texture, Prefab, etc.)
-                var path = UnityEditor.AssetDatabase.GetAssetPath(value);
-                if (!string.IsNullOrEmpty(path))
-                {
-                    writer.WriteValue(path);
-                }
-                else
-                {
-                    // Asset exists but path couldn't be found? Write minimal info.
-                    writer.WriteStartObject();
-                    writer.WritePropertyName("name");
-                    writer.WriteValue(value.name);
-                    writer.WritePropertyName("instanceID");
-                    writer.WriteValue(value.GetInstanceID());
-                    writer.WritePropertyName("isAssetWithoutPath");
-                    writer.WriteValue(true);
-                    writer.WriteEndObject();
-                }
-            }
-            else
-            {
-                // It's a scene object (GameObject, Component, etc.)
-                writer.WriteStartObject();
-                writer.WritePropertyName("name");
-                writer.WriteValue(value.name);
-                writer.WritePropertyName("instanceID");
-                writer.WriteValue(value.GetInstanceID());
-                writer.WriteEndObject();
-            }
-#else
-            // Runtime fallback: Write basic info without AssetDatabase
-            writer.WriteStartObject();
-            writer.WritePropertyName("name");
-            writer.WriteValue(value.name);
-            writer.WritePropertyName("instanceID");
-            writer.WriteValue(value.GetInstanceID());
-             writer.WritePropertyName("warning");
-            writer.WriteValue("UnityEngineObjectConverter running in non-Editor mode, asset path unavailable.");
-            writer.WriteEndObject();
-#endif
-        }
-
-        public override UnityEngine.Object ReadJson(JsonReader reader, Type objectType, UnityEngine.Object existingValue, bool hasExistingValue, JsonSerializer serializer)
-        {
-            if (reader.TokenType == JsonToken.Null)
-            {
-                return null;
-            }
-
-#if UNITY_EDITOR
-            if (reader.TokenType == JsonToken.String)
-            {
-                // Assume it's an asset path
-                var path = reader.Value.ToString();
-                return UnityEditor.AssetDatabase.LoadAssetAtPath(path, objectType);
-            }
-
-            if (reader.TokenType == JsonToken.StartObject)
-            {
-                var jo = JObject.Load(reader);
-                if (jo.TryGetValue("instanceID", out var idToken) && idToken.Type == JTokenType.Integer)
-                {
-                    var instanceId = idToken.ToObject<int>();
-                    var obj = UnityEditor.EditorUtility.InstanceIDToObject(instanceId);
-                    if (obj != null && objectType.IsAssignableFrom(obj.GetType()))
-                    {
-                        return obj;
-                    }
-                }
-                // Could potentially try finding by name as a fallback if ID lookup fails/isn't present
-                // but that's less reliable.
-            }
-#else
-             // Runtime deserialization is tricky without AssetDatabase/EditorUtility
-             // Maybe log a warning and return null or existingValue?
-             Debug.LogWarning("UnityEngineObjectConverter cannot deserialize complex objects in non-Editor mode.");
-             // Skip the token to avoid breaking the reader
-             if (reader.TokenType == JsonToken.StartObject) JObject.Load(reader);
-             else if (reader.TokenType == JsonToken.String) reader.ReadAsString();
-             // Return null or existing value, depending on desired behavior
-             return existingValue;
-#endif
-
-            throw new JsonSerializationException($"Unexpected token type '{reader.TokenType}' when deserializing UnityEngine.Object");
-        }
-    }
-} 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs.meta b/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServers.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: bcb583553e8173b49be71a5c43bd9502
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/McpClient.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpClient.cs b/Packages/UnityMcpBridge/Editor/Models/McpClient.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpClient.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,47 +0,0 @@
-namespace MCPForUnity.Editor.Models
-{
-    public class McpClient
-    {
-        public string name;
-        public string windowsConfigPath;
-        public string macConfigPath;
-        public string linuxConfigPath;
-        public McpTypes mcpType;
-        public string configStatus;
-        public McpStatus status = McpStatus.NotConfigured;
-
-        // Helper method to convert the enum to a display string
-        public string GetStatusDisplayString()
-        {
-            return status switch
-            {
-                McpStatus.NotConfigured => "Not Configured",
-                McpStatus.Configured => "Configured",
-                McpStatus.Running => "Running",
-                McpStatus.Connected => "Connected",
-                McpStatus.IncorrectPath => "Incorrect Path",
-                McpStatus.CommunicationError => "Communication Error",
-                McpStatus.NoResponse => "No Response",
-                McpStatus.UnsupportedOS => "Unsupported OS",
-                McpStatus.MissingConfig => "Missing MCPForUnity Config",
-                McpStatus.Error => configStatus.StartsWith("Error:") ? configStatus : "Error",
-                _ => "Unknown",
-            };
-        }
-
-        // Helper method to set both status enum and string for backward compatibility
-        public void SetStatus(McpStatus newStatus, string errorDetails = null)
-        {
-            status = newStatus;
-
-            if (newStatus == McpStatus.Error && !string.IsNullOrEmpty(errorDetails))
-            {
-                configStatus = $"Error: {errorDetails}";
-            }
-            else
-            {
-                configStatus = GetStatusDisplayString();
-            }
-        }
-    }
-}
Index: Packages/UnityMcpBridge/Editor/AssemblyInfo.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs.meta b/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: be61633e00d934610ac1ff8192ffbe3d
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs b/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,33 +0,0 @@
-using UnityEditor;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    internal static class McpLog
-    {
-        private const string Prefix = "<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>:";
-
-        private static bool IsDebugEnabled()
-        {
-            try { return EditorPrefs.GetBool("MCPForUnity.DebugLogs", false); } catch { return false; }
-        }
-
-        public static void Info(string message, bool always = true)
-        {
-            if (!always && !IsDebugEnabled()) return;
-            Debug.Log($"{Prefix} {message}");
-        }
-
-        public static void Warn(string message)
-        {
-            Debug.LogWarning($"<color=#cc7a00>{Prefix} {message}</color>");
-        }
-
-        public static void Error(string message)
-        {
-            Debug.LogError($"<color=#cc3333>{Prefix} {message}</color>");
-        }
-    }
-}
-
-
Index: Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageShader.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,341 +0,0 @@
-using System;
-using System.IO;
-using System.Text.RegularExpressions;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers;
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles CRUD operations for shader files within the Unity project.
-    /// </summary>
-    public static class ManageShader
-    {
-        /// <summary>
-        /// Main handler for shader management actions.
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            // Extract parameters
-            var action = @params["action"]?.ToString().ToLower();
-            var name = @params["name"]?.ToString();
-            var path = @params["path"]?.ToString(); // Relative to Assets/
-            string contents = null;
-
-            // Check if we have base64 encoded contents
-            var contentsEncoded = @params["contentsEncoded"]?.ToObject<bool>() ?? false;
-            if (contentsEncoded && @params["encodedContents"] != null)
-            {
-                try
-                {
-                    contents = DecodeBase64(@params["encodedContents"].ToString());
-                }
-                catch (Exception e)
-                {
-                    return Response.Error($"Failed to decode shader contents: {e.Message}");
-                }
-            }
-            else
-            {
-                contents = @params["contents"]?.ToString();
-            }
-
-            // Validate required parameters
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-            if (string.IsNullOrEmpty(name))
-            {
-                return Response.Error("Name parameter is required.");
-            }
-            // Basic name validation (alphanumeric, underscores, cannot start with number)
-            if (!Regex.IsMatch(name, @"^[a-zA-Z_][a-zA-Z0-9_]*$"))
-            {
-                return Response.Error(
-                    $"Invalid shader name: '{name}'. Use only letters, numbers, underscores, and don't start with a number."
-                );
-            }
-
-            // Ensure path is relative to Assets/, removing any leading "Assets/"
-            // Set default directory to "Shaders" if path is not provided
-            var relativeDir = path ?? "Shaders"; // Default to "Shaders" if path is null
-            if (!string.IsNullOrEmpty(relativeDir))
-            {
-                relativeDir = relativeDir.Replace('\\', '/').Trim('/');
-                if (relativeDir.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase))
-                {
-                    relativeDir = relativeDir.Substring("Assets/".Length).TrimStart('/');
-                }
-            }
-            // Handle empty string case explicitly after processing
-            if (string.IsNullOrEmpty(relativeDir))
-            {
-                relativeDir = "Shaders"; // Ensure default if path was provided as "" or only "/" or "Assets/"
-            }
-
-            // Construct paths
-            var shaderFileName = $"{name}.shader";
-            var fullPathDir = Path.Combine(Application.dataPath, relativeDir);
-            var fullPath = Path.Combine(fullPathDir, shaderFileName);
-            var relativePath = Path.Combine("Assets", relativeDir, shaderFileName)
-                .Replace('\\', '/'); // Ensure "Assets/" prefix and forward slashes
-
-            // Ensure the target directory exists for create/update
-            if (action == "create" || action == "update")
-            {
-                try
-                {
-                    if (!Directory.Exists(fullPathDir))
-                    {
-                        Directory.CreateDirectory(fullPathDir);
-                        // Refresh AssetDatabase to recognize new folders
-                        AssetDatabase.Refresh();
-                    }
-                }
-                catch (Exception e)
-                {
-                    return Response.Error(
-                        $"Could not create directory '{fullPathDir}': {e.Message}"
-                    );
-                }
-            }
-
-            // Route to specific action handlers
-            switch (action)
-            {
-                case "create":
-                    return CreateShader(fullPath, relativePath, name, contents);
-                case "read":
-                    return ReadShader(fullPath, relativePath);
-                case "update":
-                    return UpdateShader(fullPath, relativePath, name, contents);
-                case "delete":
-                    return DeleteShader(fullPath, relativePath);
-                default:
-                    return Response.Error(
-                        $"Unknown action: '{action}'. Valid actions are: create, read, update, delete."
-                    );
-            }
-        }
-
-        /// <summary>
-        /// Decode base64 string to normal text
-        /// </summary>
-        private static string DecodeBase64(string encoded)
-        {
-            var data = Convert.FromBase64String(encoded);
-            return System.Text.Encoding.UTF8.GetString(data);
-        }
-
-        /// <summary>
-        /// Encode text to base64 string
-        /// </summary>
-        private static string EncodeBase64(string text)
-        {
-            var data = System.Text.Encoding.UTF8.GetBytes(text);
-            return Convert.ToBase64String(data);
-        }
-
-        private static object CreateShader(
-            string fullPath,
-            string relativePath,
-            string name,
-            string contents
-        )
-        {
-            // Check if shader already exists
-            if (File.Exists(fullPath))
-            {
-                return Response.Error(
-                    $"Shader already exists at '{relativePath}'. Use 'update' action to modify."
-                );
-            }
-
-            // Add validation for shader name conflicts in Unity
-            if (Shader.Find(name) != null)
-            {
-                return Response.Error(
-                    $"A shader with name '{name}' already exists in the project. Choose a different name."
-                );
-            }
-
-            // Generate default content if none provided
-            if (string.IsNullOrEmpty(contents))
-            {
-                contents = GenerateDefaultShaderContent(name);
-            }
-
-            try
-            {
-                File.WriteAllText(fullPath, contents, new System.Text.UTF8Encoding(false));
-                AssetDatabase.ImportAsset(relativePath);
-                AssetDatabase.Refresh(); // Ensure Unity recognizes the new shader
-                return Response.Success(
-                    $"Shader '{name}.shader' created successfully at '{relativePath}'.",
-                    new { path = relativePath }
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to create shader '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object ReadShader(string fullPath, string relativePath)
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.Error($"Shader not found at '{relativePath}'.");
-            }
-
-            try
-            {
-                var contents = File.ReadAllText(fullPath);
-
-                // Return both normal and encoded contents for larger files
-                //TODO: Consider a threshold for large files
-                var isLarge = contents.Length > 10000; // If content is large, include encoded version
-                var responseData = new
-                {
-                    path = relativePath,
-                    contents,
-                    // For large files, also include base64-encoded version
-                    encodedContents = isLarge ? EncodeBase64(contents) : null,
-                    contentsEncoded = isLarge,
-                };
-
-                return Response.Success(
-                    $"Shader '{Path.GetFileName(relativePath)}' read successfully.",
-                    responseData
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to read shader '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object UpdateShader(
-            string fullPath,
-            string relativePath,
-            string name,
-            string contents
-        )
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.Error(
-                    $"Shader not found at '{relativePath}'. Use 'create' action to add a new shader."
-                );
-            }
-            if (string.IsNullOrEmpty(contents))
-            {
-                return Response.Error("Content is required for the 'update' action.");
-            }
-
-            try
-            {
-                File.WriteAllText(fullPath, contents, new System.Text.UTF8Encoding(false));
-                AssetDatabase.ImportAsset(relativePath);
-                AssetDatabase.Refresh();
-                return Response.Success(
-                    $"Shader '{Path.GetFileName(relativePath)}' updated successfully.",
-                    new { path = relativePath }
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to update shader '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object DeleteShader(string fullPath, string relativePath)
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.Error($"Shader not found at '{relativePath}'.");
-            }
-
-            try
-            {
-                // Delete the asset through Unity's AssetDatabase first
-                var success = AssetDatabase.DeleteAsset(relativePath);
-                if (!success)
-                {
-                    return Response.Error($"Failed to delete shader through Unity's AssetDatabase: '{relativePath}'");
-                }
-
-                // If the file still exists (rare case), try direct deletion
-                if (File.Exists(fullPath))
-                {
-                    File.Delete(fullPath);
-                }
-
-                return Response.Success($"Shader '{Path.GetFileName(relativePath)}' deleted successfully.");
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to delete shader '{relativePath}': {e.Message}");
-            }
-        }
-
-        //This is a CGProgram template
-        //TODO: making a HLSL template as well?
-        private static string GenerateDefaultShaderContent(string name)
-        {
-            return @"Shader """ + name + @"""
-        {
-            Properties
-            {
-                _MainTex (""Texture"", 2D) = ""white"" {}
-            }
-            SubShader
-            {
-                Tags { ""RenderType""=""Opaque"" }
-                LOD 100
-
-                Pass
-                {
-                    CGPROGRAM
-                    #pragma vertex vert
-                    #pragma fragment frag
-                    #include ""UnityCG.cginc""
-
-                    struct appdata
-                    {
-                        float4 vertex : POSITION;
-                        float2 uv : TEXCOORD0;
-                    };
-
-                    struct v2f
-                    {
-                        float2 uv : TEXCOORD0;
-                        float4 vertex : SV_POSITION;
-                    };
-
-                    sampler2D _MainTex;
-                    float4 _MainTex_ST;
-
-                    v2f vert (appdata v)
-                    {
-                        v2f o;
-                        o.vertex = UnityObjectToClipPos(v.vertex);
-                        o.uv = TRANSFORM_TEX(v.uv, _MainTex);
-                        return o;
-                    }
-
-                    fixed4 frag (v2f i) : SV_Target
-                    {
-                        fixed4 col = tex2D(_MainTex, i.uv);
-                        return col;
-                    }
-                    ENDCG
-                }
-            }
-        }";
-        }
-    }
-} 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs.meta b/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime/Serialization/UnityTypeConverters.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: e65311c160f0d41d4a1b45a3dba8dd5a
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,511 +0,0 @@
-using System;
-using System.Linq;
-using System.Threading.Tasks;
-using Newtonsoft.Json.Linq;
-using UnityEngine;
-using UnityEditor;
-using MCPForUnity.Editor.Helpers;
-
-namespace MCPForUnity.Editor.Tools
-{
-    using System.Collections.Generic;
-
-    /// <summary>
-    /// STUDIO: Handles operation queuing for batch execution of MCP commands.
-    /// Allows AI assistants to queue multiple operations and execute them atomically.
-    /// </summary>
-    public static class ManageQueue
-    {
-        /// <summary>
-        /// Main handler for queue management commands
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            if (@params == null)
-            {
-                return Response.EnhancedError(
-                    "Parameters cannot be null",
-                    "Queue management command received null parameters",
-                    "Provide action parameter (add, execute, execute_async, list, clear, stats, cancel)",
-                    new[] { "add", "execute", "execute_async", "list", "clear", "stats", "cancel" },
-                    "NULL_PARAMS"
-                );
-            }
-
-            var action = @params["action"]?.ToString()?.ToLower();
-
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.EnhancedError(
-                    "Action parameter is required",
-                    "Queue management requires an action to be specified",
-                    "Use one of: add, execute, execute_async, list, clear, stats, remove, cancel",
-                    new[] { "add", "execute", "execute_async", "list", "clear", "stats", "remove", "cancel" },
-                    "MISSING_ACTION"
-                );
-            }
-
-            switch (action)
-            {
-                case "add":
-                    return AddOperation(@params);
-
-                case "execute":
-                    return ExecuteBatch(@params);
-
-                case "execute_async":
-                    return ExecuteBatchAsync(@params);
-
-                case "list":
-                    return ListOperations(@params);
-
-                case "clear":
-                    return ClearQueue(@params);
-
-                case "stats":
-                    return GetQueueStats(@params);
-
-                case "remove":
-                    return RemoveOperation(@params);
-
-                case "cancel":
-                    return CancelOperation(@params);
-
-                default:
-                    return Response.EnhancedError(
-                        $"Unknown queue action: '{action}'",
-                        "Queue management action not recognized",
-                        "Use one of: add, execute, execute_async, list, clear, stats, remove, cancel",
-                        new[] { "add", "execute", "execute_async", "list", "clear", "stats", "remove", "cancel" },
-                        "UNKNOWN_ACTION"
-                    );
-            }
-        }
-
-        /// <summary>
-        /// Add an operation to the queue
-        /// </summary>
-        private static object AddOperation(JObject @params)
-        {
-            try
-            {
-                var tool = @params["tool"]?.ToString();
-                var operationParams = @params["parameters"] as JObject;
-                var timeoutMs = @params["timeout_ms"]?.ToObject<int>() ?? 30000;
-
-                if (string.IsNullOrEmpty(tool))
-                {
-                    return Response.EnhancedError(
-                        "Tool parameter is required for add action",
-                        "Adding operation to queue requires specifying which tool to execute",
-                        "Specify tool name (e.g., 'manage_script', 'manage_asset')",
-                        new[] { "manage_script", "manage_asset", "manage_scene", "manage_gameobject" },
-                        "MISSING_TOOL"
-                    );
-                }
-
-                if (operationParams == null)
-                {
-                    return Response.EnhancedError(
-                        "Parameters object is required for add action",
-                        "Adding operation to queue requires parameters for the tool",
-                        "Provide parameters object with the required fields for the tool",
-                        null,
-                        "MISSING_PARAMETERS"
-                    );
-                }
-
-                var operationId = OperationQueue.AddOperation(tool, operationParams, timeoutMs);
-
-                return Response.Success(
-                    $"Operation queued successfully with ID: {operationId}",
-                    new
-                    {
-                        operation_id = operationId,
-                        tool,
-                        timeout_ms = timeoutMs,
-                        queued_at = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC"),
-                        queue_stats = OperationQueue.GetQueueStats()
-                    }
-                );
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to add operation to queue: {ex.Message}",
-                    "Error occurred while adding operation to execution queue",
-                    "Check tool name and parameters format",
-                    null,
-                    "ADD_OPERATION_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Execute all queued operations
-        /// </summary>
-        private static object ExecuteBatch(JObject @params)
-        {
-            try
-            {
-                return OperationQueue.ExecuteBatch();
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to execute batch operations: {ex.Message}",
-                    "Error occurred during batch execution of queued operations",
-                    "Check Unity console for detailed error messages",
-                    null,
-                    "BATCH_EXECUTION_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Execute all queued operations asynchronously
-        /// </summary>
-        private static object ExecuteBatchAsync(JObject @params)
-        {
-            try
-            {
-                // For Unity Editor, we need to use Unity's main thread dispatcher
-                // Since Unity doesn't handle async well in the editor, we'll use a coroutine approach
-                var asyncResult = ExecuteBatchAsyncUnityCompatible();
-                return asyncResult;
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to execute batch operations asynchronously: {ex.Message}",
-                    "Error occurred during async batch execution of queued operations",
-                    "Check Unity console for detailed error messages, consider using synchronous execution",
-                    null,
-                    "ASYNC_BATCH_EXECUTION_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Unity-compatible async batch execution using EditorCoroutines
-        /// </summary>
-        private static object ExecuteBatchAsyncUnityCompatible()
-        {
-            // For Unity Editor compatibility, we'll execute with yielding between operations
-            // This prevents UI freezing while still being "async" from Unity's perspective
-
-            var pendingOps = OperationQueue.GetOperations("pending");
-            if (pendingOps.Count == 0)
-            {
-                return Response.Success("No pending operations to execute.", new { executed_count = 0 });
-            }
-
-            Debug.Log($"STUDIO: Starting async execution of {pendingOps.Count} operations");
-
-            // Start the async execution using Unity's EditorApplication.delayCall
-            // This allows Unity Editor to remain responsive
-            EditorApplication.delayCall += () => ExecuteOperationsWithYield(pendingOps);
-
-            return Response.Success(
-                $"Started async execution of {pendingOps.Count} operations",
-                new
-                {
-                    total_operations = pendingOps.Count,
-                    status = "started_async",
-                    message = "Use 'stats' action to monitor progress"
-                }
-            );
-        }
-
-        /// <summary>
-        /// Execute operations with yielding to keep Unity Editor responsive
-        /// </summary>
-        private static async void ExecuteOperationsWithYield(List<OperationQueue.QueuedOperation> operations)
-        {
-            foreach (var operation in operations)
-            {
-                try
-                {
-                    // Update status to executing
-                    operation.Status = "executing";
-                    operation.ExecutionStartTime = DateTime.UtcNow;
-
-                    Debug.Log($"STUDIO: Executing operation {operation.Id} ({operation.Tool})");
-
-                    // Execute the operation
-                    var result = await Task.Run(() =>
-                    {
-                        try
-                        {
-                            switch (operation.Tool.ToLowerInvariant())
-                            {
-                                case "manage_script":
-                                    return Tools.ManageScript.HandleCommand(operation.Parameters);
-                                case "manage_asset":
-                                    return Tools.ManageAsset.HandleCommand(operation.Parameters);
-                                case "manage_scene":
-                                    return Tools.ManageScene.HandleCommand(operation.Parameters);
-                                case "manage_gameobject":
-                                    return Tools.ManageGameObject.HandleCommand(operation.Parameters);
-                                case "manage_shader":
-                                    return Tools.ManageShader.HandleCommand(operation.Parameters);
-                                case "manage_editor":
-                                    return Tools.ManageEditor.HandleCommand(operation.Parameters);
-                                case "read_console":
-                                    return Tools.ReadConsole.HandleCommand(operation.Parameters);
-                                case "execute_menu_item":
-                                    return Tools.ExecuteMenuItem.HandleCommand(operation.Parameters);
-                                default:
-                                    throw new ArgumentException($"Unknown tool: {operation.Tool}");
-                            }
-                        }
-                        catch (Exception e)
-                        {
-                            throw new Exception($"Operation {operation.Id} failed: {e.Message}", e);
-                        }
-                    });
-
-                    // Update operation status
-                    operation.Result = result;
-                    operation.Status = "executed";
-                    operation.ExecutionEndTime = DateTime.UtcNow;
-
-                    Debug.Log($"STUDIO: Completed operation {operation.Id}");
-                }
-                catch (Exception ex)
-                {
-                    operation.Error = ex;
-                    operation.Status = "failed";
-                    operation.ExecutionEndTime = DateTime.UtcNow;
-                    Debug.LogError($"STUDIO: Operation {operation.Id} failed: {ex.Message}");
-                }
-
-                // Yield control back to Unity Editor to keep it responsive
-                await Task.Yield();
-            }
-
-            Debug.Log("STUDIO: Async batch execution completed");
-        }
-
-        /// <summary>
-        /// Cancel a running operation
-        /// </summary>
-        private static object CancelOperation(JObject @params)
-        {
-            try
-            {
-                var operationId = @params["operation_id"]?.ToString();
-
-                if (string.IsNullOrEmpty(operationId))
-                {
-                    return Response.EnhancedError(
-                        "Operation ID is required for cancel action",
-                        "Cancelling operation requires operation ID",
-                        "Use 'list' action to see available operation IDs",
-                        null,
-                        "MISSING_OPERATION_ID"
-                    );
-                }
-
-                var cancelled = OperationQueue.CancelOperation(operationId);
-
-                if (cancelled)
-                {
-                    return Response.Success(
-                        $"Operation {operationId} cancelled successfully",
-                        new
-                        {
-                            operation_id = operationId,
-                            cancelled = true,
-                            queue_stats = OperationQueue.GetQueueStats()
-                        }
-                    );
-                }
-                else
-                {
-                    return Response.EnhancedError(
-                        $"Operation {operationId} could not be cancelled",
-                        "Operation may not exist or is not currently executing",
-                        "Use 'list' action to see available operation IDs and their status",
-                        null,
-                        "CANCEL_FAILED"
-                    );
-                }
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to cancel operation: {ex.Message}",
-                    "Error occurred while cancelling operation",
-                    "Check operation ID format and queue accessibility",
-                    null,
-                    "CANCEL_OPERATION_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// List operations in the queue
-        /// </summary>
-        private static object ListOperations(JObject @params)
-        {
-            try
-            {
-                var statusFilter = @params["status"]?.ToString()?.ToLower();
-                var limit = @params["limit"]?.ToObject<int?>();
-
-                var operations = OperationQueue.GetOperations(statusFilter);
-
-                if (limit.HasValue && limit.Value > 0)
-                {
-                    operations = operations.Take(limit.Value).ToList();
-                }
-
-                var operationData = operations.Select(op => new
-                {
-                    id = op.Id,
-                    tool = op.Tool,
-                    status = op.Status,
-                    queued_at = op.QueuedAt.ToString("yyyy-MM-dd HH:mm:ss UTC"),
-                    parameters = op.Parameters,
-                    result = op.Status == "executed" ? op.Result : null,
-                    error = op.Status == "failed" ? op.Error?.Message : null
-                }).ToList();
-
-                return Response.Success(
-                    $"Found {operationData.Count} operations" + (statusFilter != null ? $" with status '{statusFilter}'" : ""),
-                    new
-                    {
-                        operations = operationData,
-                        total_count = operations.Count,
-                        status_filter = statusFilter,
-                        queue_stats = OperationQueue.GetQueueStats()
-                    }
-                );
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to list queue operations: {ex.Message}",
-                    "Error occurred while retrieving queue operations",
-                    "Check if queue system is properly initialized",
-                    null,
-                    "LIST_OPERATIONS_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Clear operations from the queue
-        /// </summary>
-        private static object ClearQueue(JObject @params)
-        {
-            try
-            {
-                var statusFilter = @params["status"]?.ToString()?.ToLower();
-                var removedCount = OperationQueue.ClearQueue(statusFilter);
-
-                var message = statusFilter != null
-                    ? $"Cleared {removedCount} operations with status '{statusFilter}'"
-                    : $"Cleared {removedCount} completed operations from queue";
-
-                return Response.Success(message, new
-                {
-                    removed_count = removedCount,
-                    status_filter = statusFilter,
-                    queue_stats = OperationQueue.GetQueueStats()
-                });
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to clear queue: {ex.Message}",
-                    "Error occurred while clearing queue operations",
-                    "Check if queue system is accessible",
-                    null,
-                    "CLEAR_QUEUE_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Get queue statistics
-        /// </summary>
-        private static object GetQueueStats(JObject @params)
-        {
-            try
-            {
-                var stats = OperationQueue.GetQueueStats();
-                return Response.Success("Queue statistics retrieved", stats);
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to get queue statistics: {ex.Message}",
-                    "Error occurred while retrieving queue statistics",
-                    "Check if queue system is properly initialized",
-                    null,
-                    "QUEUE_STATS_ERROR"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Remove a specific operation from the queue
-        /// </summary>
-        private static object RemoveOperation(JObject @params)
-        {
-            try
-            {
-                var operationId = @params["operation_id"]?.ToString();
-
-                if (string.IsNullOrEmpty(operationId))
-                {
-                    return Response.EnhancedError(
-                        "Operation ID is required for remove action",
-                        "Removing specific operation requires operation ID",
-                        "Use 'list' action to see available operation IDs",
-                        null,
-                        "MISSING_OPERATION_ID"
-                    );
-                }
-
-                var removed = OperationQueue.RemoveOperation(operationId);
-
-                if (removed)
-                {
-                    return Response.Success(
-                        $"Operation {operationId} removed from queue",
-                        new
-                        {
-                            operation_id = operationId,
-                            queue_stats = OperationQueue.GetQueueStats()
-                        }
-                    );
-                }
-                else
-                {
-                    return Response.EnhancedError(
-                        $"Operation {operationId} not found in queue",
-                        "Specified operation ID does not exist in the queue",
-                        "Use 'list' action to see available operation IDs",
-                        null,
-                        "OPERATION_NOT_FOUND",
-                        null,
-                        null
-                    );
-                }
-            }
-            catch (Exception ex)
-            {
-                return Response.EnhancedError(
-                    $"Failed to remove operation: {ex.Message}",
-                    "Error occurred while removing operation from queue",
-                    "Check operation ID format and queue accessibility",
-                    null,
-                    "REMOVE_OPERATION_ERROR"
-                );
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,427 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEditor.SceneManagement;
-using UnityEngine;
-using UnityEngine.SceneManagement;
-using MCPForUnity.Editor.Helpers; // For Response class
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles scene management operations like loading, saving, creating, and querying hierarchy.
-    /// </summary>
-    public static class ManageScene
-    {
-        /// <summary>
-        /// Main handler for scene management actions.
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            var action = @params["action"]?.ToString().ToLower();
-            var name = @params["name"]?.ToString();
-            var path = @params["path"]?.ToString(); // Relative to Assets/
-            var buildIndex = @params["buildIndex"]?.ToObject<int?>();
-            // bool loadAdditive = @params["loadAdditive"]?.ToObject<bool>() ?? false; // Example for future extension
-
-            // Ensure path is relative to Assets/, removing any leading "Assets/"
-            var relativeDir = path ?? string.Empty;
-            if (!string.IsNullOrEmpty(relativeDir))
-            {
-                relativeDir = relativeDir.Replace('\\', '/').Trim('/');
-                if (relativeDir.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase))
-                {
-                    relativeDir = relativeDir.Substring("Assets/".Length).TrimStart('/');
-                }
-            }
-
-            // Apply default *after* sanitizing, using the original path variable for the check
-            if (string.IsNullOrEmpty(path) && action == "create") // Check original path for emptiness
-            {
-                relativeDir = "Scenes"; // Default relative directory
-            }
-
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-
-            var sceneFileName = string.IsNullOrEmpty(name) ? null : $"{name}.unity";
-            // Construct full system path correctly: ProjectRoot/Assets/relativeDir/sceneFileName
-            var fullPathDir = Path.Combine(Application.dataPath, relativeDir); // Combine with Assets path (Application.dataPath ends in Assets)
-            var fullPath = string.IsNullOrEmpty(sceneFileName)
-                ? null
-                : Path.Combine(fullPathDir, sceneFileName);
-            // Ensure relativePath always starts with "Assets/" and uses forward slashes
-            var relativePath = string.IsNullOrEmpty(sceneFileName)
-                ? null
-                : Path.Combine("Assets", relativeDir, sceneFileName).Replace('\\', '/');
-
-            // Ensure directory exists for 'create'
-            if (action == "create" && !string.IsNullOrEmpty(fullPathDir))
-            {
-                try
-                {
-                    Directory.CreateDirectory(fullPathDir);
-                }
-                catch (Exception e)
-                {
-                    return Response.Error(
-                        $"Could not create directory '{fullPathDir}': {e.Message}"
-                    );
-                }
-            }
-
-            // Route action
-            switch (action)
-            {
-                case "create":
-                    if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(relativePath))
-                        return Response.Error(
-                            "'name' and 'path' parameters are required for 'create' action."
-                        );
-                    return CreateScene(fullPath, relativePath);
-                case "load":
-                    // Loading can be done by path/name or build index
-                    if (!string.IsNullOrEmpty(relativePath))
-                        return LoadScene(relativePath);
-                    else if (buildIndex.HasValue)
-                        return LoadScene(buildIndex.Value);
-                    else
-                        return Response.Error(
-                            "Either 'name'/'path' or 'buildIndex' must be provided for 'load' action."
-                        );
-                case "save":
-                    // Save current scene, optionally to a new path
-                    return SaveScene(fullPath, relativePath);
-                case "get_hierarchy":
-                    return GetSceneHierarchy();
-                case "get_active":
-                    return GetActiveSceneInfo();
-                case "get_build_settings":
-                    return GetBuildSettingsScenes();
-                // Add cases for modifying build settings, additive loading, unloading etc.
-                default:
-                    return Response.Error(
-                        $"Unknown action: '{action}'. Valid actions: create, load, save, get_hierarchy, get_active, get_build_settings."
-                    );
-            }
-        }
-
-        private static object CreateScene(string fullPath, string relativePath)
-        {
-            if (File.Exists(fullPath))
-            {
-                return Response.Error($"Scene already exists at '{relativePath}'.");
-            }
-
-            try
-            {
-                // Create a new empty scene
-                var newScene = EditorSceneManager.NewScene(
-                    NewSceneSetup.EmptyScene,
-                    NewSceneMode.Single
-                );
-                // Save it to the specified path
-                var saved = EditorSceneManager.SaveScene(newScene, relativePath);
-
-                if (saved)
-                {
-                    AssetDatabase.Refresh(); // Ensure Unity sees the new scene file
-                    return Response.Success(
-                        $"Scene '{Path.GetFileName(relativePath)}' created successfully at '{relativePath}'.",
-                        new { path = relativePath }
-                    );
-                }
-                else
-                {
-                    // If SaveScene fails, it might leave an untitled scene open.
-                    // Optionally try to close it, but be cautious.
-                    return Response.Error($"Failed to save new scene to '{relativePath}'.");
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error creating scene '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object LoadScene(string relativePath)
-        {
-            if (
-                !File.Exists(
-                    Path.Combine(
-                        Application.dataPath.Substring(
-                            0,
-                            Application.dataPath.Length - "Assets".Length
-                        ),
-                        relativePath
-                    )
-                )
-            )
-            {
-                return Response.Error($"Scene file not found at '{relativePath}'.");
-            }
-
-            // Check for unsaved changes in the current scene
-            if (EditorSceneManager.GetActiveScene().isDirty)
-            {
-                // Optionally prompt the user or save automatically before loading
-                return Response.Error(
-                    "Current scene has unsaved changes. Please save or discard changes before loading a new scene."
-                );
-                // Example: bool saveOK = EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo();
-                // if (!saveOK) return Response.Error("Load cancelled by user.");
-            }
-
-            try
-            {
-                EditorSceneManager.OpenScene(relativePath, OpenSceneMode.Single);
-                return Response.Success(
-                    $"Scene '{relativePath}' loaded successfully.",
-                    new
-                    {
-                        path = relativePath,
-                        name = Path.GetFileNameWithoutExtension(relativePath),
-                    }
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error loading scene '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object LoadScene(int buildIndex)
-        {
-            if (buildIndex < 0 || buildIndex >= SceneManager.sceneCountInBuildSettings)
-            {
-                return Response.Error(
-                    $"Invalid build index: {buildIndex}. Must be between 0 and {SceneManager.sceneCountInBuildSettings - 1}."
-                );
-            }
-
-            // Check for unsaved changes
-            if (EditorSceneManager.GetActiveScene().isDirty)
-            {
-                return Response.Error(
-                    "Current scene has unsaved changes. Please save or discard changes before loading a new scene."
-                );
-            }
-
-            try
-            {
-                var scenePath = SceneUtility.GetScenePathByBuildIndex(buildIndex);
-                EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Single);
-                return Response.Success(
-                    $"Scene at build index {buildIndex} ('{scenePath}') loaded successfully.",
-                    new
-                    {
-                        path = scenePath,
-                        name = Path.GetFileNameWithoutExtension(scenePath),
-                        buildIndex,
-                    }
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error(
-                    $"Error loading scene with build index {buildIndex}: {e.Message}"
-                );
-            }
-        }
-
-        private static object SaveScene(string fullPath, string relativePath)
-        {
-            try
-            {
-                var currentScene = EditorSceneManager.GetActiveScene();
-                if (!currentScene.IsValid())
-                {
-                    return Response.Error("No valid scene is currently active to save.");
-                }
-
-                bool saved;
-                var finalPath = currentScene.path; // Path where it was last saved or will be saved
-
-                if (!string.IsNullOrEmpty(relativePath) && currentScene.path != relativePath)
-                {
-                    // Save As...
-                    // Ensure directory exists
-                    var dir = Path.GetDirectoryName(fullPath);
-                    if (!Directory.Exists(dir))
-                        Directory.CreateDirectory(dir);
-
-                    saved = EditorSceneManager.SaveScene(currentScene, relativePath);
-                    finalPath = relativePath;
-                }
-                else
-                {
-                    // Save (overwrite existing or save untitled)
-                    if (string.IsNullOrEmpty(currentScene.path))
-                    {
-                        // Scene is untitled, needs a path
-                        return Response.Error(
-                            "Cannot save an untitled scene without providing a 'name' and 'path'. Use Save As functionality."
-                        );
-                    }
-                    saved = EditorSceneManager.SaveScene(currentScene);
-                }
-
-                if (saved)
-                {
-                    AssetDatabase.Refresh();
-                    return Response.Success(
-                        $"Scene '{currentScene.name}' saved successfully to '{finalPath}'.",
-                        new { path = finalPath, currentScene.name }
-                    );
-                }
-                else
-                {
-                    return Response.Error($"Failed to save scene '{currentScene.name}'.");
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error saving scene: {e.Message}");
-            }
-        }
-
-        private static object GetActiveSceneInfo()
-        {
-            try
-            {
-                var activeScene = EditorSceneManager.GetActiveScene();
-                if (!activeScene.IsValid())
-                {
-                    return Response.Error("No active scene found.");
-                }
-
-                var sceneInfo = new
-                {
-                    activeScene.name,
-                    activeScene.path,
-                    activeScene.buildIndex, // -1 if not in build settings
-                    activeScene.isDirty,
-                    activeScene.isLoaded,
-                    activeScene.rootCount,
-                };
-
-                return Response.Success("Retrieved active scene information.", sceneInfo);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting active scene info: {e.Message}");
-            }
-        }
-
-        private static object GetBuildSettingsScenes()
-        {
-            try
-            {
-                var scenes = new List<object>();
-                for (var i = 0; i < EditorBuildSettings.scenes.Length; i++)
-                {
-                    var scene = EditorBuildSettings.scenes[i];
-                    scenes.Add(
-                        new
-                        {
-                            scene.path,
-                            guid = scene.guid.ToString(),
-                            scene.enabled,
-                            buildIndex = i, // Actual build index considering only enabled scenes might differ
-                        }
-                    );
-                }
-                return Response.Success("Retrieved scenes from Build Settings.", scenes);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting scenes from Build Settings: {e.Message}");
-            }
-        }
-
-        private static object GetSceneHierarchy()
-        {
-            try
-            {
-                var activeScene = EditorSceneManager.GetActiveScene();
-                if (!activeScene.IsValid() || !activeScene.isLoaded)
-                {
-                    return Response.Error(
-                        "No valid and loaded scene is active to get hierarchy from."
-                    );
-                }
-
-                var rootObjects = activeScene.GetRootGameObjects();
-                var hierarchy = rootObjects.Select(go => GetGameObjectDataRecursive(go)).ToList();
-
-                return Response.Success(
-                    $"Retrieved hierarchy for scene '{activeScene.name}'.",
-                    hierarchy
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting scene hierarchy: {e.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Recursively builds a data representation of a GameObject and its children.
-        /// </summary>
-        private static object GetGameObjectDataRecursive(GameObject go)
-        {
-            if (go == null)
-                return null;
-
-            var childrenData = new List<object>();
-            foreach (Transform child in go.transform)
-            {
-                childrenData.Add(GetGameObjectDataRecursive(child.gameObject));
-            }
-
-            var gameObjectData = new Dictionary<string, object>
-            {
-                { "name", go.name },
-                { "activeSelf", go.activeSelf },
-                { "activeInHierarchy", go.activeInHierarchy },
-                { "tag", go.tag },
-                { "layer", go.layer },
-                { "isStatic", go.isStatic },
-                { "instanceID", go.GetInstanceID() }, // Useful unique identifier
-                {
-                    "transform",
-                    new
-                    {
-                        position = new
-                        {
-                            go.transform.localPosition.x,
-                            go.transform.localPosition.y,
-                            go.transform.localPosition.z,
-                        },
-                        rotation = new
-                        {
-                            go.transform.localRotation.eulerAngles.x,
-                            go.transform.localRotation.eulerAngles.y,
-                            go.transform.localRotation.eulerAngles.z,
-                        }, // Euler for simplicity
-                        scale = new
-                        {
-                            go.transform.localScale.x,
-                            go.transform.localScale.y,
-                            go.transform.localScale.z,
-                        },
-                    }
-                },
-                { "children", childrenData },
-            };
-
-            return gameObjectData;
-        }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef.meta b/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,7 +0,0 @@
-fileFormatVersion: 2
-guid: 98f702da6ca044be59a864a9419c4eab
-AssemblyDefinitionImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/package.json.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/package.json.meta b/Packages/UnityMcpBridge/package.json.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/package.json.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,7 +0,0 @@
-fileFormatVersion: 2
-guid: a2f7ae0675bf4fb478a0a1df7a3f6c64
-TextScriptImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/Response.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/Response.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/Response.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/Response.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 80c09a76b944f8c4691e06c4d76c4be8
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs b/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,129 +0,0 @@
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    public static class ConfigJsonBuilder
-    {
-        public static string BuildManualConfigJson(string uvPath, string pythonDir, McpClient client)
-        {
-            var root = new JObject();
-            var isVSCode = client?.mcpType == McpTypes.VSCode;
-            JObject container;
-            if (isVSCode)
-            {
-                container = EnsureObject(root, "servers");
-            }
-            else
-            {
-                container = EnsureObject(root, "mcpServers");
-            }
-
-            var unity = new JObject();
-            PopulateUnityNode(unity, uvPath, pythonDir, client, isVSCode);
-
-            container["unityMCP"] = unity;
-
-            return root.ToString(Formatting.Indented);
-        }
-
-        public static JObject ApplyUnityServerToExistingConfig(JObject root, string uvPath, string serverSrc, McpClient client)
-        {
-            if (root == null) root = new JObject();
-            var isVSCode = client?.mcpType == McpTypes.VSCode;
-            var container = isVSCode ? EnsureObject(root, "servers") : EnsureObject(root, "mcpServers");
-            var unity = container["unityMCP"] as JObject ?? new JObject();
-            PopulateUnityNode(unity, uvPath, serverSrc, client, isVSCode);
-
-            container["unityMCP"] = unity;
-            return root;
-        }
-
-        /// <summary>
-        /// Centralized builder that applies all caveats consistently.
-        /// - Sets command/args with provided directory
-        /// - Ensures env exists
-        /// - Adds type:"stdio" for VSCode
-        /// - Adds disabled:false for Windsurf/Kiro only when missing
-        /// </summary>
-        private static void PopulateUnityNode(JObject unity, string uvPath, string directory, McpClient client, bool isVSCode)
-        {
-            unity["command"] = uvPath;
-
-            // For Cursor (non-VSCode) on macOS, prefer a no-spaces symlink path to avoid arg parsing issues in some runners
-            var effectiveDir = directory;
-#if UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX
-            bool isCursor = !isVSCode && (client == null || client.mcpType != McpTypes.VSCode);
-            if (isCursor && !string.IsNullOrEmpty(directory))
-            {
-                // Replace canonical path segment with the symlink path if present
-                const string canonical = "/Library/Application Support/";
-                const string symlinkSeg = "/Library/AppSupport/";
-                try
-                {
-                    // Normalize to full path style
-                    if (directory.Contains(canonical))
-                    {
-                        var candidate = directory.Replace(canonical, symlinkSeg).Replace('\\', '/');
-                        if (System.IO.Directory.Exists(candidate))
-                        {
-                            effectiveDir = candidate;
-                        }
-                    }
-                    else
-                    {
-                        // If installer returned XDG-style on macOS, map to canonical symlink
-                        string norm = directory.Replace('\\', '/');
-                        int idx = norm.IndexOf("/.local/share/UnityMCP/", System.StringComparison.Ordinal);
-                        if (idx >= 0)
-                        {
-                            string home = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal) ?? string.Empty;
-                            string suffix = norm.Substring(idx + "/.local/share/".Length); // UnityMCP/...
-                            string candidate = System.IO.Path.Combine(home, "Library", "AppSupport", suffix).Replace('\\', '/');
-                            if (System.IO.Directory.Exists(candidate))
-                            {
-                                effectiveDir = candidate;
-                            }
-                        }
-                    }
-                }
-                catch { /* fallback to original directory on any error */ }
-            }
-#endif
-
-            unity["args"] = JArray.FromObject(new[] { "run", "--directory", effectiveDir, "server.py" });
-
-            if (isVSCode)
-            {
-                unity["type"] = "stdio";
-            }
-            else
-            {
-                // Remove type if it somehow exists from previous clients
-                if (unity["type"] != null) unity.Remove("type");
-            }
-
-            if (client != null && (client.mcpType == McpTypes.Windsurf || client.mcpType == McpTypes.Kiro))
-            {
-                if (unity["env"] == null)
-                {
-                    unity["env"] = new JObject();
-                }
-
-                if (unity["disabled"] == null)
-                {
-                    unity["disabled"] = false;
-                }
-            }
-        }
-
-        private static JObject EnsureObject(JObject parent, string name)
-        {
-            if (parent[name] is JObject o) return o;
-            var created = new JObject();
-            parent[name] = created;
-            return created;
-        }
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/CommandRegistry.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 5b61b5a84813b5749a5c64422694a0fa
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 64b8ff807bc9a401c82015cbafccffac
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,1338 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers; // For Response class
-
-#if UNITY_6000_0_OR_NEWER
-using PhysicsMaterialType = UnityEngine.PhysicsMaterial;
-using PhysicsMaterialCombine = UnityEngine.PhysicsMaterialCombine;  
-#else
-using PhysicsMaterialType = UnityEngine.PhysicMaterial;
-using PhysicsMaterialCombine = UnityEngine.PhysicMaterialCombine;
-#endif
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles asset management operations within the Unity project.
-    /// </summary>
-    public static class ManageAsset
-    {
-        // --- Main Handler ---
-
-        // Define the list of valid actions
-        private static readonly List<string> ValidActions = new List<string>
-        {
-            "import",
-            "create",
-            "modify",
-            "delete",
-            "duplicate",
-            "move",
-            "rename",
-            "search",
-            "get_info",
-            "create_folder",
-            "get_components",
-        };
-
-        public static object HandleCommand(JObject @params)
-        {
-            var action = @params["action"]?.ToString().ToLower();
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-
-            // Check if the action is valid before switching
-            if (!ValidActions.Contains(action))
-            {
-                var validActionsList = string.Join(", ", ValidActions);
-                return Response.Error(
-                    $"Unknown action: '{action}'. Valid actions are: {validActionsList}"
-                );
-            }
-
-            // Common parameters
-            var path = @params["path"]?.ToString();
-
-            try
-            {
-                switch (action)
-                {
-                    case "import":
-                        // Note: Unity typically auto-imports. This might re-import or configure import settings.
-                        return ReimportAsset(path, @params["properties"] as JObject);
-                    case "create":
-                        return CreateAsset(@params);
-                    case "modify":
-                        return ModifyAsset(path, @params["properties"] as JObject);
-                    case "delete":
-                        return DeleteAsset(path);
-                    case "duplicate":
-                        return DuplicateAsset(path, @params["destination"]?.ToString());
-                    case "move": // Often same as rename if within Assets/
-                    case "rename":
-                        return MoveOrRenameAsset(path, @params["destination"]?.ToString());
-                    case "search":
-                        return SearchAssets(@params);
-                    case "get_info":
-                        return GetAssetInfo(
-                            path,
-                            @params["generatePreview"]?.ToObject<bool>() ?? false
-                        );
-                    case "create_folder": // Added specific action for clarity
-                        return CreateFolder(path);
-                    case "get_components":
-                        return GetComponentsFromAsset(path);
-
-                    default:
-                        // This error message is less likely to be hit now, but kept here as a fallback or for potential future modifications.
-                        var validActionsListDefault = string.Join(", ", ValidActions);
-                        return Response.Error(
-                            $"Unknown action: '{action}'. Valid actions are: {validActionsListDefault}"
-                        );
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ManageAsset] Action '{action}' failed for path '{path}': {e}");
-                return Response.Error(
-                    $"Internal error processing action '{action}' on '{path}': {e.Message}"
-                );
-            }
-        }
-
-        // --- Action Implementations ---
-
-        private static object ReimportAsset(string path, JObject properties)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for reimport.");
-            var fullPath = SanitizeAssetPath(path);
-            if (!AssetExists(fullPath))
-                return Response.Error($"Asset not found at path: {fullPath}");
-
-            try
-            {
-                // TODO: Apply importer properties before reimporting?
-                // This is complex as it requires getting the AssetImporter, casting it,
-                // applying properties via reflection or specific methods, saving, then reimporting.
-                if (properties != null && properties.HasValues)
-                {
-                    Debug.LogWarning(
-                        "[ManageAsset.Reimport] Modifying importer properties before reimport is not fully implemented yet."
-                    );
-                    // AssetImporter importer = AssetImporter.GetAtPath(fullPath);
-                    // if (importer != null) { /* Apply properties */ AssetDatabase.WriteImportSettingsIfDirty(fullPath); }
-                }
-
-                AssetDatabase.ImportAsset(fullPath, ImportAssetOptions.ForceUpdate);
-                // AssetDatabase.Refresh(); // Usually ImportAsset handles refresh
-                return Response.Success($"Asset '{fullPath}' reimported.", GetAssetData(fullPath));
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to reimport asset '{fullPath}': {e.Message}");
-            }
-        }
-
-        private static object CreateAsset(JObject @params)
-        {
-            var path = @params["path"]?.ToString();
-            var assetType = @params["assetType"]?.ToString();
-            var properties = @params["properties"] as JObject;
-
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for create.");
-            if (string.IsNullOrEmpty(assetType))
-                return Response.Error("'assetType' is required for create.");
-
-            var fullPath = SanitizeAssetPath(path);
-            var directory = Path.GetDirectoryName(fullPath);
-
-            // Ensure directory exists
-            if (!Directory.Exists(Path.Combine(Directory.GetCurrentDirectory(), directory)))
-            {
-                Directory.CreateDirectory(Path.Combine(Directory.GetCurrentDirectory(), directory));
-                AssetDatabase.Refresh(); // Make sure Unity knows about the new folder
-            }
-
-            if (AssetExists(fullPath))
-                return Response.Error($"Asset already exists at path: {fullPath}");
-
-            try
-            {
-                UnityEngine.Object newAsset = null;
-                var lowerAssetType = assetType.ToLowerInvariant();
-
-                // Handle common asset types
-                if (lowerAssetType == "folder")
-                {
-                    return CreateFolder(path); // Use dedicated method
-                }
-                else if (lowerAssetType == "material")
-                {
-                    // Prefer provided shader; fall back to common pipelines
-                    var requested = properties?["shader"]?.ToString();
-                    var shader =
-                        (!string.IsNullOrEmpty(requested) ? Shader.Find(requested) : null)
-                        ?? Shader.Find("Universal Render Pipeline/Lit")
-                        ?? Shader.Find("HDRP/Lit")
-                        ?? Shader.Find("Standard")
-                        ?? Shader.Find("Unlit/Color");
-                    if (shader == null)
-                        return Response.Error($"Could not find a suitable shader (requested: '{requested ?? "none"}').");
-
-                    var mat = new Material(shader);
-                    if (properties != null)
-                        ApplyMaterialProperties(mat, properties);
-                    AssetDatabase.CreateAsset(mat, fullPath);
-                    newAsset = mat;
-                }
-                else if (lowerAssetType == "physicsmaterial")
-                {
-                    var pmat = new PhysicsMaterialType();
-                    if (properties != null)
-                        ApplyPhysicsMaterialProperties(pmat, properties);
-                    AssetDatabase.CreateAsset(pmat, fullPath);
-                    newAsset = pmat;
-                }
-                else if (lowerAssetType == "scriptableobject")
-                {
-                    var scriptClassName = properties?["scriptClass"]?.ToString();
-                    if (string.IsNullOrEmpty(scriptClassName))
-                        return Response.Error(
-                            "'scriptClass' property required when creating ScriptableObject asset."
-                        );
-
-                    var scriptType = ComponentResolver.TryResolve(scriptClassName, out var resolvedType, out var error) ? resolvedType : null;
-                    if (
-                        scriptType == null
-                        || !typeof(ScriptableObject).IsAssignableFrom(scriptType)
-                    )
-                    {
-                        var reason = scriptType == null
-                            ? (string.IsNullOrEmpty(error) ? "Type not found." : error)
-                            : "Type found but does not inherit from ScriptableObject.";
-                        return Response.Error($"Script class '{scriptClassName}' invalid: {reason}");
-                    }
-
-                    var so = ScriptableObject.CreateInstance(scriptType);
-                    // TODO: Apply properties from JObject to the ScriptableObject instance?
-                    AssetDatabase.CreateAsset(so, fullPath);
-                    newAsset = so;
-                }
-                else if (lowerAssetType == "prefab")
-                {
-                    // Creating prefabs usually involves saving an existing GameObject hierarchy.
-                    // A common pattern is to create an empty GameObject, configure it, and then save it.
-                    return Response.Error(
-                        "Creating prefabs programmatically usually requires a source GameObject. Use manage_gameobject to create/configure, then save as prefab via a separate mechanism or future enhancement."
-                    );
-                    // Example (conceptual):
-                    // GameObject source = GameObject.Find(properties["sourceGameObject"].ToString());
-                    // if(source != null) PrefabUtility.SaveAsPrefabAsset(source, fullPath);
-                }
-                // TODO: Add more asset types (Animation Controller, Scene, etc.)
-                else
-                {
-                    // Generic creation attempt (might fail or create empty files)
-                    // For some types, just creating the file might be enough if Unity imports it.
-                    // File.Create(Path.Combine(Directory.GetCurrentDirectory(), fullPath)).Close();
-                    // AssetDatabase.ImportAsset(fullPath); // Let Unity try to import it
-                    // newAsset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(fullPath);
-                    return Response.Error(
-                        $"Creation for asset type '{assetType}' is not explicitly supported yet. Supported: Folder, Material, ScriptableObject."
-                    );
-                }
-
-                if (
-                    newAsset == null
-                    && !Directory.Exists(Path.Combine(Directory.GetCurrentDirectory(), fullPath))
-                ) // Check if it wasn't a folder and asset wasn't created
-                {
-                    return Response.Error(
-                        $"Failed to create asset '{assetType}' at '{fullPath}'. See logs for details."
-                    );
-                }
-
-                AssetDatabase.SaveAssets();
-                // AssetDatabase.Refresh(); // CreateAsset often handles refresh
-                return Response.Success(
-                    $"Asset '{fullPath}' created successfully.",
-                    GetAssetData(fullPath)
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to create asset at '{fullPath}': {e.Message}");
-            }
-        }
-
-        private static object CreateFolder(string path)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for create_folder.");
-            var fullPath = SanitizeAssetPath(path);
-            var parentDir = Path.GetDirectoryName(fullPath);
-            var folderName = Path.GetFileName(fullPath);
-
-            if (AssetExists(fullPath))
-            {
-                // Check if it's actually a folder already
-                if (AssetDatabase.IsValidFolder(fullPath))
-                {
-                    return Response.Success(
-                        $"Folder already exists at path: {fullPath}",
-                        GetAssetData(fullPath)
-                    );
-                }
-                else
-                {
-                    return Response.Error(
-                        $"An asset (not a folder) already exists at path: {fullPath}"
-                    );
-                }
-            }
-
-            try
-            {
-                // Ensure parent exists
-                if (!string.IsNullOrEmpty(parentDir) && !AssetDatabase.IsValidFolder(parentDir))
-                {
-                    // Recursively create parent folders if needed (AssetDatabase handles this internally)
-                    // Or we can do it manually: Directory.CreateDirectory(Path.Combine(Directory.GetCurrentDirectory(), parentDir)); AssetDatabase.Refresh();
-                }
-
-                var guid = AssetDatabase.CreateFolder(parentDir, folderName);
-                if (string.IsNullOrEmpty(guid))
-                {
-                    return Response.Error(
-                        $"Failed to create folder '{fullPath}'. Check logs and permissions."
-                    );
-                }
-
-                // AssetDatabase.Refresh(); // CreateFolder usually handles refresh
-                return Response.Success(
-                    $"Folder '{fullPath}' created successfully.",
-                    GetAssetData(fullPath)
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to create folder '{fullPath}': {e.Message}");
-            }
-        }
-
-        private static object ModifyAsset(string path, JObject properties)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for modify.");
-            if (properties == null || !properties.HasValues)
-                return Response.Error("'properties' are required for modify.");
-
-            var fullPath = SanitizeAssetPath(path);
-            if (!AssetExists(fullPath))
-                return Response.Error($"Asset not found at path: {fullPath}");
-
-            try
-            {
-                var asset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(
-                    fullPath
-                );
-                if (asset == null)
-                    return Response.Error($"Failed to load asset at path: {fullPath}");
-
-                var modified = false; // Flag to track if any changes were made
-
-                // --- NEW: Handle GameObject / Prefab Component Modification ---
-                if (asset is GameObject gameObject)
-                {
-                    // Iterate through the properties JSON: keys are component names, values are properties objects for that component
-                    foreach (var prop in properties.Properties())
-                    {
-                        var componentName = prop.Name; // e.g., "Collectible"
-                        // Check if the value associated with the component name is actually an object containing properties
-                        if (
-                            prop.Value is JObject componentProperties
-                            && componentProperties.HasValues
-                        ) // e.g., {"bobSpeed": 2.0}
-                        {
-                            // Resolve component type via ComponentResolver, then fetch by Type
-                            Component targetComponent = null;
-                            var resolved = ComponentResolver.TryResolve(componentName, out var compType, out var compError);
-                            if (resolved)
-                            {
-                                targetComponent = gameObject.GetComponent(compType);
-                            }
-
-                            // Only warn about resolution failure if component also not found
-                            if (targetComponent == null && !resolved)
-                            {
-                                Debug.LogWarning(
-                                    $"[ManageAsset.ModifyAsset] Failed to resolve component '{componentName}' on '{gameObject.name}': {compError}"
-                                );
-                            }
-
-                            if (targetComponent != null)
-                            {
-                                // Apply the nested properties (e.g., bobSpeed) to the found component instance
-                                // Use |= to ensure 'modified' becomes true if any component is successfully modified
-                                modified |= ApplyObjectProperties(
-                                    targetComponent,
-                                    componentProperties
-                                );
-                            }
-                            else
-                            {
-                                // Log a warning if a specified component couldn't be found
-                                Debug.LogWarning(
-                                    $"[ManageAsset.ModifyAsset] Component '{componentName}' not found on GameObject '{gameObject.name}' in asset '{fullPath}'. Skipping modification for this component."
-                                );
-                            }
-                        }
-                        else
-                        {
-                            // Log a warning if the structure isn't {"ComponentName": {"prop": value}}
-                            // We could potentially try to apply this property directly to the GameObject here if needed,
-                            // but the primary goal is component modification.
-                            Debug.LogWarning(
-                                $"[ManageAsset.ModifyAsset] Property '{prop.Name}' for GameObject modification should have a JSON object value containing component properties. Value was: {prop.Value.Type}. Skipping."
-                            );
-                        }
-                    }
-                    // Note: 'modified' is now true if ANY component property was successfully changed.
-                }
-                // --- End NEW ---
-
-                // --- Existing logic for other asset types (now as else-if) ---
-                // Example: Modifying a Material
-                else if (asset is Material material)
-                {
-                    // Apply properties directly to the material. If this modifies, it sets modified=true.
-                    // Use |= in case the asset was already marked modified by previous logic (though unlikely here)
-                    modified |= ApplyMaterialProperties(material, properties);
-                }
-                // Example: Modifying a ScriptableObject
-                else if (asset is ScriptableObject so)
-                {
-                    // Apply properties directly to the ScriptableObject.
-                    modified |= ApplyObjectProperties(so, properties); // General helper
-                }
-                // Example: Modifying TextureImporter settings
-                else if (asset is Texture)
-                {
-                    var importer = AssetImporter.GetAtPath(fullPath);
-                    if (importer is TextureImporter textureImporter)
-                    {
-                        var importerModified = ApplyObjectProperties(textureImporter, properties);
-                        if (importerModified)
-                        {
-                            // Importer settings need saving and reimporting
-                            AssetDatabase.WriteImportSettingsIfDirty(fullPath);
-                            AssetDatabase.ImportAsset(fullPath, ImportAssetOptions.ForceUpdate); // Reimport to apply changes
-                            modified = true; // Mark overall operation as modified
-                        }
-                    }
-                    else
-                    {
-                        Debug.LogWarning($"Could not get TextureImporter for {fullPath}.");
-                    }
-                }
-                // TODO: Add modification logic for other common asset types (Models, AudioClips importers, etc.)
-                else // Fallback for other asset types OR direct properties on non-GameObject assets
-                {
-                    // This block handles non-GameObject/Material/ScriptableObject/Texture assets.
-                    // Attempts to apply properties directly to the asset itself.
-                    Debug.LogWarning(
-                        $"[ManageAsset.ModifyAsset] Asset type '{asset.GetType().Name}' at '{fullPath}' is not explicitly handled for component modification. Attempting generic property setting on the asset itself."
-                    );
-                    modified |= ApplyObjectProperties(asset, properties);
-                }
-                // --- End Existing Logic ---
-
-                // Check if any modification happened (either component or direct asset modification)
-                if (modified)
-                {
-                    // Mark the asset as dirty (important for prefabs/SOs) so Unity knows to save it.
-                    EditorUtility.SetDirty(asset);
-                    // Save all modified assets to disk.
-                    AssetDatabase.SaveAssets();
-                    // Refresh might be needed in some edge cases, but SaveAssets usually covers it.
-                    // AssetDatabase.Refresh();
-                    return Response.Success(
-                        $"Asset '{fullPath}' modified successfully.",
-                        GetAssetData(fullPath)
-                    );
-                }
-                else
-                {
-                    // If no changes were made (e.g., component not found, property names incorrect, value unchanged), return a success message indicating nothing changed.
-                    return Response.Success(
-                        $"No applicable or modifiable properties found for asset '{fullPath}'. Check component names, property names, and values.",
-                        GetAssetData(fullPath)
-                    );
-                    // Previous message: return Response.Success($"No applicable properties found to modify for asset '{fullPath}'.", GetAssetData(fullPath));
-                }
-            }
-            catch (Exception e)
-            {
-                // Log the detailed error internally
-                Debug.LogError($"[ManageAsset] Action 'modify' failed for path '{path}': {e}");
-                // Return a user-friendly error message
-                return Response.Error($"Failed to modify asset '{fullPath}': {e.Message}");
-            }
-        }
-
-        private static object DeleteAsset(string path)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for delete.");
-            var fullPath = SanitizeAssetPath(path);
-            if (!AssetExists(fullPath))
-                return Response.Error($"Asset not found at path: {fullPath}");
-
-            try
-            {
-                var success = AssetDatabase.DeleteAsset(fullPath);
-                if (success)
-                {
-                    // AssetDatabase.Refresh(); // DeleteAsset usually handles refresh
-                    return Response.Success($"Asset '{fullPath}' deleted successfully.");
-                }
-                else
-                {
-                    // This might happen if the file couldn't be deleted (e.g., locked)
-                    return Response.Error(
-                        $"Failed to delete asset '{fullPath}'. Check logs or if the file is locked."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error deleting asset '{fullPath}': {e.Message}");
-            }
-        }
-
-        private static object DuplicateAsset(string path, string destinationPath)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for duplicate.");
-
-            var sourcePath = SanitizeAssetPath(path);
-            if (!AssetExists(sourcePath))
-                return Response.Error($"Source asset not found at path: {sourcePath}");
-
-            string destPath;
-            if (string.IsNullOrEmpty(destinationPath))
-            {
-                // Generate a unique path if destination is not provided
-                destPath = AssetDatabase.GenerateUniqueAssetPath(sourcePath);
-            }
-            else
-            {
-                destPath = SanitizeAssetPath(destinationPath);
-                if (AssetExists(destPath))
-                    return Response.Error($"Asset already exists at destination path: {destPath}");
-                // Ensure destination directory exists
-                EnsureDirectoryExists(Path.GetDirectoryName(destPath));
-            }
-
-            try
-            {
-                var success = AssetDatabase.CopyAsset(sourcePath, destPath);
-                if (success)
-                {
-                    // AssetDatabase.Refresh();
-                    return Response.Success(
-                        $"Asset '{sourcePath}' duplicated to '{destPath}'.",
-                        GetAssetData(destPath)
-                    );
-                }
-                else
-                {
-                    return Response.Error(
-                        $"Failed to duplicate asset from '{sourcePath}' to '{destPath}'."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error duplicating asset '{sourcePath}': {e.Message}");
-            }
-        }
-
-        private static object MoveOrRenameAsset(string path, string destinationPath)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for move/rename.");
-            if (string.IsNullOrEmpty(destinationPath))
-                return Response.Error("'destination' path is required for move/rename.");
-
-            var sourcePath = SanitizeAssetPath(path);
-            var destPath = SanitizeAssetPath(destinationPath);
-
-            if (!AssetExists(sourcePath))
-                return Response.Error($"Source asset not found at path: {sourcePath}");
-            if (AssetExists(destPath))
-                return Response.Error(
-                    $"An asset already exists at the destination path: {destPath}"
-                );
-
-            // Ensure destination directory exists
-            EnsureDirectoryExists(Path.GetDirectoryName(destPath));
-
-            try
-            {
-                // Validate will return an error string if failed, null if successful
-                var error = AssetDatabase.ValidateMoveAsset(sourcePath, destPath);
-                if (!string.IsNullOrEmpty(error))
-                {
-                    return Response.Error(
-                        $"Failed to move/rename asset from '{sourcePath}' to '{destPath}': {error}"
-                    );
-                }
-
-                var guid = AssetDatabase.MoveAsset(sourcePath, destPath);
-                if (!string.IsNullOrEmpty(guid)) // MoveAsset returns the new GUID on success
-                {
-                    // AssetDatabase.Refresh(); // MoveAsset usually handles refresh
-                    return Response.Success(
-                        $"Asset moved/renamed from '{sourcePath}' to '{destPath}'.",
-                        GetAssetData(destPath)
-                    );
-                }
-                else
-                {
-                    // This case might not be reachable if ValidateMoveAsset passes, but good to have
-                    return Response.Error(
-                        $"MoveAsset call failed unexpectedly for '{sourcePath}' to '{destPath}'."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error moving/renaming asset '{sourcePath}': {e.Message}");
-            }
-        }
-
-        private static object SearchAssets(JObject @params)
-        {
-            var searchPattern = @params["searchPattern"]?.ToString();
-            var filterType = @params["filterType"]?.ToString();
-            var pathScope = @params["path"]?.ToString(); // Use path as folder scope
-            var filterDateAfterStr = @params["filterDateAfter"]?.ToString();
-            var pageSize = @params["pageSize"]?.ToObject<int?>() ?? 50; // Default page size
-            var pageNumber = @params["pageNumber"]?.ToObject<int?>() ?? 1; // Default page number (1-based)
-            var generatePreview = @params["generatePreview"]?.ToObject<bool>() ?? false;
-
-            var searchFilters = new List<string>();
-            if (!string.IsNullOrEmpty(searchPattern))
-                searchFilters.Add(searchPattern);
-            if (!string.IsNullOrEmpty(filterType))
-                searchFilters.Add($"t:{filterType}");
-
-            string[] folderScope = null;
-            if (!string.IsNullOrEmpty(pathScope))
-            {
-                folderScope = new string[] { SanitizeAssetPath(pathScope) };
-                if (!AssetDatabase.IsValidFolder(folderScope[0]))
-                {
-                    // Maybe the user provided a file path instead of a folder?
-                    // We could search in the containing folder, or return an error.
-                    Debug.LogWarning(
-                        $"Search path '{folderScope[0]}' is not a valid folder. Searching entire project."
-                    );
-                    folderScope = null; // Search everywhere if path isn't a folder
-                }
-            }
-
-            DateTime? filterDateAfter = null;
-            if (!string.IsNullOrEmpty(filterDateAfterStr))
-            {
-                if (
-                    DateTime.TryParse(
-                        filterDateAfterStr,
-                        CultureInfo.InvariantCulture,
-                        DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal,
-                        out var parsedDate
-                    )
-                )
-                {
-                    filterDateAfter = parsedDate;
-                }
-                else
-                {
-                    Debug.LogWarning(
-                        $"Could not parse filterDateAfter: '{filterDateAfterStr}'. Expected ISO 8601 format."
-                    );
-                }
-            }
-
-            try
-            {
-                var guids = AssetDatabase.FindAssets(
-                    string.Join(" ", searchFilters),
-                    folderScope
-                );
-                var results = new List<object>();
-                var totalFound = 0;
-
-                foreach (var guid in guids)
-                {
-                    var assetPath = AssetDatabase.GUIDToAssetPath(guid);
-                    if (string.IsNullOrEmpty(assetPath))
-                        continue;
-
-                    // Apply date filter if present
-                    if (filterDateAfter.HasValue)
-                    {
-                        var lastWriteTime = File.GetLastWriteTimeUtc(
-                            Path.Combine(Directory.GetCurrentDirectory(), assetPath)
-                        );
-                        if (lastWriteTime <= filterDateAfter.Value)
-                        {
-                            continue; // Skip assets older than or equal to the filter date
-                        }
-                    }
-
-                    totalFound++; // Count matching assets before pagination
-                    results.Add(GetAssetData(assetPath, generatePreview));
-                }
-
-                // Apply pagination
-                var startIndex = (pageNumber - 1) * pageSize;
-                var pagedResults = results.Skip(startIndex).Take(pageSize).ToList();
-
-                return Response.Success(
-                    $"Found {totalFound} asset(s). Returning page {pageNumber} ({pagedResults.Count} assets).",
-                    new
-                    {
-                        totalAssets = totalFound,
-                        pageSize,
-                        pageNumber,
-                        assets = pagedResults,
-                    }
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error searching assets: {e.Message}");
-            }
-        }
-
-        private static object GetAssetInfo(string path, bool generatePreview)
-        {
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for get_info.");
-            var fullPath = SanitizeAssetPath(path);
-            if (!AssetExists(fullPath))
-                return Response.Error($"Asset not found at path: {fullPath}");
-
-            try
-            {
-                return Response.Success(
-                    "Asset info retrieved.",
-                    GetAssetData(fullPath, generatePreview)
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting info for asset '{fullPath}': {e.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Retrieves components attached to a GameObject asset (like a Prefab).
-        /// </summary>
-        /// <param name="path">The asset path of the GameObject or Prefab.</param>
-        /// <returns>A response object containing a list of component type names or an error.</returns>
-        private static object GetComponentsFromAsset(string path)
-        {
-            // 1. Validate input path
-            if (string.IsNullOrEmpty(path))
-                return Response.Error("'path' is required for get_components.");
-
-            // 2. Sanitize and check existence
-            var fullPath = SanitizeAssetPath(path);
-            if (!AssetExists(fullPath))
-                return Response.Error($"Asset not found at path: {fullPath}");
-
-            try
-            {
-                // 3. Load the asset
-                var asset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(
-                    fullPath
-                );
-                if (asset == null)
-                    return Response.Error($"Failed to load asset at path: {fullPath}");
-
-                // 4. Check if it's a GameObject (Prefabs load as GameObjects)
-                var gameObject = asset as GameObject;
-                if (gameObject == null)
-                {
-                    // Also check if it's *directly* a Component type (less common for primary assets)
-                    var componentAsset = asset as Component;
-                    if (componentAsset != null)
-                    {
-                        // If the asset itself *is* a component, maybe return just its info?
-                        // This is an edge case. Let's stick to GameObjects for now.
-                        return Response.Error(
-                            $"Asset at '{fullPath}' is a Component ({asset.GetType().FullName}), not a GameObject. Components are typically retrieved *from* a GameObject."
-                        );
-                    }
-                    return Response.Error(
-                        $"Asset at '{fullPath}' is not a GameObject (Type: {asset.GetType().FullName}). Cannot get components from this asset type."
-                    );
-                }
-
-                // 5. Get components
-                var components = gameObject.GetComponents<Component>();
-
-                // 6. Format component data
-                var componentList = components
-                    .Select(comp => new
-                    {
-                        typeName = comp.GetType().FullName,
-                        instanceID = comp.GetInstanceID(),
-                        // TODO: Add more component-specific details here if needed in the future?
-                        //       Requires reflection or specific handling per component type.
-                    })
-                    .ToList<object>(); // Explicit cast for clarity if needed
-
-                // 7. Return success response
-                return Response.Success(
-                    $"Found {componentList.Count} component(s) on asset '{fullPath}'.",
-                    componentList
-                );
-            }
-            catch (Exception e)
-            {
-                Debug.LogError(
-                    $"[ManageAsset.GetComponentsFromAsset] Error getting components for '{fullPath}': {e}"
-                );
-                return Response.Error(
-                    $"Error getting components for asset '{fullPath}': {e.Message}"
-                );
-            }
-        }
-
-        // --- Internal Helpers ---
-
-        /// <summary>
-        /// Ensures the asset path starts with "Assets/".
-        /// </summary>
-        private static string SanitizeAssetPath(string path)
-        {
-            if (string.IsNullOrEmpty(path))
-                return path;
-            path = path.Replace('\\', '/'); // Normalize separators
-            if (!path.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase))
-            {
-                return "Assets/" + path.TrimStart('/');
-            }
-            return path;
-        }
-
-        /// <summary>
-        /// Checks if an asset exists at the given path (file or folder).
-        /// </summary>
-        private static bool AssetExists(string sanitizedPath)
-        {
-            // AssetDatabase APIs are generally preferred over raw File/Directory checks for assets.
-            // Check if it's a known asset GUID.
-            if (!string.IsNullOrEmpty(AssetDatabase.AssetPathToGUID(sanitizedPath)))
-            {
-                return true;
-            }
-            // AssetPathToGUID might not work for newly created folders not yet refreshed.
-            // Check directory explicitly for folders.
-            if (Directory.Exists(Path.Combine(Directory.GetCurrentDirectory(), sanitizedPath)))
-            {
-                // Check if it's considered a *valid* folder by Unity
-                return AssetDatabase.IsValidFolder(sanitizedPath);
-            }
-            // Check file existence for non-folder assets.
-            if (File.Exists(Path.Combine(Directory.GetCurrentDirectory(), sanitizedPath)))
-            {
-                return true; // Assume if file exists, it's an asset or will be imported
-            }
-
-            return false;
-            // Alternative: return !string.IsNullOrEmpty(AssetDatabase.AssetPathToGUID(sanitizedPath));
-        }
-
-        /// <summary>
-        /// Ensures the directory for a given asset path exists, creating it if necessary.
-        /// </summary>
-        private static void EnsureDirectoryExists(string directoryPath)
-        {
-            if (string.IsNullOrEmpty(directoryPath))
-                return;
-            var fullDirPath = Path.Combine(Directory.GetCurrentDirectory(), directoryPath);
-            if (!Directory.Exists(fullDirPath))
-            {
-                Directory.CreateDirectory(fullDirPath);
-                AssetDatabase.Refresh(); // Let Unity know about the new folder
-            }
-        }
-
-        /// <summary>
-        /// Applies properties from JObject to a Material.
-        /// </summary>
-        private static bool ApplyMaterialProperties(Material mat, JObject properties)
-        {
-            if (mat == null || properties == null)
-                return false;
-            var modified = false;
-
-            // Example: Set shader
-            if (properties["shader"]?.Type == JTokenType.String)
-            {
-                var newShader = Shader.Find(properties["shader"].ToString());
-                if (newShader != null && mat.shader != newShader)
-                {
-                    mat.shader = newShader;
-                    modified = true;
-                }
-            }
-            // Example: Set color property
-            if (properties["color"] is JObject colorProps)
-            {
-                var propName = colorProps["name"]?.ToString() ?? "_Color"; // Default main color
-                if (colorProps["value"] is JArray colArr && colArr.Count >= 3)
-                {
-                    try
-                    {
-                        var newColor = new Color(
-                            colArr[0].ToObject<float>(),
-                            colArr[1].ToObject<float>(),
-                            colArr[2].ToObject<float>(),
-                            colArr.Count > 3 ? colArr[3].ToObject<float>() : 1.0f
-                        );
-                        if (mat.HasProperty(propName) && mat.GetColor(propName) != newColor)
-                        {
-                            mat.SetColor(propName, newColor);
-                            modified = true;
-                        }
-                    }
-                    catch (Exception ex)
-                    {
-                        Debug.LogWarning(
-                            $"Error parsing color property '{propName}': {ex.Message}"
-                        );
-                    }
-                }
-            } else if (properties["color"] is JArray colorArr) //Use color now with examples set in manage_asset.py
-            {
-                var propName =  "_Color";
-                try {
-                    if (colorArr.Count >= 3)
-                    {
-                        var newColor = new Color(
-                            colorArr[0].ToObject<float>(),
-                            colorArr[1].ToObject<float>(),
-                            colorArr[2].ToObject<float>(),
-                            colorArr.Count > 3 ? colorArr[3].ToObject<float>() : 1.0f
-                        );
-                        if (mat.HasProperty(propName) && mat.GetColor(propName) != newColor)
-                        {
-                            mat.SetColor(propName, newColor);
-                            modified = true;
-                        }
-                    }
-                }
-                catch (Exception ex) {
-                    Debug.LogWarning(
-                        $"Error parsing color property '{propName}': {ex.Message}"
-                    );
-                }
-            }
-            // Example: Set float property
-            if (properties["float"] is JObject floatProps)
-            {
-                var propName = floatProps["name"]?.ToString();
-                if (
-                    !string.IsNullOrEmpty(propName) &&
-                    (floatProps["value"]?.Type == JTokenType.Float || floatProps["value"]?.Type == JTokenType.Integer)
-                )
-                {
-                    try
-                    {
-                        var newVal = floatProps["value"].ToObject<float>();
-                        if (mat.HasProperty(propName) && mat.GetFloat(propName) != newVal)
-                        {
-                            mat.SetFloat(propName, newVal);
-                            modified = true;
-                        }
-                    }
-                    catch (Exception ex)
-                    {
-                        Debug.LogWarning(
-                            $"Error parsing float property '{propName}': {ex.Message}"
-                        );
-                    }
-                }
-            }
-            // Example: Set texture property
-            if (properties["texture"] is JObject texProps)
-            {
-                var propName = texProps["name"]?.ToString() ?? "_MainTex"; // Default main texture
-                var texPath = texProps["path"]?.ToString();
-                if (!string.IsNullOrEmpty(texPath))
-                {
-                    var newTex = AssetDatabase.LoadAssetAtPath<Texture>(
-                        SanitizeAssetPath(texPath)
-                    );
-                    if (
-                        newTex != null
-                        && mat.HasProperty(propName)
-                        && mat.GetTexture(propName) != newTex
-                    )
-                    {
-                        mat.SetTexture(propName, newTex);
-                        modified = true;
-                    }
-                    else if (newTex == null)
-                    {
-                        Debug.LogWarning($"Texture not found at path: {texPath}");
-                    }
-                }
-            }
-
-            // TODO: Add handlers for other property types (Vectors, Ints, Keywords, RenderQueue, etc.)
-            return modified;
-        }
-
-        /// <summary>
-        ///  Applies properties from JObject to a PhysicsMaterial.
-        /// </summary>
-        private static bool ApplyPhysicsMaterialProperties(PhysicsMaterialType pmat, JObject properties)
-        {
-            if (pmat == null || properties == null)
-                return false;
-            var modified = false;
-
-            // Example: Set dynamic friction
-            if (properties["dynamicFriction"]?.Type == JTokenType.Float)
-            {
-                var dynamicFriction = properties["dynamicFriction"].ToObject<float>();
-                pmat.dynamicFriction = dynamicFriction;
-                modified = true;
-            }
-
-            // Example: Set static friction
-            if (properties["staticFriction"]?.Type == JTokenType.Float)
-            {
-                var staticFriction = properties["staticFriction"].ToObject<float>();
-                pmat.staticFriction = staticFriction;
-                modified = true;
-            }
-
-            // Example: Set bounciness
-            if (properties["bounciness"]?.Type == JTokenType.Float)
-            {
-                var bounciness = properties["bounciness"].ToObject<float>();
-                pmat.bounciness = bounciness;
-                modified = true;
-            }
-
-            var averageList = new List<String> { "ave", "Ave", "average", "Average" };
-            var multiplyList = new List<String> { "mul", "Mul", "mult", "Mult", "multiply", "Multiply" };
-            var minimumList = new List<String> { "min", "Min", "minimum", "Minimum" };
-            var maximumList = new List<String> { "max", "Max", "maximum", "Maximum" };
-
-            // Example: Set friction combine
-            if (properties["frictionCombine"]?.Type == JTokenType.String)
-            {
-                var frictionCombine = properties["frictionCombine"].ToString();
-                if (averageList.Contains(frictionCombine))
-                    pmat.frictionCombine = PhysicsMaterialCombine.Average;
-                else if (multiplyList.Contains(frictionCombine))
-                    pmat.frictionCombine = PhysicsMaterialCombine.Multiply;
-                else if (minimumList.Contains(frictionCombine))
-                    pmat.frictionCombine = PhysicsMaterialCombine.Minimum;
-                else if (maximumList.Contains(frictionCombine))
-                    pmat.frictionCombine = PhysicsMaterialCombine.Maximum;
-                modified = true;
-            }
-
-            // Example: Set bounce combine
-            if (properties["bounceCombine"]?.Type == JTokenType.String)
-            {
-                var bounceCombine = properties["bounceCombine"].ToString();
-                if (averageList.Contains(bounceCombine))
-                    pmat.bounceCombine = PhysicsMaterialCombine.Average;
-                else if (multiplyList.Contains(bounceCombine))
-                    pmat.bounceCombine = PhysicsMaterialCombine.Multiply;
-                else if (minimumList.Contains(bounceCombine))
-                    pmat.bounceCombine = PhysicsMaterialCombine.Minimum;
-                else if (maximumList.Contains(bounceCombine))
-                    pmat.bounceCombine = PhysicsMaterialCombine.Maximum;
-                modified = true;
-            }
-
-            return modified;
-        }
-
-        /// <summary>
-        /// Generic helper to set properties on any UnityEngine.Object using reflection.
-        /// </summary>
-        private static bool ApplyObjectProperties(UnityEngine.Object target, JObject properties)
-        {
-            if (target == null || properties == null)
-                return false;
-            var modified = false;
-            var type = target.GetType();
-
-            foreach (var prop in properties.Properties())
-            {
-                var propName = prop.Name;
-                var propValue = prop.Value;
-                if (SetPropertyOrField(target, propName, propValue, type))
-                {
-                    modified = true;
-                }
-            }
-            return modified;
-        }
-
-        /// <summary>
-        /// Helper to set a property or field via reflection, handling basic types and Unity objects.
-        /// </summary>
-        private static bool SetPropertyOrField(
-            object target,
-            string memberName,
-            JToken value,
-            Type type = null
-        )
-        {
-            type = type ?? target.GetType();
-            var flags =
-                System.Reflection.BindingFlags.Public
-                | System.Reflection.BindingFlags.Instance
-                | System.Reflection.BindingFlags.IgnoreCase;
-
-            try
-            {
-                var propInfo = type.GetProperty(memberName, flags);
-                if (propInfo != null && propInfo.CanWrite)
-                {
-                    var convertedValue = ConvertJTokenToType(value, propInfo.PropertyType);
-                    if (
-                        convertedValue != null
-                        && !object.Equals(propInfo.GetValue(target), convertedValue)
-                    )
-                    {
-                        propInfo.SetValue(target, convertedValue);
-                        return true;
-                    }
-                }
-                else
-                {
-                    var fieldInfo = type.GetField(memberName, flags);
-                    if (fieldInfo != null)
-                    {
-                        var convertedValue = ConvertJTokenToType(value, fieldInfo.FieldType);
-                        if (
-                            convertedValue != null
-                            && !object.Equals(fieldInfo.GetValue(target), convertedValue)
-                        )
-                        {
-                            fieldInfo.SetValue(target, convertedValue);
-                            return true;
-                        }
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning(
-                    $"[SetPropertyOrField] Failed to set '{memberName}' on {type.Name}: {ex.Message}"
-                );
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Simple JToken to Type conversion for common Unity types and primitives.
-        /// </summary>
-        private static object ConvertJTokenToType(JToken token, Type targetType)
-        {
-            try
-            {
-                if (token == null || token.Type == JTokenType.Null)
-                    return null;
-
-                if (targetType == typeof(string))
-                    return token.ToObject<string>();
-                if (targetType == typeof(int))
-                    return token.ToObject<int>();
-                if (targetType == typeof(float))
-                    return token.ToObject<float>();
-                if (targetType == typeof(bool))
-                    return token.ToObject<bool>();
-                if (targetType == typeof(Vector2) && token is JArray arrV2 && arrV2.Count == 2)
-                    return new Vector2(arrV2[0].ToObject<float>(), arrV2[1].ToObject<float>());
-                if (targetType == typeof(Vector3) && token is JArray arrV3 && arrV3.Count == 3)
-                    return new Vector3(
-                        arrV3[0].ToObject<float>(),
-                        arrV3[1].ToObject<float>(),
-                        arrV3[2].ToObject<float>()
-                    );
-                if (targetType == typeof(Vector4) && token is JArray arrV4 && arrV4.Count == 4)
-                    return new Vector4(
-                        arrV4[0].ToObject<float>(),
-                        arrV4[1].ToObject<float>(),
-                        arrV4[2].ToObject<float>(),
-                        arrV4[3].ToObject<float>()
-                    );
-                if (targetType == typeof(Quaternion) && token is JArray arrQ && arrQ.Count == 4)
-                    return new Quaternion(
-                        arrQ[0].ToObject<float>(),
-                        arrQ[1].ToObject<float>(),
-                        arrQ[2].ToObject<float>(),
-                        arrQ[3].ToObject<float>()
-                    );
-                if (targetType == typeof(Color) && token is JArray arrC && arrC.Count >= 3) // Allow RGB or RGBA
-                    return new Color(
-                        arrC[0].ToObject<float>(),
-                        arrC[1].ToObject<float>(),
-                        arrC[2].ToObject<float>(),
-                        arrC.Count > 3 ? arrC[3].ToObject<float>() : 1.0f
-                    );
-                if (targetType.IsEnum)
-                    return Enum.Parse(targetType, token.ToString(), true); // Case-insensitive enum parsing
-
-                // Handle loading Unity Objects (Materials, Textures, etc.) by path
-                if (
-                    typeof(UnityEngine.Object).IsAssignableFrom(targetType)
-                    && token.Type == JTokenType.String
-                )
-                {
-                    var assetPath = SanitizeAssetPath(token.ToString());
-                    var loadedAsset = AssetDatabase.LoadAssetAtPath(
-                        assetPath,
-                        targetType
-                    );
-                    if (loadedAsset == null)
-                    {
-                        Debug.LogWarning(
-                            $"[ConvertJTokenToType] Could not load asset of type {targetType.Name} from path: {assetPath}"
-                        );
-                    }
-                    return loadedAsset;
-                }
-
-                // Fallback: Try direct conversion (might work for other simple value types)
-                return token.ToObject(targetType);
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning(
-                    $"[ConvertJTokenToType] Could not convert JToken '{token}' (type {token.Type}) to type '{targetType.Name}': {ex.Message}"
-                );
-                return null;
-            }
-        }
-
-
-        // --- Data Serialization ---
-
-        /// <summary>
-        /// Creates a serializable representation of an asset.
-        /// </summary>
-        private static object GetAssetData(string path, bool generatePreview = false)
-        {
-            if (string.IsNullOrEmpty(path) || !AssetExists(path))
-                return null;
-
-            var guid = AssetDatabase.AssetPathToGUID(path);
-            var assetType = AssetDatabase.GetMainAssetTypeAtPath(path);
-            var asset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(path);
-            string previewBase64 = null;
-            var previewWidth = 0;
-            var previewHeight = 0;
-
-            if (generatePreview && asset != null)
-            {
-                var preview = AssetPreview.GetAssetPreview(asset);
-
-                if (preview != null)
-                {
-                    try
-                    {
-                        // Ensure texture is readable for EncodeToPNG
-                        // Creating a temporary readable copy is safer
-                        RenderTexture rt = null;
-                        Texture2D readablePreview = null;
-                        var previous = RenderTexture.active;
-                        try
-                        {
-                            rt = RenderTexture.GetTemporary(preview.width, preview.height);
-                            Graphics.Blit(preview, rt);
-                            RenderTexture.active = rt;
-                            readablePreview = new Texture2D(preview.width, preview.height, TextureFormat.RGB24, false);
-                            readablePreview.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
-                            readablePreview.Apply();
-
-                            var pngData = readablePreview.EncodeToPNG();
-                            if (pngData != null && pngData.Length > 0)
-                            {
-                                previewBase64 = Convert.ToBase64String(pngData);
-                                previewWidth = readablePreview.width;
-                                previewHeight = readablePreview.height;
-                            }
-                        }
-                        finally
-                        {
-                            RenderTexture.active = previous;
-                            if (rt != null) RenderTexture.ReleaseTemporary(rt);
-                            if (readablePreview != null) UnityEngine.Object.DestroyImmediate(readablePreview);
-                        }
-                    }
-                    catch (Exception ex)
-                    {
-                        Debug.LogWarning(
-                            $"Failed to generate readable preview for '{path}': {ex.Message}. Preview might not be readable."
-                        );
-                        // Fallback: Try getting static preview if available?
-                        // Texture2D staticPreview = AssetPreview.GetMiniThumbnail(asset);
-                    }
-                }
-                else
-                {
-                    Debug.LogWarning(
-                        $"Could not get asset preview for {path} (Type: {assetType?.Name}). Is it supported?"
-                    );
-                }
-            }
-
-            return new
-            {
-                path,
-                guid,
-                assetType = assetType?.FullName ?? "Unknown",
-                name = Path.GetFileNameWithoutExtension(path),
-                fileName = Path.GetFileName(path),
-                isFolder = AssetDatabase.IsValidFolder(path),
-                instanceID = asset?.GetInstanceID() ?? 0,
-                lastWriteTimeUtc = File.GetLastWriteTimeUtc(
-                        Path.Combine(Directory.GetCurrentDirectory(), path)
-                    )
-                    .ToString("o"), // ISO 8601
-                // --- Preview Data ---
-                previewBase64, // PNG data as Base64 string
-                previewWidth,
-                previewHeight,
-                // TODO: Add more metadata? Importer settings? Dependencies?
-            };
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs.meta b/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 36798bd7b867b8e43ac86885e94f928f
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2668 +0,0 @@
-using System;
-using System.IO;
-using System.Linq;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers;
-using System.Threading;
-using System.Security.Cryptography;
-
-#if USE_ROSLYN
-using Microsoft.CodeAnalysis;
-using Microsoft.CodeAnalysis.CSharp;
-using Microsoft.CodeAnalysis.Formatting;
-#endif
-
-#if UNITY_EDITOR
-#endif
-
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles CRUD operations for C# scripts within the Unity project.
-    /// 
-    /// ROSLYN INSTALLATION GUIDE:
-    /// To enable advanced syntax validation with Roslyn compiler services:
-    /// 
-    /// 1. Install Microsoft.CodeAnalysis.CSharp NuGet package:
-    ///    - Open Package Manager in Unity
-    ///    - Follow the instruction on https://github.com/GlitchEnzo/NuGetForUnity
-    ///    
-    /// 2. Open NuGet Package Manager and Install Microsoft.CodeAnalysis.CSharp:
-    ///    
-    /// 3. Alternative: Manual DLL installation:
-    ///    - Download Microsoft.CodeAnalysis.CSharp.dll and dependencies
-    ///    - Place in Assets/Plugins/ folder
-    ///    - Ensure .NET compatibility settings are correct
-    ///    
-    /// 4. Define USE_ROSLYN symbol:
-    ///    - Go to Player Settings > Scripting Define Symbols
-    ///    - Add "USE_ROSLYN" to enable Roslyn-based validation
-    ///    
-    /// 5. Restart Unity after installation
-    /// 
-    /// Note: Without Roslyn, the system falls back to basic structural validation.
-    /// Roslyn provides full C# compiler diagnostics with line numbers and detailed error messages.
-    /// </summary>
-    public static class ManageScript
-    {
-        /// <summary>
-        /// Resolves a directory under Assets/, preventing traversal and escaping.
-        /// Returns fullPathDir on disk and canonical 'Assets/...' relative path.
-        /// </summary>
-        private static bool TryResolveUnderAssets(string relDir, out string fullPathDir, out string relPathSafe)
-        {
-            var assets = Application.dataPath.Replace('\\', '/');
-
-            // Normalize caller path: allow both "Scripts/..." and "Assets/Scripts/..."
-            var rel = (relDir ?? "Scripts").Replace('\\', '/').Trim();
-            if (string.IsNullOrEmpty(rel)) rel = "Scripts";
-            if (rel.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase)) rel = rel.Substring(7);
-            rel = rel.TrimStart('/');
-
-            var targetDir = Path.Combine(assets, rel).Replace('\\', '/');
-            var full = Path.GetFullPath(targetDir).Replace('\\', '/');
-
-            var underAssets = full.StartsWith(assets + "/", StringComparison.OrdinalIgnoreCase)
-                               || string.Equals(full, assets, StringComparison.OrdinalIgnoreCase);
-            if (!underAssets)
-            {
-                fullPathDir = null;
-                relPathSafe = null;
-                return false;
-            }
-
-            // Best-effort symlink guard: if the directory OR ANY ANCESTOR (up to Assets/) is a reparse point/symlink, reject
-            try
-            {
-                var di = new DirectoryInfo(full);
-                while (di != null)
-                {
-                    if (di.Exists && (di.Attributes & FileAttributes.ReparsePoint) != 0)
-                    {
-                        fullPathDir = null;
-                        relPathSafe = null;
-                        return false;
-                    }
-                    var atAssets = string.Equals(
-                        di.FullName.Replace('\\','/'),
-                        assets,
-                        StringComparison.OrdinalIgnoreCase
-                    );
-                    if (atAssets) break;
-                    di = di.Parent;
-                }
-            }
-            catch { /* best effort; proceed */ }
-
-            fullPathDir = full;
-            var tail = full.Length > assets.Length ? full.Substring(assets.Length).TrimStart('/') : string.Empty;
-            relPathSafe = ("Assets/" + tail).TrimEnd('/');
-            return true;
-        }
-        /// <summary>
-        /// Main handler for script management actions.
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            // Handle null parameters
-            if (@params == null)
-            {
-                return Response.Error("invalid_params", "Parameters cannot be null.");
-            }
-
-            // Extract parameters
-            var action = @params["action"]?.ToString()?.ToLower();
-            var name = @params["name"]?.ToString();
-            var path = @params["path"]?.ToString(); // Relative to Assets/
-            string contents = null;
-
-            // Check if we have base64 encoded contents
-            var contentsEncoded = @params["contentsEncoded"]?.ToObject<bool>() ?? false;
-            if (contentsEncoded && @params["encodedContents"] != null)
-            {
-                try
-                {
-                    contents = DecodeBase64(@params["encodedContents"].ToString());
-                }
-                catch (Exception e)
-                {
-                    return Response.Error($"Failed to decode script contents: {e.Message}");
-                }
-            }
-            else
-            {
-                contents = @params["contents"]?.ToString();
-            }
-
-            var scriptType = @params["scriptType"]?.ToString(); // For templates/validation
-            var namespaceName = @params["namespace"]?.ToString(); // For organizing code
-
-            // Validate required parameters
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-            if (string.IsNullOrEmpty(name))
-            {
-                return Response.Error("Name parameter is required.");
-            }
-            // Basic name validation (alphanumeric, underscores, cannot start with number)
-            if (!Regex.IsMatch(name, @"^[a-zA-Z_][a-zA-Z0-9_]*$", RegexOptions.CultureInvariant, TimeSpan.FromSeconds(2)))
-            {
-                return Response.Error(
-                    $"Invalid script name: '{name}'. Use only letters, numbers, underscores, and don't start with a number."
-                );
-            }
-
-            // Resolve and harden target directory under Assets/
-            if (!TryResolveUnderAssets(path, out var fullPathDir, out var relPathSafeDir))
-            {
-                return Response.EnhancedError(
-                    $"Invalid path. Target directory must be within 'Assets/'. Provided: '{(path ?? "(null)")}'",
-                    $"Script creation attempted outside Assets folder",
-                    "Use a path starting with 'Assets/' (e.g., 'Assets/Scripts/MyScript.cs')",
-                    new[] { "Assets/Scripts/", "Assets/", "Assets/Scripts/Player/" },
-                    "INVALID_PATH",
-                    path
-                );
-            }
-
-            // Construct file paths
-            var scriptFileName = $"{name}.cs";
-            var fullPath = Path.Combine(fullPathDir, scriptFileName);
-            var relativePath = Path.Combine(relPathSafeDir, scriptFileName).Replace('\\', '/');
-
-            // Ensure the target directory exists for create/update
-            if (action == "create" || action == "update")
-            {
-                try
-                {
-                    Directory.CreateDirectory(fullPathDir);
-                }
-                catch (Exception e)
-                {
-                    return Response.Error(
-                        $"Could not create directory '{fullPathDir}': {e.Message}"
-                    );
-                }
-            }
-
-            // Route to specific action handlers
-            switch (action)
-            {
-                case "create":
-                    return CreateScript(
-                        fullPath,
-                        relativePath,
-                        name,
-                        contents,
-                        scriptType,
-                        namespaceName
-                    );
-                case "read":
-                    McpLog.Warn("manage_script.read is deprecated; prefer resources/read. Serving read for backward compatibility.");
-                    return ReadScript(fullPath, relativePath);
-                case "update":
-                    McpLog.Warn("manage_script.update is deprecated; prefer apply_text_edits. Serving update for backward compatibility.");
-                    return UpdateScript(fullPath, relativePath, name, contents);
-                case "delete":
-                    return DeleteScript(fullPath, relativePath);
-                case "apply_text_edits":
-                {
-                    var textEdits = @params["edits"] as JArray;
-                    var precondition = @params["precondition_sha256"]?.ToString();
-                    // Respect optional options
-                    var refreshOpt = @params["options"]?["refresh"]?.ToString()?.ToLowerInvariant();
-                    var validateOpt = @params["options"]?["validate"]?.ToString()?.ToLowerInvariant();
-                    return ApplyTextEdits(fullPath, relativePath, name, textEdits, precondition, refreshOpt, validateOpt);
-                }
-                case "validate":
-                {
-                    var level = @params["level"]?.ToString()?.ToLowerInvariant() ?? "standard";
-                    var chosen = level switch
-                    {
-                        "basic" => ValidationLevel.Basic,
-                        "standard" => ValidationLevel.Standard,
-                        "strict" => ValidationLevel.Strict,
-                        "comprehensive" => ValidationLevel.Comprehensive,
-                        _ => ValidationLevel.Standard
-                    };
-                    string fileText;
-                    try { fileText = File.ReadAllText(fullPath); }
-                    catch (Exception ex) { return Response.Error($"Failed to read script: {ex.Message}"); }
-
-                    var ok = ValidateScriptSyntax(fileText, chosen, out var diagsRaw);
-                    var diags = (diagsRaw ?? Array.Empty<string>()).Select(s =>
-                    {
-                        var m = Regex.Match(
-                            s,
-                            @"^(ERROR|WARNING|INFO): (.*?)(?: \(Line (\d+)\))?$",
-                            RegexOptions.CultureInvariant | RegexOptions.Multiline,
-                            TimeSpan.FromMilliseconds(250)
-                        );
-                        var severity = m.Success ? m.Groups[1].Value.ToLowerInvariant() : "info";
-                        var message = m.Success ? m.Groups[2].Value : s;
-                        var lineNum = m.Success && int.TryParse(m.Groups[3].Value, out var l) ? l : 0;
-                        return new { line = lineNum, col = 0, severity, message };
-                    }).ToArray();
-
-                    var result = new { diagnostics = diags };
-                    return ok ? Response.Success("Validation completed.", result)
-                               : Response.Error("Validation failed.", result);
-                }
-                case "edit":
-                    Debug.LogWarning("manage_script.edit is deprecated; prefer apply_text_edits. Serving structured edit for backward compatibility.");
-                    var structEdits = @params["edits"] as JArray;
-                    var options = @params["options"] as JObject;
-                    return EditScript(fullPath, relativePath, name, structEdits, options);
-                case "get_sha":
-                {
-                    try
-                    {
-                        if (!File.Exists(fullPath))
-                            return Response.Error($"Script not found at '{relativePath}'.");
-
-                        var text = File.ReadAllText(fullPath);
-                        var sha = ComputeSha256(text);
-                        var fi = new FileInfo(fullPath);
-                        long lengthBytes;
-                        try { lengthBytes = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false).GetByteCount(text); }
-                        catch { lengthBytes = fi.Exists ? fi.Length : 0; }
-                        var data = new
-                        {
-                            uri = $"unity://path/{relativePath}",
-                            path = relativePath,
-                            sha256 = sha,
-                            lengthBytes,
-                            lastModifiedUtc = fi.Exists ? fi.LastWriteTimeUtc.ToString("o") : string.Empty
-                        };
-                        return Response.Success($"SHA computed for '{relativePath}'.", data);
-                    }
-                    catch (Exception ex)
-                    {
-                        return Response.Error($"Failed to compute SHA: {ex.Message}");
-                    }
-                }
-                default:
-                    return Response.Error(
-                        $"Unknown action: '{action}'. Valid actions are: create, delete, apply_text_edits, validate, read (deprecated), update (deprecated), edit (deprecated)."
-                    );
-            }
-        }
-
-        /// <summary>
-        /// Decode base64 string to normal text
-        /// </summary>
-        private static string DecodeBase64(string encoded)
-        {
-            var data = Convert.FromBase64String(encoded);
-            return System.Text.Encoding.UTF8.GetString(data);
-        }
-
-        /// <summary>
-        /// Encode text to base64 string
-        /// </summary>
-        private static string EncodeBase64(string text)
-        {
-            var data = System.Text.Encoding.UTF8.GetBytes(text);
-            return Convert.ToBase64String(data);
-        }
-
-        private static object CreateScript(
-            string fullPath,
-            string relativePath,
-            string name,
-            string contents,
-            string scriptType,
-            string namespaceName
-        )
-        {
-            // Check if script already exists
-            if (File.Exists(fullPath))
-            {
-                return Response.Error(
-                    $"Script already exists at '{relativePath}'. Use 'update' action to modify."
-                );
-            }
-
-            // Generate default content if none provided
-            if (string.IsNullOrEmpty(contents))
-            {
-                contents = GenerateDefaultScriptContent(name, scriptType, namespaceName);
-            }
-
-            // Validate syntax with detailed error reporting using GUI setting
-            var validationLevel = GetValidationLevelFromGUI();
-            var isValid = ValidateScriptSyntax(contents, validationLevel, out var validationErrors);
-            if (!isValid)
-            {
-                return Response.Error("validation_failed", new { status = "validation_failed", diagnostics = validationErrors ?? Array.Empty<string>() });
-            }
-            else if (validationErrors != null && validationErrors.Length > 0)
-            {
-                // Log warnings but don't block creation
-                Debug.LogWarning($"Script validation warnings for {name}:\n" + string.Join("\n", validationErrors));
-            }
-
-            try
-            {
-                // Atomic create without BOM; schedule refresh after reply
-                var enc = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
-                var tmp = fullPath + ".tmp";
-                File.WriteAllText(tmp, contents, enc);
-                try
-                {
-                    File.Move(tmp, fullPath);
-                }
-                catch (IOException)
-                {
-                    File.Copy(tmp, fullPath, overwrite: true);
-                    try { File.Delete(tmp); } catch { }
-                }
-
-                var uri = $"unity://path/{relativePath}";
-                var ok = Response.Success(
-                    $"Script '{name}.cs' created successfully at '{relativePath}'.",
-                    new { uri, scheduledRefresh = false }
-                );
-
-                ManageScriptRefreshHelpers.ImportAndRequestCompile(relativePath);
-
-                return ok;
-            }
-            catch (Exception e)
-            {
-                return Response.ScriptError($"Failed to create script '{relativePath}': {e.Message}", relativePath, null, new[] {
-                    "Check directory permissions",
-                    "Ensure parent directory exists",
-                    "Verify script name follows C# naming conventions"
-                });
-            }
-        }
-
-        private static object ReadScript(string fullPath, string relativePath)
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.ScriptError($"Script not found at '{relativePath}'.", relativePath, null, new[] {
-                    "Check if the script path is correct",
-                    "Ensure the script exists in the Assets folder",
-                    "Try using 'list' action to see available scripts"
-                });
-            }
-
-            try
-            {
-                var contents = File.ReadAllText(fullPath);
-
-                // Return both normal and encoded contents for larger files
-                var isLarge = contents.Length > 10000; // If content is large, include encoded version
-                var uri = $"unity://path/{relativePath}";
-                var responseData = new
-                {
-                    uri,
-                    path = relativePath,
-                    contents,
-                    // For large files, also include base64-encoded version
-                    encodedContents = isLarge ? EncodeBase64(contents) : null,
-                    contentsEncoded = isLarge,
-                };
-
-                return Response.Success(
-                    $"Script '{Path.GetFileName(relativePath)}' read successfully.",
-                    responseData
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to read script '{relativePath}': {e.Message}");
-            }
-        }
-
-        private static object UpdateScript(
-            string fullPath,
-            string relativePath,
-            string name,
-            string contents
-        )
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.Error(
-                    $"Script not found at '{relativePath}'. Use 'create' action to add a new script."
-                );
-            }
-            if (string.IsNullOrEmpty(contents))
-            {
-                return Response.Error("Content is required for the 'update' action.");
-            }
-
-            // Validate syntax with detailed error reporting using GUI setting
-            var validationLevel = GetValidationLevelFromGUI();
-            var isValid = ValidateScriptSyntax(contents, validationLevel, out var validationErrors);
-            if (!isValid)
-            {
-                return Response.Error("validation_failed", new { status = "validation_failed", diagnostics = validationErrors ?? Array.Empty<string>() });
-            }
-            else if (validationErrors != null && validationErrors.Length > 0)
-            {
-                // Log warnings but don't block update
-                Debug.LogWarning($"Script validation warnings for {name}:\n" + string.Join("\n", validationErrors));
-            }
-
-            try
-            {
-                // Safe write with atomic replace when available, without BOM
-                var encoding = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
-                var tempPath = fullPath + ".tmp";
-                File.WriteAllText(tempPath, contents, encoding);
-
-                var backupPath = fullPath + ".bak";
-                try
-                {
-                    File.Replace(tempPath, fullPath, backupPath);
-                    try { if (File.Exists(backupPath)) File.Delete(backupPath); } catch { }
-                }
-                catch (PlatformNotSupportedException)
-                {
-                    File.Copy(tempPath, fullPath, true);
-                    try { File.Delete(tempPath); } catch { }
-                    try { if (File.Exists(backupPath)) File.Delete(backupPath); } catch { }
-                }
-                catch (IOException)
-                {
-                    File.Copy(tempPath, fullPath, true);
-                    try { File.Delete(tempPath); } catch { }
-                    try { if (File.Exists(backupPath)) File.Delete(backupPath); } catch { }
-                }
-
-                // Prepare success response BEFORE any operation that can trigger a domain reload
-                var uri = $"unity://path/{relativePath}";
-                var ok = Response.Success(
-                    $"Script '{name}.cs' updated successfully at '{relativePath}'.",
-                    new { uri, path = relativePath, scheduledRefresh = true }
-                );
-
-                // Schedule a debounced import/compile on next editor tick to avoid stalling the reply
-                ManageScriptRefreshHelpers.ScheduleScriptRefresh(relativePath);
-
-                return ok;
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to update script '{relativePath}': {e.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Apply simple text edits specified by line/column ranges. Applies transactionally and validates result.
-        /// </summary>
-        private const int MaxEditPayloadBytes = 64 * 1024;
-
-        private static object ApplyTextEdits(
-            string fullPath,
-            string relativePath,
-            string name,
-            JArray edits,
-            string preconditionSha256,
-            string refreshModeFromCaller = null,
-            string validateMode = null)
-        {
-            if (!File.Exists(fullPath))
-                return Response.Error($"Script not found at '{relativePath}'.");
-            // Refuse edits if the target or any ancestor is a symlink
-            try
-            {
-                var di = new DirectoryInfo(Path.GetDirectoryName(fullPath) ?? "");
-                while (di != null && !string.Equals(di.FullName.Replace('\\','/'), Application.dataPath.Replace('\\','/'), StringComparison.OrdinalIgnoreCase))
-                {
-                    if (di.Exists && (di.Attributes & FileAttributes.ReparsePoint) != 0)
-                        return Response.Error("Refusing to edit a symlinked script path.");
-                    di = di.Parent;
-                }
-            }
-            catch
-            {
-                // If checking attributes fails, proceed without the symlink guard
-            }
-            if (edits == null || edits.Count == 0)
-                return Response.Error("No edits provided.");
-
-            string original;
-            try { original = File.ReadAllText(fullPath); }
-            catch (Exception ex) { return Response.Error($"Failed to read script: {ex.Message}"); }
-
-            // Require precondition to avoid drift on large files
-            var currentSha = ComputeSha256(original);
-            if (string.IsNullOrEmpty(preconditionSha256))
-                return Response.Error("precondition_required", new { status = "precondition_required", current_sha256 = currentSha });
-            if (!preconditionSha256.Equals(currentSha, StringComparison.OrdinalIgnoreCase))
-                return Response.Error("stale_file", new { status = "stale_file", expected_sha256 = preconditionSha256, current_sha256 = currentSha });
-
-            // Convert edits to absolute index ranges
-            var spans = new List<(int start, int end, string text)>();
-            long totalBytes = 0;
-            foreach (var e in edits)
-            {
-                try
-                {
-                    var sl = Math.Max(1, e.Value<int>("startLine"));
-                    var sc = Math.Max(1, e.Value<int>("startCol"));
-                    var el = Math.Max(1, e.Value<int>("endLine"));
-                    var ec = Math.Max(1, e.Value<int>("endCol"));
-                    var newText = e.Value<string>("newText") ?? string.Empty;
-
-                    if (!TryIndexFromLineCol(original, sl, sc, out var sidx))
-                        return Response.Error($"apply_text_edits: start out of range (line {sl}, col {sc})");
-                    if (!TryIndexFromLineCol(original, el, ec, out var eidx))
-                        return Response.Error($"apply_text_edits: end out of range (line {el}, col {ec})");
-                    if (eidx < sidx) (sidx, eidx) = (eidx, sidx);
-
-                    spans.Add((sidx, eidx, newText));
-                    checked
-                    {
-                        totalBytes += System.Text.Encoding.UTF8.GetByteCount(newText);
-                    }
-                }
-                catch (Exception ex)
-                {
-                    return Response.Error($"Invalid edit payload: {ex.Message}");
-                }
-            }
-
-            // Header guard: refuse edits that touch before the first 'using ' directive (after optional BOM) to prevent file corruption
-            var headerBoundary = (original.Length > 0 && original[0] == '\uFEFF') ? 1 : 0; // skip BOM once if present
-            // Find first top-level using (supports alias, static, and dotted namespaces)
-            var mUsing = System.Text.RegularExpressions.Regex.Match(
-                original,
-                @"(?m)^\s*using\s+(?:static\s+)?(?:[A-Za-z_]\w*\s*=\s*)?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*\s*;",
-                System.Text.RegularExpressions.RegexOptions.CultureInvariant,
-                TimeSpan.FromSeconds(2)
-            );
-            if (mUsing.Success)
-            {
-                headerBoundary = Math.Min(Math.Max(headerBoundary, mUsing.Index), original.Length);
-            }
-            foreach (var sp in spans)
-            {
-                if (sp.start < headerBoundary)
-                {
-                    return Response.Error("using_guard", new { status = "using_guard", hint = "Refusing to edit before the first 'using'. Use anchor_insert near a method or a structured edit." });
-                }
-            }
-
-            // Attempt auto-upgrade: if a single edit targets a method header/body, re-route as structured replace_method
-            if (spans.Count == 1)
-            {
-                var sp = spans[0];
-                // Heuristic: around the start of the edit, try to match a method header in original
-                var searchStart = Math.Max(0, sp.start - 200);
-                var searchEnd = Math.Min(original.Length, sp.start + 200);
-                var slice = original.Substring(searchStart, searchEnd - searchStart);
-                var rx = new System.Text.RegularExpressions.Regex(@"(?m)^[\t ]*(?:\[[^\]]+\][\t ]*)*[\t ]*(?:public|private|protected|internal|static|virtual|override|sealed|async|extern|unsafe|new|partial)[\s\S]*?\b([A-Za-z_][A-Za-z0-9_]*)\s*\(");
-                var mh = rx.Match(slice);
-                if (mh.Success)
-                {
-                    var methodName = mh.Groups[1].Value;
-                    // Find class span containing the edit
-                    if (TryComputeClassSpan(original, name, null, out var clsStart, out var clsLen, out _))
-                    {
-                        if (TryComputeMethodSpan(original, clsStart, clsLen, methodName, null, null, null, out var mStart, out var mLen, out _))
-                        {
-                            // If the edit overlaps the method span significantly, treat as replace_method
-                            if (sp.start <= mStart + 2 && sp.end >= mStart + 1)
-                            {
-                                var structEdits = new JArray();
-
-                                // Apply the edit to get a candidate string, then recompute method span on the edited text
-                                var candidate = original.Remove(sp.start, sp.end - sp.start).Insert(sp.start, sp.text ?? string.Empty);
-                                string replacementText;
-                                if (TryComputeClassSpan(candidate, name, null, out var cls2Start, out var cls2Len, out _)
-                                    && TryComputeMethodSpan(candidate, cls2Start, cls2Len, methodName, null, null, null, out var m2Start, out var m2Len, out _))
-                                {
-                                    replacementText = candidate.Substring(m2Start, m2Len);
-                                }
-                                else
-                                {
-                                    // Fallback: adjust method start by the net delta if the edit was before the method
-                                    var delta = (sp.text?.Length ?? 0) - (sp.end - sp.start);
-                                    var adjustedStart = mStart + (sp.start <= mStart ? delta : 0);
-                                    adjustedStart = Math.Max(0, Math.Min(adjustedStart, candidate.Length));
-
-                                    // If the edit was within the original method span, adjust the length by the delta within-method
-                                    var withinMethodDelta = 0;
-                                    if (sp.start >= mStart && sp.start <= mStart + mLen)
-                                    {
-                                        withinMethodDelta = delta;
-                                    }
-                                    var adjustedLen = mLen + withinMethodDelta;
-                                    adjustedLen = Math.Max(0, Math.Min(candidate.Length - adjustedStart, adjustedLen));
-                                    replacementText = candidate.Substring(adjustedStart, adjustedLen);
-                                }
-
-                                var op = new JObject
-                                {
-                                    ["mode"] = "replace_method",
-                                    ["className"] = name,
-                                    ["methodName"] = methodName,
-                                    ["replacement"] = replacementText
-                                };
-                                structEdits.Add(op);
-                                // Reuse structured path
-                                return EditScript(fullPath, relativePath, name, structEdits, new JObject{ ["refresh"] = "immediate", ["validate"] = "standard" });
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (totalBytes > MaxEditPayloadBytes)
-            {
-                return Response.Error("too_large", new { status = "too_large", limitBytes = MaxEditPayloadBytes, hint = "split into smaller edits" });
-            }
-
-            // Ensure non-overlap and apply from back to front
-            spans = spans.OrderByDescending(t => t.start).ToList();
-            for (var i = 1; i < spans.Count; i++)
-            {
-                 if (spans[i].end > spans[i - 1].start)
-                {
-                    var conflict = new[] { new { startA = spans[i].start, endA = spans[i].end, startB = spans[i - 1].start, endB = spans[i - 1].end } };
-                    return Response.Error("overlap", new { status = "overlap", conflicts = conflict, hint = "Sort ranges descending by start and compute from the same snapshot." });
-                }
-            }
-
-            var working = original;
-            var relaxed = string.Equals(validateMode, "relaxed", StringComparison.OrdinalIgnoreCase);
-            var syntaxOnly = string.Equals(validateMode, "syntax", StringComparison.OrdinalIgnoreCase);
-            foreach (var sp in spans)
-            {
-                var next = working.Remove(sp.start, sp.end - sp.start).Insert(sp.start, sp.text ?? string.Empty);
-                if (relaxed)
-                {
-                    // Scoped balance check: validate just around the changed region to avoid false positives
-                    var originalLength = sp.end - sp.start;
-                    var newLength = sp.text?.Length ?? 0;
-                    var endPos = sp.start + newLength;
-                    if (!CheckScopedBalance(next, Math.Max(0, sp.start - 500), Math.Min(next.Length, endPos + 500)))
-                    {
-                        return Response.Error("unbalanced_braces", new { status = "unbalanced_braces", line = 0, expected = "{}()[] (scoped)", hint = "Use standard validation or shrink the edit range." });
-                    }
-                }
-                working = next;
-            }
-
-            // No-op guard: if resulting text is identical, avoid writes and return explicit no-op
-            if (string.Equals(working, original, StringComparison.Ordinal))
-            {
-                var noChangeSha = ComputeSha256(original);
-                return Response.Success(
-                    $"No-op: contents unchanged for '{relativePath}'.",
-                    new
-                    {
-                        uri = $"unity://path/{relativePath}",
-                        path = relativePath,
-                        editsApplied = 0,
-                        no_op = true,
-                        sha256 = noChangeSha,
-                        evidence = new { reason = "identical_content" }
-                    }
-                );
-            }
-
-            // Always check final structural balance regardless of relaxed mode
-            if (!CheckBalancedDelimiters(working, out var line, out var expected))
-            {
-                var startLine = Math.Max(1, line - 5);
-                var endLine = line + 5;
-                var hint = $"unbalanced_braces at line {line}. Call resources/read for lines {startLine}-{endLine} and resend a smaller apply_text_edits that restores balance.";
-                return Response.Error(hint, new { status = "unbalanced_braces", line, expected = expected.ToString(), evidenceWindow = new { startLine, endLine } });
-            }
-
-#if USE_ROSLYN
-            if (!syntaxOnly)
-            {
-                var tree = CSharpSyntaxTree.ParseText(working);
-                var diagnostics = tree.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error).Take(3)
-                    .Select(d => new {
-                        line = d.Location.GetLineSpan().StartLinePosition.Line + 1,
-                        col = d.Location.GetLineSpan().StartLinePosition.Character + 1,
-                        code = d.Id,
-                        message = d.GetMessage()
-                    }).ToArray();
-                if (diagnostics.Length > 0)
-                {
-                    int firstLine = diagnostics[0].line;
-                    int startLineRos = Math.Max(1, firstLine - 5);
-                    int endLineRos = firstLine + 5;
-                    return Response.Error("syntax_error", new { status = "syntax_error", diagnostics, evidenceWindow = new { startLine = startLineRos, endLine = endLineRos } });
-                }
-
-                // Optional formatting
-                try
-                {
-                    var root = tree.GetRoot();
-                    var workspace = new AdhocWorkspace();
-                    root = Microsoft.CodeAnalysis.Formatting.Formatter.Format(root, workspace);
-                    working = root.ToFullString();
-                }
-                catch { }
-            }
-#endif
-
-            var newSha = ComputeSha256(working);
-
-            // Atomic write and schedule refresh
-            try
-            {
-                var enc = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
-                var tmp = fullPath + ".tmp";
-                File.WriteAllText(tmp, working, enc);
-                var backup = fullPath + ".bak";
-                try
-                {
-                    File.Replace(tmp, fullPath, backup);
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { /* ignore */ }
-                }
-                catch (PlatformNotSupportedException)
-                {
-                    File.Copy(tmp, fullPath, true);
-                    try { File.Delete(tmp); } catch { }
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { }
-                }
-                catch (IOException)
-                {
-                    File.Copy(tmp, fullPath, true);
-                    try { File.Delete(tmp); } catch { }
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { }
-                }
-
-                // Respect refresh mode: immediate vs debounced
-                var immediate = string.Equals(refreshModeFromCaller, "immediate", StringComparison.OrdinalIgnoreCase) ||
-                                  string.Equals(refreshModeFromCaller, "sync", StringComparison.OrdinalIgnoreCase);
-                if (immediate)
-                {
-                    McpLog.Info($"[ManageScript] ApplyTextEdits: immediate refresh for '{relativePath}'");
-                    AssetDatabase.ImportAsset(
-                        relativePath,
-                        ImportAssetOptions.ForceSynchronousImport | ImportAssetOptions.ForceUpdate
-                    );
-#if UNITY_EDITOR
-                    UnityEditor.Compilation.CompilationPipeline.RequestScriptCompilation();
-#endif
-                }
-                else
-                {
-                    McpLog.Info($"[ManageScript] ApplyTextEdits: debounced refresh scheduled for '{relativePath}'");
-                    ManageScriptRefreshHelpers.ScheduleScriptRefresh(relativePath);
-                }
-
-                return Response.Success(
-                    $"Applied {spans.Count} text edit(s) to '{relativePath}'.",
-                    new
-                    {
-                        uri = $"unity://path/{relativePath}",
-                        path = relativePath,
-                        editsApplied = spans.Count,
-                        sha256 = newSha,
-                        scheduledRefresh = !immediate
-                    }
-                );
-            }
-            catch (Exception ex)
-            {
-                return Response.Error($"Failed to write edits: {ex.Message}");
-            }
-        }
-
-        private static bool TryIndexFromLineCol(string text, int line1, int col1, out int index)
-        {
-            // 1-based line/col to absolute index (0-based), col positions are counted in code points
-            int line = 1, col = 1;
-            for (var i = 0; i <= text.Length; i++)
-            {
-                if (line == line1 && col == col1)
-                {
-                    index = i;
-                    return true;
-                }
-                if (i == text.Length) break;
-                var c = text[i];
-                if (c == '\r')
-                {
-                    // Treat CRLF as a single newline; skip the LF if present
-                    if (i + 1 < text.Length && text[i + 1] == '\n')
-                        i++;
-                    line++;
-                    col = 1;
-                }
-                else if (c == '\n')
-                {
-                    line++;
-                    col = 1;
-                }
-                else
-                {
-                    col++;
-                }
-            }
-            index = -1;
-            return false;
-        }
-
-        private static string ComputeSha256(string contents)
-        {
-            using (var sha = SHA256.Create())
-            {
-                var bytes = System.Text.Encoding.UTF8.GetBytes(contents);
-                var hash = sha.ComputeHash(bytes);
-                return BitConverter.ToString(hash).Replace("-", string.Empty).ToLowerInvariant();
-            }
-        }
-
-        private static bool CheckBalancedDelimiters(string text, out int line, out char expected)
-        {
-            var braceStack = new Stack<int>();
-            var parenStack = new Stack<int>();
-            var bracketStack = new Stack<int>();
-            bool inString = false, inChar = false, inSingle = false, inMulti = false, escape = false;
-            line = 1; expected = '\0';
-
-            for (var i = 0; i < text.Length; i++)
-            {
-                var c = text[i];
-                var next = i + 1 < text.Length ? text[i + 1] : '\0';
-
-                if (c == '\n') { line++; if (inSingle) inSingle = false; }
-
-                if (escape) { escape = false; continue; }
-
-                if (inString)
-                {
-                    if (c == '\\') { escape = true; }
-                    else if (c == '"') inString = false;
-                    continue;
-                }
-                if (inChar)
-                {
-                    if (c == '\\') { escape = true; }
-                    else if (c == '\'') inChar = false;
-                    continue;
-                }
-                if (inSingle) continue;
-                if (inMulti)
-                {
-                    if (c == '*' && next == '/') { inMulti = false; i++; }
-                    continue;
-                }
-
-                if (c == '"') { inString = true; continue; }
-                if (c == '\'') { inChar = true; continue; }
-                if (c == '/' && next == '/') { inSingle = true; i++; continue; }
-                if (c == '/' && next == '*') { inMulti = true; i++; continue; }
-
-                switch (c)
-                {
-                    case '{': braceStack.Push(line); break;
-                    case '}':
-                        if (braceStack.Count == 0) { expected = '{'; return false; }
-                        braceStack.Pop();
-                        break;
-                    case '(': parenStack.Push(line); break;
-                    case ')':
-                        if (parenStack.Count == 0) { expected = '('; return false; }
-                        parenStack.Pop();
-                        break;
-                    case '[': bracketStack.Push(line); break;
-                    case ']':
-                        if (bracketStack.Count == 0) { expected = '['; return false; }
-                        bracketStack.Pop();
-                        break;
-                }
-            }
-
-            if (braceStack.Count > 0) { line = braceStack.Peek(); expected = '}'; return false; }
-            if (parenStack.Count > 0) { line = parenStack.Peek(); expected = ')'; return false; }
-            if (bracketStack.Count > 0) { line = bracketStack.Peek(); expected = ']'; return false; }
-
-            return true;
-        }
-
-        // Lightweight scoped balance: checks delimiters within a substring, ignoring outer context
-        private static bool CheckScopedBalance(string text, int start, int end)
-        {
-            start = Math.Max(0, Math.Min(text.Length, start));
-            end = Math.Max(start, Math.Min(text.Length, end));
-            int brace = 0, paren = 0, bracket = 0;
-            bool inStr = false, inChr = false, esc = false;
-            for (var i = start; i < end; i++)
-            {
-                var c = text[i];
-                var n = (i + 1 < end) ? text[i + 1] : '\0';
-                if (inStr)
-                {
-                    if (!esc && c == '"') inStr = false; esc = (!esc && c == '\\'); continue;
-                }
-                if (inChr)
-                {
-                    if (!esc && c == '\'') inChr = false; esc = (!esc && c == '\\'); continue;
-                }
-                if (c == '"') { inStr = true; esc = false; continue; }
-                if (c == '\'') { inChr = true; esc = false; continue; }
-                if (c == '/' && n == '/') { while (i < end && text[i] != '\n') i++; continue; }
-                if (c == '/' && n == '*') { i += 2; while (i + 1 < end && !(text[i] == '*' && text[i + 1] == '/')) i++; i++; continue; }
-                if (c == '{') brace++; else if (c == '}') brace--;
-                else if (c == '(') paren++; else if (c == ')') paren--;
-                else if (c == '[') bracket++; else if (c == ']') bracket--;
-                // Allow temporary negative balance - will check tolerance at end
-            }
-            return brace >= -3 && paren >= -3 && bracket >= -3; // tolerate more context from outside region
-        }
-
-        private static object DeleteScript(string fullPath, string relativePath)
-        {
-            if (!File.Exists(fullPath))
-            {
-                return Response.Error($"Script not found at '{relativePath}'. Cannot delete.");
-            }
-
-            try
-            {
-                // Use AssetDatabase.MoveAssetToTrash for safer deletion (allows undo)
-                var deleted = AssetDatabase.MoveAssetToTrash(relativePath);
-                if (deleted)
-                {
-                    AssetDatabase.Refresh();
-                    return Response.Success(
-                        $"Script '{Path.GetFileName(relativePath)}' moved to trash successfully.",
-                        new { deleted = true }
-                    );
-                }
-                else
-                {
-                    // Fallback or error if MoveAssetToTrash fails
-                    return Response.Error(
-                        $"Failed to move script '{relativePath}' to trash. It might be locked or in use."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error deleting script '{relativePath}': {e.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Structured edits (AST-backed where available) on existing scripts.
-        /// Supports class-level replace/delete with Roslyn span computation if USE_ROSLYN is defined,
-        /// otherwise falls back to a conservative balanced-brace scan.
-        /// </summary>
-        private static object EditScript(
-            string fullPath,
-            string relativePath,
-            string name,
-            JArray edits,
-            JObject options)
-        {
-            if (!File.Exists(fullPath))
-                return Response.Error($"Script not found at '{relativePath}'.");
-            // Refuse edits if the target is a symlink
-            try
-            {
-                var attrs = File.GetAttributes(fullPath);
-                if ((attrs & FileAttributes.ReparsePoint) != 0)
-                    return Response.Error("Refusing to edit a symlinked script path.");
-            }
-            catch
-            {
-                // ignore failures checking attributes and proceed
-            }
-            if (edits == null || edits.Count == 0)
-                return Response.Error("No edits provided.");
-
-            string original;
-            try { original = File.ReadAllText(fullPath); }
-            catch (Exception ex) { return Response.Error($"Failed to read script: {ex.Message}"); }
-
-            var working = original;
-
-            try
-            {
-                var replacements = new List<(int start, int length, string text)>();
-                var appliedCount = 0;
-
-                // Apply mode: atomic (default) computes all spans against original and applies together.
-                // Sequential applies each edit immediately to the current working text (useful for dependent edits).
-                var applyMode = options?["applyMode"]?.ToString()?.ToLowerInvariant();
-                var applySequentially = applyMode == "sequential";
-
-                foreach (var e in edits)
-                {
-                    var op = (JObject)e;
-                    var mode = (op.Value<string>("mode") ?? op.Value<string>("op") ?? string.Empty).ToLowerInvariant();
-
-                    switch (mode)
-                    {
-                        case "replace_class":
-                        {
-                            var className = op.Value<string>("className");
-                            var ns = op.Value<string>("namespace");
-                            var replacement = ExtractReplacement(op);
-
-                            if (string.IsNullOrWhiteSpace(className))
-                                return Response.Error("replace_class requires 'className'.");
-                            if (replacement == null)
-                                return Response.Error("replace_class requires 'replacement' (inline or base64).");
-
-                            if (!TryComputeClassSpan(working, className, ns, out var spanStart, out var spanLength, out var why))
-                                return Response.Error($"replace_class failed: {why}");
-
-                            if (!ValidateClassSnippet(replacement, className, out var vErr))
-                                return Response.Error($"Replacement snippet invalid: {vErr}");
-
-                            if (applySequentially)
-                            {
-                                working = working.Remove(spanStart, spanLength).Insert(spanStart, NormalizeNewlines(replacement));
-                                appliedCount++;
-                            }
-                            else
-                            {
-                                replacements.Add((spanStart, spanLength, NormalizeNewlines(replacement)));
-                            }
-                            break;
-                        }
-
-                        case "delete_class":
-                        {
-                            var className = op.Value<string>("className");
-                            var ns = op.Value<string>("namespace");
-                            if (string.IsNullOrWhiteSpace(className))
-                                return Response.Error("delete_class requires 'className'.");
-
-                            if (!TryComputeClassSpan(working, className, ns, out var s, out var l, out var why))
-                                return Response.Error($"delete_class failed: {why}");
-
-                            if (applySequentially)
-                            {
-                                working = working.Remove(s, l);
-                                appliedCount++;
-                            }
-                            else
-                            {
-                                replacements.Add((s, l, string.Empty));
-                            }
-                            break;
-                        }
-
-                        case "replace_method":
-                        {
-                            var className = op.Value<string>("className");
-                            var ns = op.Value<string>("namespace");
-                            var methodName = op.Value<string>("methodName");
-                            var replacement = ExtractReplacement(op);
-                            var returnType = op.Value<string>("returnType");
-                            var parametersSignature = op.Value<string>("parametersSignature");
-                            var attributesContains = op.Value<string>("attributesContains");
-
-                            if (string.IsNullOrWhiteSpace(className)) return Response.Error("replace_method requires 'className'.");
-                            if (string.IsNullOrWhiteSpace(methodName)) return Response.Error("replace_method requires 'methodName'.");
-                            if (replacement == null) return Response.Error("replace_method requires 'replacement' (inline or base64).");
-
-                            if (!TryComputeClassSpan(working, className, ns, out var clsStart, out var clsLen, out var whyClass))
-                                return Response.Error($"replace_method failed to locate class: {whyClass}");
-
-                            if (!TryComputeMethodSpan(working, clsStart, clsLen, methodName, returnType, parametersSignature, attributesContains, out var mStart, out var mLen, out var whyMethod))
-                            {
-                                var hasDependentInsert = edits.Any(j => j is JObject jo &&
-                                    string.Equals(jo.Value<string>("className"), className, StringComparison.Ordinal) &&
-                                    string.Equals(jo.Value<string>("methodName"), methodName, StringComparison.Ordinal) &&
-                                    ((jo.Value<string>("mode") ?? jo.Value<string>("op") ?? string.Empty).ToLowerInvariant() == "insert_method"));
-                                var hint = hasDependentInsert && !applySequentially ? " Hint: This batch inserts this method. Use options.applyMode='sequential' or split into separate calls." : string.Empty;
-                                return Response.Error($"replace_method failed: {whyMethod}.{hint}");
-                            }
-
-                            if (applySequentially)
-                            {
-                                working = working.Remove(mStart, mLen).Insert(mStart, NormalizeNewlines(replacement));
-                                appliedCount++;
-                            }
-                            else
-                            {
-                                replacements.Add((mStart, mLen, NormalizeNewlines(replacement)));
-                            }
-                            break;
-                        }
-
-                        case "delete_method":
-                        {
-                            var className = op.Value<string>("className");
-                            var ns = op.Value<string>("namespace");
-                            var methodName = op.Value<string>("methodName");
-                            var returnType = op.Value<string>("returnType");
-                            var parametersSignature = op.Value<string>("parametersSignature");
-                            var attributesContains = op.Value<string>("attributesContains");
-
-                            if (string.IsNullOrWhiteSpace(className)) return Response.Error("delete_method requires 'className'.");
-                            if (string.IsNullOrWhiteSpace(methodName)) return Response.Error("delete_method requires 'methodName'.");
-
-                            if (!TryComputeClassSpan(working, className, ns, out var clsStart, out var clsLen, out var whyClass))
-                                return Response.Error($"delete_method failed to locate class: {whyClass}");
-
-                            if (!TryComputeMethodSpan(working, clsStart, clsLen, methodName, returnType, parametersSignature, attributesContains, out var mStart, out var mLen, out var whyMethod))
-                            {
-                                var hasDependentInsert = edits.Any(j => j is JObject jo &&
-                                    string.Equals(jo.Value<string>("className"), className, StringComparison.Ordinal) &&
-                                    string.Equals(jo.Value<string>("methodName"), methodName, StringComparison.Ordinal) &&
-                                    ((jo.Value<string>("mode") ?? jo.Value<string>("op") ?? string.Empty).ToLowerInvariant() == "insert_method"));
-                                var hint = hasDependentInsert && !applySequentially ? " Hint: This batch inserts this method. Use options.applyMode='sequential' or split into separate calls." : string.Empty;
-                                return Response.Error($"delete_method failed: {whyMethod}.{hint}");
-                            }
-
-                            if (applySequentially)
-                            {
-                                working = working.Remove(mStart, mLen);
-                                appliedCount++;
-                            }
-                            else
-                            {
-                                replacements.Add((mStart, mLen, string.Empty));
-                            }
-                            break;
-                        }
-
-                        case "insert_method":
-                        {
-                            var className = op.Value<string>("className");
-                            var ns = op.Value<string>("namespace");
-                            var position = (op.Value<string>("position") ?? "end").ToLowerInvariant();
-                            var afterMethodName = op.Value<string>("afterMethodName");
-                            var afterReturnType = op.Value<string>("afterReturnType");
-                            var afterParameters = op.Value<string>("afterParametersSignature");
-                            var afterAttributesContains = op.Value<string>("afterAttributesContains");
-                            var snippet = ExtractReplacement(op);
-                            // Harden: refuse empty replacement for inserts
-                            if (snippet == null || snippet.Trim().Length == 0)
-                                return Response.Error("insert_method requires a non-empty 'replacement' text.");
-
-                            if (string.IsNullOrWhiteSpace(className)) return Response.Error("insert_method requires 'className'.");
-                            if (snippet == null) return Response.Error("insert_method requires 'replacement' (inline or base64) containing a full method declaration.");
-
-                            if (!TryComputeClassSpan(working, className, ns, out var clsStart, out var clsLen, out var whyClass))
-                                return Response.Error($"insert_method failed to locate class: {whyClass}");
-
-                            if (position == "after")
-                            {
-                                if (string.IsNullOrEmpty(afterMethodName)) return Response.Error("insert_method with position='after' requires 'afterMethodName'.");
-                                if (!TryComputeMethodSpan(working, clsStart, clsLen, afterMethodName, afterReturnType, afterParameters, afterAttributesContains, out var aStart, out var aLen, out var whyAfter))
-                                    return Response.Error($"insert_method(after) failed to locate anchor method: {whyAfter}");
-                                var insAt = aStart + aLen;
-                                var text = NormalizeNewlines("\n\n" + snippet.TrimEnd() + "\n");
-                                if (applySequentially)
-                                {
-                                    working = working.Insert(insAt, text);
-                                    appliedCount++;
-                                }
-                                else
-                                {
-                                    replacements.Add((insAt, 0, text));
-                                }
-                            }
-                            else if (!TryFindClassInsertionPoint(working, clsStart, clsLen, position, out var insAt, out var whyIns))
-                                return Response.Error($"insert_method failed: {whyIns}");
-                            else
-                            {
-                                var text = NormalizeNewlines("\n\n" + snippet.TrimEnd() + "\n");
-                                if (applySequentially)
-                                {
-                                    working = working.Insert(insAt, text);
-                                    appliedCount++;
-                                }
-                                else
-                                {
-                                    replacements.Add((insAt, 0, text));
-                                }
-                            }
-                            break;
-                        }
-
-                        case "anchor_insert":
-                        {
-                            var anchor = op.Value<string>("anchor");
-                            var position = (op.Value<string>("position") ?? "before").ToLowerInvariant();
-                            var text = op.Value<string>("text") ?? ExtractReplacement(op);
-                            if (string.IsNullOrWhiteSpace(anchor)) return Response.Error("anchor_insert requires 'anchor' (regex).");
-                            if (string.IsNullOrEmpty(text)) return Response.Error("anchor_insert requires non-empty 'text'.");
-
-                            try
-                            {
-                                var rx = new Regex(anchor, RegexOptions.Multiline, TimeSpan.FromSeconds(2));
-                                var m = rx.Match(working);
-                                if (!m.Success) return Response.Error($"anchor_insert: anchor not found: {anchor}");
-                                var insAt = position == "after" ? m.Index + m.Length : m.Index;
-                                var norm = NormalizeNewlines(text);
-                                if (!norm.EndsWith("\n"))
-                                {
-                                    norm += "\n";
-                                }
-
-                                // Duplicate guard: if identical snippet already exists within this class, skip insert
-                                if (TryComputeClassSpan(working, name, null, out var clsStartDG, out var clsLenDG, out _))
-                                {
-                                    var classSlice = working.Substring(clsStartDG, Math.Min(clsLenDG, working.Length - clsStartDG));
-                                    if (classSlice.IndexOf(norm, StringComparison.Ordinal) >= 0)
-                                    {
-                                        // Do not insert duplicate; treat as no-op
-                                        break;
-                                    }
-                                }
-                                if (applySequentially)
-                                {
-                                    working = working.Insert(insAt, norm);
-                                    appliedCount++;
-                                }
-                                else
-                                {
-                                    replacements.Add((insAt, 0, norm));
-                                }
-                            }
-                            catch (Exception ex)
-                            {
-                                return Response.Error($"anchor_insert failed: {ex.Message}");
-                            }
-                            break;
-                        }
-
-                        case "anchor_delete":
-                        {
-                            var anchor = op.Value<string>("anchor");
-                            if (string.IsNullOrWhiteSpace(anchor)) return Response.Error("anchor_delete requires 'anchor' (regex).");
-                            try
-                            {
-                                var rx = new Regex(anchor, RegexOptions.Multiline, TimeSpan.FromSeconds(2));
-                                var m = rx.Match(working);
-                                if (!m.Success) return Response.Error($"anchor_delete: anchor not found: {anchor}");
-                                var delAt = m.Index;
-                                var delLen = m.Length;
-                                if (applySequentially)
-                                {
-                                    working = working.Remove(delAt, delLen);
-                                    appliedCount++;
-                                }
-                                else
-                                {
-                                    replacements.Add((delAt, delLen, string.Empty));
-                                }
-                            }
-                            catch (Exception ex)
-                            {
-                                return Response.Error($"anchor_delete failed: {ex.Message}");
-                            }
-                            break;
-                        }
-
-                        case "anchor_replace":
-                        {
-                            var anchor = op.Value<string>("anchor");
-                            var replacement = op.Value<string>("text") ?? op.Value<string>("replacement") ?? ExtractReplacement(op) ?? string.Empty;
-                            if (string.IsNullOrWhiteSpace(anchor)) return Response.Error("anchor_replace requires 'anchor' (regex).");
-                            try
-                            {
-                                var rx = new Regex(anchor, RegexOptions.Multiline, TimeSpan.FromSeconds(2));
-                                var m = rx.Match(working);
-                                if (!m.Success) return Response.Error($"anchor_replace: anchor not found: {anchor}");
-                                var at = m.Index;
-                                var len = m.Length;
-                                var norm = NormalizeNewlines(replacement);
-                                if (applySequentially)
-                                {
-                                    working = working.Remove(at, len).Insert(at, norm);
-                                    appliedCount++;
-                                }
-                                else
-                                {
-                                    replacements.Add((at, len, norm));
-                                }
-                            }
-                            catch (Exception ex)
-                            {
-                                return Response.Error($"anchor_replace failed: {ex.Message}");
-                            }
-                            break;
-                        }
-
-                        default:
-                            return Response.Error($"Unknown edit mode: '{mode}'. Allowed: replace_class, delete_class, replace_method, delete_method, insert_method, anchor_insert, anchor_delete, anchor_replace.");
-                    }
-                }
-
-                if (!applySequentially)
-                {
-                    if (HasOverlaps(replacements))
-                    {
-                        var ordered = replacements.OrderByDescending(r => r.start).ToList();
-                        for (var i = 1; i < ordered.Count; i++)
-                        {
-                            if (ordered[i].start + ordered[i].length > ordered[i - 1].start)
-                            {
-                                var conflict = new[] { new { startA = ordered[i].start, endA = ordered[i].start + ordered[i].length, startB = ordered[i - 1].start, endB = ordered[i - 1].start + ordered[i - 1].length } };
-                                return Response.Error("overlap", new { status = "overlap", conflicts = conflict, hint = "Sort ranges descending by start and compute from the same snapshot." });
-                            }
-                        }
-                        return Response.Error("overlap", new { status = "overlap" });
-                    }
-
-                    foreach (var r in replacements.OrderByDescending(r => r.start))
-                        working = working.Remove(r.start, r.length).Insert(r.start, r.text);
-                    appliedCount = replacements.Count;
-                }
-
-                // No-op guard for structured edits: if text unchanged, return explicit no-op
-                if (string.Equals(working, original, StringComparison.Ordinal))
-                {
-                    var sameSha = ComputeSha256(original);
-                    return Response.Success(
-                        $"No-op: contents unchanged for '{relativePath}'.",
-                        new
-                        {
-                            path = relativePath,
-                            uri = $"unity://path/{relativePath}",
-                            editsApplied = 0,
-                            no_op = true,
-                            sha256 = sameSha,
-                            evidence = new { reason = "identical_content" }
-                        }
-                    );
-                }
-
-                // Validate result using override from options if provided; otherwise GUI strictness
-                var level = GetValidationLevelFromGUI();
-                try
-                {
-                    var validateOpt = options?["validate"]?.ToString()?.ToLowerInvariant();
-                    if (!string.IsNullOrEmpty(validateOpt))
-                    {
-                        level = validateOpt switch
-                        {
-                            "basic" => ValidationLevel.Basic,
-                            "standard" => ValidationLevel.Standard,
-                            "comprehensive" => ValidationLevel.Comprehensive,
-                            "strict" => ValidationLevel.Strict,
-                            _ => level
-                        };
-                    }
-                }
-                catch { /* ignore option parsing issues */ }
-                if (!ValidateScriptSyntax(working, level, out var errors))
-                    return Response.Error("validation_failed", new { status = "validation_failed", diagnostics = errors ?? Array.Empty<string>() });
-                else if (errors != null && errors.Length > 0)
-                    Debug.LogWarning($"Script validation warnings for {name}:\n" + string.Join("\n", errors));
-
-                // Atomic write with backup; schedule refresh
-                // Decide refresh behavior
-                var refreshMode = options?["refresh"]?.ToString()?.ToLowerInvariant();
-                var immediate = refreshMode == "immediate" || refreshMode == "sync";
-
-                // Persist changes atomically (no BOM), then compute/return new file SHA
-                var enc = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
-                var tmp = fullPath + ".tmp";
-                File.WriteAllText(tmp, working, enc);
-                var backup = fullPath + ".bak";
-                try
-                {
-                    File.Replace(tmp, fullPath, backup);
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { }
-                }
-                catch (PlatformNotSupportedException)
-                {
-                    File.Copy(tmp, fullPath, true);
-                    try { File.Delete(tmp); } catch { }
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { }
-                }
-                catch (IOException)
-                {
-                    File.Copy(tmp, fullPath, true);
-                    try { File.Delete(tmp); } catch { }
-                    try { if (File.Exists(backup)) File.Delete(backup); } catch { }
-                }
-
-                var newSha = ComputeSha256(working);
-                var ok = Response.Success(
-                    $"Applied {appliedCount} structured edit(s) to '{relativePath}'.",
-                    new
-                    {
-                        path = relativePath,
-                        uri = $"unity://path/{relativePath}",
-                        editsApplied = appliedCount,
-                        scheduledRefresh = !immediate,
-                        sha256 = newSha
-                    }
-                );
-
-                if (immediate)
-                {
-                    McpLog.Info($"[ManageScript] EditScript: immediate refresh for '{relativePath}'", always: false);
-                    ManageScriptRefreshHelpers.ImportAndRequestCompile(relativePath);
-                }
-                else
-                {
-                    ManageScriptRefreshHelpers.ScheduleScriptRefresh(relativePath);
-                }
-                return ok;
-            }
-            catch (Exception ex)
-            {
-                return Response.Error($"Edit failed: {ex.Message}");
-            }
-        }
-
-        private static bool HasOverlaps(IEnumerable<(int start, int length, string text)> list)
-        {
-            var arr = list.OrderBy(x => x.start).ToArray();
-            for (var i = 1; i < arr.Length; i++)
-            {
-                if (arr[i - 1].start + arr[i - 1].length > arr[i].start)
-                    return true;
-            }
-            return false;
-        }
-
-        private static string ExtractReplacement(JObject op)
-        {
-            var inline = op.Value<string>("replacement");
-            if (!string.IsNullOrEmpty(inline)) return inline;
-
-            var b64 = op.Value<string>("replacementBase64");
-            if (!string.IsNullOrEmpty(b64))
-            {
-                try { return System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(b64)); }
-                catch { return null; }
-            }
-            return null;
-        }
-
-        private static string NormalizeNewlines(string t)
-        {
-            if (string.IsNullOrEmpty(t)) return t;
-            return t.Replace("\r\n", "\n").Replace("\r", "\n");
-        }
-
-        private static bool ValidateClassSnippet(string snippet, string expectedName, out string err)
-        {
-#if USE_ROSLYN
-            try
-            {
-                var tree = CSharpSyntaxTree.ParseText(snippet);
-                var root = tree.GetRoot();
-                var classes = root.DescendantNodes().OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>().ToList();
-                if (classes.Count != 1) { err = "snippet must contain exactly one class declaration"; return false; }
-                // Optional: enforce expected name
-                // if (classes[0].Identifier.ValueText != expectedName) { err = $"snippet declares '{classes[0].Identifier.ValueText}', expected '{expectedName}'"; return false; }
-                err = null; return true;
-            }
-            catch (Exception ex) { err = ex.Message; return false; }
-#else
-            if (string.IsNullOrWhiteSpace(snippet) || !snippet.Contains("class ")) { err = "no 'class' keyword found in snippet"; return false; }
-            err = null; return true;
-#endif
-        }
-
-        private static bool TryComputeClassSpan(string source, string className, string ns, out int start, out int length, out string why)
-        {
-#if USE_ROSLYN
-            try
-            {
-                var tree = CSharpSyntaxTree.ParseText(source);
-                var root = tree.GetRoot();
-                var classes = root.DescendantNodes()
-                    .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
-                    .Where(c => c.Identifier.ValueText == className);
-
-                if (!string.IsNullOrEmpty(ns))
-                {
-                    classes = classes.Where(c =>
-                        (c.FirstAncestorOrSelf<Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax>()?.Name?.ToString() ?? "") == ns
-                        || (c.FirstAncestorOrSelf<Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax>()?.Name?.ToString() ?? "") == ns);
-                }
-
-                var list = classes.ToList();
-                if (list.Count == 0) { start = length = 0; why = $"class '{className}' not found" + (ns != null ? $" in namespace '{ns}'" : ""); return false; }
-                if (list.Count > 1) { start = length = 0; why = $"class '{className}' matched {list.Count} declarations (partial/nested?). Disambiguate."; return false; }
-
-                var cls = list[0];
-                var span = cls.FullSpan; // includes attributes & leading trivia
-                start = span.Start; length = span.Length; why = null; return true;
-            }
-            catch
-            {
-                // fall back below
-            }
-#endif
-            return TryComputeClassSpanBalanced(source, className, ns, out start, out length, out why);
-        }
-
-        private static bool TryComputeClassSpanBalanced(string source, string className, string ns, out int start, out int length, out string why)
-        {
-            start = length = 0; why = null;
-            var idx = IndexOfClassToken(source, className);
-            if (idx < 0) { why = $"class '{className}' not found (balanced scan)"; return false; }
-
-            if (!string.IsNullOrEmpty(ns) && !AppearsWithinNamespaceHeader(source, idx, ns))
-            { why = $"class '{className}' not under namespace '{ns}' (balanced scan)"; return false; }
-
-            // Include modifiers/attributes on the same line: back up to the start of line
-            var lineStart = idx;
-            while (lineStart > 0 && source[lineStart - 1] != '\n' && source[lineStart - 1] != '\r') lineStart--;
-
-            var i = idx;
-            while (i < source.Length && source[i] != '{') i++;
-            if (i >= source.Length) { why = "no opening brace after class header"; return false; }
-
-            var depth = 0; bool inStr = false, inChar = false, inSL = false, inML = false, esc = false;
-            var startSpan = lineStart;
-            for (; i < source.Length; i++)
-            {
-                var c = source[i];
-                var n = i + 1 < source.Length ? source[i + 1] : '\0';
-
-                if (inSL) { if (c == '\n') inSL = false; continue; }
-                if (inML) { if (c == '*' && n == '/') { inML = false; i++; } continue; }
-                if (inStr) { if (!esc && c == '"') inStr = false; esc = (!esc && c == '\\'); continue; }
-                if (inChar) { if (!esc && c == '\'') inChar = false; esc = (!esc && c == '\\'); continue; }
-
-                if (c == '/' && n == '/') { inSL = true; i++; continue; }
-                if (c == '/' && n == '*') { inML = true; i++; continue; }
-                if (c == '"') { inStr = true; continue; }
-                if (c == '\'') { inChar = true; continue; }
-
-                if (c == '{') { depth++; }
-                else if (c == '}')
-                {
-                    depth--;
-                    if (depth == 0) { start = startSpan; length = (i - startSpan) + 1; return true; }
-                    if (depth < 0) { why = "brace underflow"; return false; }
-                }
-            }
-            why = "unterminated class block"; return false;
-        }
-
-        private static bool TryComputeMethodSpan(
-            string source,
-            int classStart,
-            int classLength,
-            string methodName,
-            string returnType,
-            string parametersSignature,
-            string attributesContains,
-            out int start,
-            out int length,
-            out string why)
-        {
-            start = length = 0; why = null;
-            var searchStart = classStart;
-            var searchEnd = Math.Min(source.Length, classStart + classLength);
-
-            // 1) Find the method header using a stricter regex (allows optional attributes above)
-            var rtPattern = string.IsNullOrEmpty(returnType) ? @"[^\s]+" : Regex.Escape(returnType).Replace("\\ ", "\\s+");
-            var namePattern = Regex.Escape(methodName);
-            // If a parametersSignature is provided, it may include surrounding parentheses. Strip them so
-            // we can safely embed the signature inside our own parenthesis group without duplicating.
-            string paramsPattern;
-            if (string.IsNullOrEmpty(parametersSignature))
-            {
-                paramsPattern = @"[\s\S]*?"; // permissive when not specified
-            }
-            else
-            {
-                var ps = parametersSignature.Trim();
-                if (ps.StartsWith("(") && ps.EndsWith(")") && ps.Length >= 2)
-                {
-                    ps = ps.Substring(1, ps.Length - 2);
-                }
-                // Escape literal text of the signature
-                paramsPattern = Regex.Escape(ps);
-            }
-            var pattern =
-                @"(?m)^[\t ]*(?:\[[^\]]+\][\t ]*)*[\t ]*" +
-                @"(?:(?:public|private|protected|internal|static|virtual|override|sealed|async|extern|unsafe|new|partial|readonly|volatile|event|abstract|ref|in|out)\s+)*" +
-                rtPattern + @"[\t ]+" + namePattern + @"\s*(?:<[^>]+>)?\s*\(" + paramsPattern + @"\)";
-
-            var slice = source.Substring(searchStart, searchEnd - searchStart);
-            var headerMatch = Regex.Match(slice, pattern, RegexOptions.Multiline, TimeSpan.FromSeconds(2));
-            if (!headerMatch.Success)
-            {
-                why = $"method '{methodName}' header not found in class"; return false;
-            }
-            var headerIndex = searchStart + headerMatch.Index;
-
-            // Optional attributes filter: look upward from headerIndex for contiguous attribute lines
-            if (!string.IsNullOrEmpty(attributesContains))
-            {
-                var attrScanStart = headerIndex;
-                while (attrScanStart > searchStart)
-                {
-                    var prevNl = source.LastIndexOf('\n', attrScanStart - 1);
-                    if (prevNl < 0 || prevNl < searchStart) break;
-                    var prevLine = source.Substring(prevNl + 1, attrScanStart - (prevNl + 1));
-                    if (prevLine.TrimStart().StartsWith("[")) { attrScanStart = prevNl; continue; }
-                    break;
-                }
-                var attrBlock = source.Substring(attrScanStart, headerIndex - attrScanStart);
-                if (attrBlock.IndexOf(attributesContains, StringComparison.Ordinal) < 0)
-                {
-                    why = $"method '{methodName}' found but attributes filter did not match"; return false;
-                }
-            }
-
-            // backtrack to the very start of header/attributes to include in span
-            var lineStart = headerIndex;
-            while (lineStart > searchStart && source[lineStart - 1] != '\n' && source[lineStart - 1] != '\r') lineStart--;
-            // If previous lines are attributes, include them
-            var attrStart = lineStart;
-            var probe = lineStart - 1;
-            while (probe > searchStart)
-            {
-                var prevNl = source.LastIndexOf('\n', probe);
-                if (prevNl < 0 || prevNl < searchStart) break;
-                var prev = source.Substring(prevNl + 1, attrStart - (prevNl + 1));
-                if (prev.TrimStart().StartsWith("[")) { attrStart = prevNl + 1; probe = prevNl - 1; }
-                else break;
-            }
-
-            // 2) Walk from the end of signature to detect body style ('{' or '=> ...;') and compute end
-            // Find the '(' that belongs to the method signature, not attributes
-            var nameTokenIdx = IndexOfTokenWithin(source, methodName, headerIndex, searchEnd);
-            if (nameTokenIdx < 0) { why = $"method '{methodName}' token not found after header"; return false; }
-            var sigOpenParen = IndexOfTokenWithin(source, "(", nameTokenIdx, searchEnd);
-            if (sigOpenParen < 0) { why = "method parameter list '(' not found"; return false; }
-
-            var i = sigOpenParen;
-            var parenDepth = 0; bool inStr = false, inChar = false, inSL = false, inML = false, esc = false;
-            for (; i < searchEnd; i++)
-            {
-                var c = source[i];
-                var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                if (inSL) { if (c == '\n') inSL = false; continue; }
-                if (inML) { if (c == '*' && n == '/') { inML = false; i++; } continue; }
-                if (inStr) { if (!esc && c == '"') inStr = false; esc = (!esc && c == '\\'); continue; }
-                if (inChar) { if (!esc && c == '\'') inChar = false; esc = (!esc && c == '\\'); continue; }
-
-                if (c == '/' && n == '/') { inSL = true; i++; continue; }
-                if (c == '/' && n == '*') { inML = true; i++; continue; }
-                if (c == '"') { inStr = true; continue; }
-                if (c == '\'') { inChar = true; continue; }
-
-                if (c == '(') parenDepth++;
-                if (c == ')') { parenDepth--; if (parenDepth == 0) { i++; break; } }
-            }
-
-            // After params: detect expression-bodied or block-bodied
-            // Skip whitespace/comments
-            for (; i < searchEnd; i++)
-            {
-                var c = source[i];
-                var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                if (char.IsWhiteSpace(c)) continue;
-                if (c == '/' && n == '/') { while (i < searchEnd && source[i] != '\n') i++; continue; }
-                if (c == '/' && n == '*') { i += 2; while (i + 1 < searchEnd && !(source[i] == '*' && source[i + 1] == '/')) i++; i++; continue; }
-                break;
-            }
-
-            // Tolerate generic constraints between params and body: multiple 'where T : ...'
-            for (;;)
-            {
-                // Skip whitespace/comments before checking for 'where'
-                for (; i < searchEnd; i++)
-                {
-                    var c = source[i];
-                    var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                    if (char.IsWhiteSpace(c)) continue;
-                    if (c == '/' && n == '/') { while (i < searchEnd && source[i] != '\n') i++; continue; }
-                    if (c == '/' && n == '*') { i += 2; while (i + 1 < searchEnd && !(source[i] == '*' && source[i + 1] == '/')) i++; i++; continue; }
-                    break;
-                }
-
-                // Check word-boundary 'where'
-                var hasWhere = false;
-                if (i + 5 <= searchEnd)
-                {
-                    hasWhere = source[i] == 'w' && source[i + 1] == 'h' && source[i + 2] == 'e' && source[i + 3] == 'r' && source[i + 4] == 'e';
-                    if (hasWhere)
-                    {
-                        // Left boundary
-                        if (i - 1 >= 0)
-                        {
-                            var lb = source[i - 1];
-                            if (char.IsLetterOrDigit(lb) || lb == '_') hasWhere = false;
-                        }
-                        // Right boundary
-                        if (hasWhere && i + 5 < searchEnd)
-                        {
-                            var rb = source[i + 5];
-                            if (char.IsLetterOrDigit(rb) || rb == '_') hasWhere = false;
-                        }
-                    }
-                }
-                if (!hasWhere) break;
-
-                // Advance past the entire where-constraint clause until we hit '{' or '=>' or ';'
-                i += 5; // past 'where'
-                while (i < searchEnd)
-                {
-                    var c = source[i];
-                    var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                    if (c == '{' || c == ';' || (c == '=' && n == '>')) break;
-                    // Skip comments inline
-                    if (c == '/' && n == '/') { while (i < searchEnd && source[i] != '\n') i++; continue; }
-                    if (c == '/' && n == '*') { i += 2; while (i + 1 < searchEnd && !(source[i] == '*' && source[i + 1] == '/')) i++; i++; continue; }
-                    i++;
-                }
-            }
-
-            // Re-check for expression-bodied after constraints
-            if (i < searchEnd - 1 && source[i] == '=' && source[i + 1] == '>')
-            {
-                // expression-bodied method: seek to terminating semicolon
-                var j = i;
-                var done = false;
-                while (j < searchEnd)
-                {
-                    var c = source[j];
-                    if (c == ';') { done = true; break; }
-                    j++;
-                }
-                if (!done) { why = "unterminated expression-bodied method"; return false; }
-                start = attrStart; length = (j - attrStart) + 1; return true;
-            }
-
-            if (i >= searchEnd || source[i] != '{') { why = "no opening brace after method signature"; return false; }
-
-            var depth = 0; inStr = false; inChar = false; inSL = false; inML = false; esc = false;
-            var startSpan = attrStart;
-            for (; i < searchEnd; i++)
-            {
-                var c = source[i];
-                var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                if (inSL) { if (c == '\n') inSL = false; continue; }
-                if (inML) { if (c == '*' && n == '/') { inML = false; i++; } continue; }
-                if (inStr) { if (!esc && c == '"') inStr = false; esc = (!esc && c == '\\'); continue; }
-                if (inChar) { if (!esc && c == '\'') inChar = false; esc = (!esc && c == '\\'); continue; }
-
-                if (c == '/' && n == '/') { inSL = true; i++; continue; }
-                if (c == '/' && n == '*') { inML = true; i++; continue; }
-                if (c == '"') { inStr = true; continue; }
-                if (c == '\'') { inChar = true; continue; }
-
-                if (c == '{') depth++;
-                else if (c == '}')
-                {
-                    depth--;
-                    if (depth == 0) { start = startSpan; length = (i - startSpan) + 1; return true; }
-                    if (depth < 0) { why = "brace underflow in method"; return false; }
-                }
-            }
-            why = "unterminated method block"; return false;
-        }
-
-        private static int IndexOfTokenWithin(string s, string token, int start, int end)
-        {
-            var idx = s.IndexOf(token, start, StringComparison.Ordinal);
-            return (idx >= 0 && idx < end) ? idx : -1;
-        }
-
-        private static bool TryFindClassInsertionPoint(string source, int classStart, int classLength, string position, out int insertAt, out string why)
-        {
-            insertAt = 0; why = null;
-            var searchStart = classStart;
-            var searchEnd = Math.Min(source.Length, classStart + classLength);
-
-            if (position == "start")
-            {
-                // find first '{' after class header, insert just after with a newline
-                var i = IndexOfTokenWithin(source, "{", searchStart, searchEnd);
-                if (i < 0) { why = "could not find class opening brace"; return false; }
-                insertAt = i + 1; return true;
-            }
-            else // end
-            {
-                // walk to matching closing brace of class and insert just before it
-                var i = IndexOfTokenWithin(source, "{", searchStart, searchEnd);
-                if (i < 0) { why = "could not find class opening brace"; return false; }
-                var depth = 0; bool inStr = false, inChar = false, inSL = false, inML = false, esc = false;
-                for (; i < searchEnd; i++)
-                {
-                    var c = source[i];
-                    var n = i + 1 < searchEnd ? source[i + 1] : '\0';
-                    if (inSL) { if (c == '\n') inSL = false; continue; }
-                    if (inML) { if (c == '*' && n == '/') { inML = false; i++; } continue; }
-                    if (inStr) { if (!esc && c == '"') inStr = false; esc = (!esc && c == '\\'); continue; }
-                    if (inChar) { if (!esc && c == '\'') inChar = false; esc = (!esc && c == '\\'); continue; }
-
-                    if (c == '/' && n == '/') { inSL = true; i++; continue; }
-                    if (c == '/' && n == '*') { inML = true; i++; continue; }
-                    if (c == '"') { inStr = true; continue; }
-                    if (c == '\'') { inChar = true; continue; }
-
-                    if (c == '{') depth++;
-                    else if (c == '}')
-                    {
-                        depth--;
-                        if (depth == 0) { insertAt = i; return true; }
-                        if (depth < 0) { why = "brace underflow while scanning class"; return false; }
-                    }
-                }
-                why = "could not find class closing brace"; return false;
-            }
-        }
-
-        private static int IndexOfClassToken(string s, string className)
-        {
-            // simple token search; could be tightened with Regex for word boundaries
-            var pattern = "class " + className;
-            return s.IndexOf(pattern, StringComparison.Ordinal);
-        }
-
-        private static bool AppearsWithinNamespaceHeader(string s, int pos, string ns)
-        {
-            var from = Math.Max(0, pos - 2000);
-            var slice = s.Substring(from, pos - from);
-            return slice.Contains("namespace " + ns);
-        }
-
-        /// <summary>
-        /// Generates basic C# script content based on name and type.
-        /// </summary>
-        private static string GenerateDefaultScriptContent(
-            string name,
-            string scriptType,
-            string namespaceName
-        )
-        {
-            var usingStatements = "using UnityEngine;\nusing System.Collections;\n";
-            string classDeclaration;
-            var body =
-                "\n    // Use this for initialization\n    void Start() {\n\n    }\n\n    // Update is called once per frame\n    void Update() {\n\n    }\n";
-
-            var baseClass = "";
-            if (!string.IsNullOrEmpty(scriptType))
-            {
-                if (scriptType.Equals("MonoBehaviour", StringComparison.OrdinalIgnoreCase))
-                    baseClass = " : MonoBehaviour";
-                else if (scriptType.Equals("ScriptableObject", StringComparison.OrdinalIgnoreCase))
-                {
-                    baseClass = " : ScriptableObject";
-                    body = ""; // ScriptableObjects don't usually need Start/Update
-                }
-                else if (
-                    scriptType.Equals("Editor", StringComparison.OrdinalIgnoreCase)
-                    || scriptType.Equals("EditorWindow", StringComparison.OrdinalIgnoreCase)
-                )
-                {
-                    usingStatements += "using UnityEditor;\n";
-                    if (scriptType.Equals("Editor", StringComparison.OrdinalIgnoreCase))
-                        baseClass = " : Editor";
-                    else
-                        baseClass = " : EditorWindow";
-                    body = ""; // Editor scripts have different structures
-                }
-                // Add more types as needed
-            }
-
-            classDeclaration = $"public class {name}{baseClass}";
-
-            var fullContent = $"{usingStatements}\n";
-            var useNamespace = !string.IsNullOrEmpty(namespaceName);
-
-            if (useNamespace)
-            {
-                fullContent += $"namespace {namespaceName}\n{{\n";
-                // Indent class and body if using namespace
-                classDeclaration = "    " + classDeclaration;
-                body = string.Join("\n", body.Split('\n').Select(line => "    " + line));
-            }
-
-            fullContent += $"{classDeclaration}\n{{\n{body}\n}}";
-
-            if (useNamespace)
-            {
-                fullContent += "\n}"; // Close namespace
-            }
-
-            return fullContent.Trim() + "\n"; // Ensure a trailing newline
-        }
-
-        /// <summary>
-        /// Gets the validation level from the GUI settings
-        /// </summary>
-        private static ValidationLevel GetValidationLevelFromGUI()
-        {
-            var savedLevel = EditorPrefs.GetString("MCPForUnity_ScriptValidationLevel", "standard");
-            return savedLevel.ToLower() switch
-            {
-                "basic" => ValidationLevel.Basic,
-                "standard" => ValidationLevel.Standard,
-                "comprehensive" => ValidationLevel.Comprehensive,
-                "strict" => ValidationLevel.Strict,
-                _ => ValidationLevel.Standard // Default fallback
-            };
-        }
-
-        /// <summary>
-        /// Validates C# script syntax using multiple validation layers.
-        /// </summary>
-        private static bool ValidateScriptSyntax(string contents)
-        {
-            return ValidateScriptSyntax(contents, ValidationLevel.Standard, out _);
-        }
-
-        /// <summary>
-        /// Advanced syntax validation with detailed diagnostics and configurable strictness.
-        /// </summary>
-        private static bool ValidateScriptSyntax(string contents, ValidationLevel level, out string[] errors)
-        {
-            var errorList = new System.Collections.Generic.List<string>();
-            errors = null;
-
-            if (string.IsNullOrEmpty(contents))
-            {
-                return true; // Empty content is valid
-            }
-
-            // Basic structural validation
-            if (!ValidateBasicStructure(contents, errorList))
-            {
-                errors = errorList.ToArray();
-                return false;
-            }
-
-#if USE_ROSLYN
-            // Advanced Roslyn-based validation: only run for Standard+; fail on Roslyn errors
-            if (level >= ValidationLevel.Standard)
-            {
-                if (!ValidateScriptSyntaxRoslyn(contents, level, errorList))
-                {
-                    errors = errorList.ToArray();
-                    return false;
-                }
-            }
-#endif
-
-            // Unity-specific validation
-            if (level >= ValidationLevel.Standard)
-            {
-                ValidateScriptSyntaxUnity(contents, errorList);
-            }
-
-            // Semantic analysis for common issues
-            if (level >= ValidationLevel.Comprehensive)
-            {
-                ValidateSemanticRules(contents, errorList);
-            }
-
-#if USE_ROSLYN
-            // Full semantic compilation validation for Strict level
-            if (level == ValidationLevel.Strict)
-            {
-                if (!ValidateScriptSemantics(contents, errorList))
-                {
-                    errors = errorList.ToArray();
-                    return false; // Strict level fails on any semantic errors
-                }
-            }
-#endif
-
-            errors = errorList.ToArray();
-            return errorList.Count == 0 || (level != ValidationLevel.Strict && !errorList.Any(e => e.StartsWith("ERROR:")));
-        }
-
-        /// <summary>
-        /// Validation strictness levels
-        /// </summary>
-        private enum ValidationLevel
-        {
-            Basic,        // Only syntax errors
-            Standard,     // Syntax + Unity best practices
-            Comprehensive, // All checks + semantic analysis
-            Strict        // Treat all issues as errors
-        }
-
-        /// <summary>
-        /// Validates basic code structure (braces, quotes, comments)
-        /// </summary>
-        private static bool ValidateBasicStructure(string contents, System.Collections.Generic.List<string> errors)
-        {
-            var isValid = true;
-            var braceBalance = 0;
-            var parenBalance = 0;
-            var bracketBalance = 0;
-            var inStringLiteral = false;
-            var inCharLiteral = false;
-            var inSingleLineComment = false;
-            var inMultiLineComment = false;
-            var escaped = false;
-
-            for (var i = 0; i < contents.Length; i++)
-            {
-                var c = contents[i];
-                var next = i + 1 < contents.Length ? contents[i + 1] : '\0';
-
-                // Handle escape sequences
-                if (escaped)
-                {
-                    escaped = false;
-                    continue;
-                }
-
-                if (c == '\\' && (inStringLiteral || inCharLiteral))
-                {
-                    escaped = true;
-                    continue;
-                }
-
-                // Handle comments
-                if (!inStringLiteral && !inCharLiteral)
-                {
-                    if (c == '/' && next == '/' && !inMultiLineComment)
-                    {
-                        inSingleLineComment = true;
-                        continue;
-                    }
-                    if (c == '/' && next == '*' && !inSingleLineComment)
-                    {
-                        inMultiLineComment = true;
-                        i++; // Skip next character
-                        continue;
-                    }
-                    if (c == '*' && next == '/' && inMultiLineComment)
-                    {
-                        inMultiLineComment = false;
-                        i++; // Skip next character
-                        continue;
-                    }
-                }
-
-                if (c == '\n')
-                {
-                    inSingleLineComment = false;
-                    continue;
-                }
-
-                if (inSingleLineComment || inMultiLineComment)
-                    continue;
-
-                // Handle string and character literals
-                if (c == '"' && !inCharLiteral)
-                {
-                    inStringLiteral = !inStringLiteral;
-                    continue;
-                }
-                if (c == '\'' && !inStringLiteral)
-                {
-                    inCharLiteral = !inCharLiteral;
-                    continue;
-                }
-
-                if (inStringLiteral || inCharLiteral)
-                    continue;
-
-                // Count brackets and braces
-                switch (c)
-                {
-                    case '{': braceBalance++; break;
-                    case '}': braceBalance--; break;
-                    case '(': parenBalance++; break;
-                    case ')': parenBalance--; break;
-                    case '[': bracketBalance++; break;
-                    case ']': bracketBalance--; break;
-                }
-
-                // Check for negative balances (closing without opening)
-                if (braceBalance < 0)
-                {
-                    errors.Add("ERROR: Unmatched closing brace '}'");
-                    isValid = false;
-                }
-                if (parenBalance < 0)
-                {
-                    errors.Add("ERROR: Unmatched closing parenthesis ')'");
-                    isValid = false;
-                }
-                if (bracketBalance < 0)
-                {
-                    errors.Add("ERROR: Unmatched closing bracket ']'");
-                    isValid = false;
-                }
-            }
-
-            // Check final balances
-            if (braceBalance != 0)
-            {
-                errors.Add($"ERROR: Unbalanced braces (difference: {braceBalance})");
-                isValid = false;
-            }
-            if (parenBalance != 0)
-            {
-                errors.Add($"ERROR: Unbalanced parentheses (difference: {parenBalance})");
-                isValid = false;
-            }
-            if (bracketBalance != 0)
-            {
-                errors.Add($"ERROR: Unbalanced brackets (difference: {bracketBalance})");
-                isValid = false;
-            }
-            if (inStringLiteral)
-            {
-                errors.Add("ERROR: Unterminated string literal");
-                isValid = false;
-            }
-            if (inCharLiteral)
-            {
-                errors.Add("ERROR: Unterminated character literal");
-                isValid = false;
-            }
-            if (inMultiLineComment)
-            {
-                errors.Add("WARNING: Unterminated multi-line comment");
-            }
-
-            return isValid;
-        }
-
-#if USE_ROSLYN
-        /// <summary>
-        /// Cached compilation references for performance
-        /// </summary>
-        private static System.Collections.Generic.List<MetadataReference> _cachedReferences = null;
-        private static DateTime _cacheTime = DateTime.MinValue;
-        private static readonly TimeSpan CacheExpiry = TimeSpan.FromMinutes(5);
-
-        /// <summary>
-        /// Validates syntax using Roslyn compiler services
-        /// </summary>
-        private static bool ValidateScriptSyntaxRoslyn(string contents, ValidationLevel level, System.Collections.Generic.List<string> errors)
-        {
-            try
-            {
-                var syntaxTree = CSharpSyntaxTree.ParseText(contents);
-                var diagnostics = syntaxTree.GetDiagnostics();
-
-                bool hasErrors = false;
-                foreach (var diagnostic in diagnostics)
-                {
-                    string severity = diagnostic.Severity.ToString().ToUpper();
-                    string message = $"{severity}: {diagnostic.GetMessage()}";
-
-                    if (diagnostic.Severity == DiagnosticSeverity.Error)
-                    {
-                        hasErrors = true;
-                    }
-
-                    // Include warnings in comprehensive mode
-                    if (level >= ValidationLevel.Standard || diagnostic.Severity == DiagnosticSeverity.Error) //Also use Standard for now
-                    {
-                        var location = diagnostic.Location.GetLineSpan();
-                        if (location.IsValid)
-                        {
-                            message += $" (Line {location.StartLinePosition.Line + 1})";
-                        }
-                        errors.Add(message);
-                    }
-                }
-
-                return !hasErrors;
-            }
-            catch (Exception ex)
-            {
-                errors.Add($"ERROR: Roslyn validation failed: {ex.Message}");
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Validates script semantics using full compilation context to catch namespace, type, and method resolution errors
-        /// </summary>
-        private static bool ValidateScriptSemantics(string contents, System.Collections.Generic.List<string> errors)
-        {
-            try
-            {
-                // Get compilation references with caching
-                var references = GetCompilationReferences();
-                if (references == null || references.Count == 0)
-                {
-                    errors.Add("WARNING: Could not load compilation references for semantic validation");
-                    return true; // Don't fail if we can't get references
-                }
-
-                // Create syntax tree
-                var syntaxTree = CSharpSyntaxTree.ParseText(contents);
-
-                // Create compilation with full context
-                var compilation = CSharpCompilation.Create(
-                    "TempValidation",
-                    new[] { syntaxTree },
-                    references,
-                    new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
-                );
-
-                // Get semantic diagnostics - this catches all the issues you mentioned!
-                var diagnostics = compilation.GetDiagnostics();
-
-                bool hasErrors = false;
-                foreach (var diagnostic in diagnostics)
-                {
-                    if (diagnostic.Severity == DiagnosticSeverity.Error)
-                    {
-                        hasErrors = true;
-                        var location = diagnostic.Location.GetLineSpan();
-                        string locationInfo = location.IsValid ?
-                            $" (Line {location.StartLinePosition.Line + 1}, Column {location.StartLinePosition.Character + 1})" : "";
-
-                        // Include diagnostic ID for better error identification
-                        string diagnosticId = !string.IsNullOrEmpty(diagnostic.Id) ? $" [{diagnostic.Id}]" : "";
-                        errors.Add($"ERROR: {diagnostic.GetMessage()}{diagnosticId}{locationInfo}");
-                    }
-                    else if (diagnostic.Severity == DiagnosticSeverity.Warning)
-                    {
-                        var location = diagnostic.Location.GetLineSpan();
-                        string locationInfo = location.IsValid ?
-                            $" (Line {location.StartLinePosition.Line + 1}, Column {location.StartLinePosition.Character + 1})" : "";
-
-                        string diagnosticId = !string.IsNullOrEmpty(diagnostic.Id) ? $" [{diagnostic.Id}]" : "";
-                        errors.Add($"WARNING: {diagnostic.GetMessage()}{diagnosticId}{locationInfo}");
-                    }
-                }
-
-                return !hasErrors;
-            }
-            catch (Exception ex)
-            {
-                errors.Add($"ERROR: Semantic validation failed: {ex.Message}");
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Gets compilation references with caching for performance
-        /// </summary>
-        private static System.Collections.Generic.List<MetadataReference> GetCompilationReferences()
-        {
-            // Check cache validity
-            if (_cachedReferences != null && DateTime.Now - _cacheTime < CacheExpiry)
-            {
-                return _cachedReferences;
-            }
-
-            try
-            {
-                var references = new System.Collections.Generic.List<MetadataReference>();
-
-                // Core .NET assemblies
-                references.Add(MetadataReference.CreateFromFile(typeof(object).Assembly.Location)); // mscorlib/System.Private.CoreLib
-                references.Add(MetadataReference.CreateFromFile(typeof(System.Linq.Enumerable).Assembly.Location)); // System.Linq
-                references.Add(MetadataReference.CreateFromFile(typeof(System.Collections.Generic.List<>).Assembly.Location)); // System.Collections
-
-                // Unity assemblies
-                try
-                {
-                    references.Add(MetadataReference.CreateFromFile(typeof(UnityEngine.Debug).Assembly.Location)); // UnityEngine
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogWarning($"Could not load UnityEngine assembly: {ex.Message}");
-                }
-
-#if UNITY_EDITOR
-                try
-                {
-                    references.Add(MetadataReference.CreateFromFile(typeof(UnityEditor.Editor).Assembly.Location)); // UnityEditor
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogWarning($"Could not load UnityEditor assembly: {ex.Message}");
-                }
-
-                // Get Unity project assemblies
-                try
-                {
-                    var assemblies = CompilationPipeline.GetAssemblies();
-                    foreach (var assembly in assemblies)
-                    {
-                        if (File.Exists(assembly.outputPath))
-                        {
-                            references.Add(MetadataReference.CreateFromFile(assembly.outputPath));
-                        }
-                    }
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogWarning($"Could not load Unity project assemblies: {ex.Message}");
-                }
-#endif
-
-                // Cache the results
-                _cachedReferences = references;
-                _cacheTime = DateTime.Now;
-
-                return references;
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError($"Failed to get compilation references: {ex.Message}");
-                return new System.Collections.Generic.List<MetadataReference>();
-            }
-        }
-#else
-        private static bool ValidateScriptSyntaxRoslyn(string contents, ValidationLevel level, System.Collections.Generic.List<string> errors)
-        {
-            // Fallback when Roslyn is not available
-            return true;
-        }
-#endif
-
-        /// <summary>
-        /// Validates Unity-specific coding rules and best practices
-        /// //TODO: Naive Unity Checks and not really yield any results, need to be improved
-        /// </summary>
-        private static void ValidateScriptSyntaxUnity(string contents, System.Collections.Generic.List<string> errors)
-        {
-            // Check for common Unity anti-patterns
-            if (contents.Contains("FindObjectOfType") && contents.Contains("Update()"))
-            {
-                errors.Add("WARNING: FindObjectOfType in Update() can cause performance issues");
-            }
-
-            if (contents.Contains("GameObject.Find") && contents.Contains("Update()"))
-            {
-                errors.Add("WARNING: GameObject.Find in Update() can cause performance issues");
-            }
-
-            // Check for proper MonoBehaviour usage
-            if (contents.Contains(": MonoBehaviour") && !contents.Contains("using UnityEngine"))
-            {
-                errors.Add("WARNING: MonoBehaviour requires 'using UnityEngine;'");
-            }
-
-            // Check for SerializeField usage
-            if (contents.Contains("[SerializeField]") && !contents.Contains("using UnityEngine"))
-            {
-                errors.Add("WARNING: SerializeField requires 'using UnityEngine;'");
-            }
-
-            // Check for proper coroutine usage
-            if (contents.Contains("StartCoroutine") && !contents.Contains("IEnumerator"))
-            {
-                errors.Add("WARNING: StartCoroutine typically requires IEnumerator methods");
-            }
-
-            // Check for Update without FixedUpdate for physics
-            if (contents.Contains("Rigidbody") && contents.Contains("Update()") && !contents.Contains("FixedUpdate()"))
-            {
-                errors.Add("WARNING: Consider using FixedUpdate() for Rigidbody operations");
-            }
-
-            // Check for missing null checks on Unity objects
-            if (contents.Contains("GetComponent<") && !contents.Contains("!= null"))
-            {
-                errors.Add("WARNING: Consider null checking GetComponent results");
-            }
-
-            // Check for proper event function signatures
-            if (contents.Contains("void Start(") && !contents.Contains("void Start()"))
-            {
-                errors.Add("WARNING: Start() should not have parameters");
-            }
-
-            if (contents.Contains("void Update(") && !contents.Contains("void Update()"))
-            {
-                errors.Add("WARNING: Update() should not have parameters");
-            }
-
-            // Check for inefficient string operations
-            if (contents.Contains("Update()") && contents.Contains("\"") && contents.Contains("+"))
-            {
-                errors.Add("WARNING: String concatenation in Update() can cause garbage collection issues");
-            }
-        }
-
-        /// <summary>
-        /// Validates semantic rules and common coding issues
-        /// </summary>
-        private static void ValidateSemanticRules(string contents, System.Collections.Generic.List<string> errors)
-        {
-            // Check for potential memory leaks
-            if (contents.Contains("new ") && contents.Contains("Update()"))
-            {
-                errors.Add("WARNING: Creating objects in Update() may cause memory issues");
-            }
-
-            // Check for magic numbers
-            var magicNumberPattern = new Regex(@"\b\d+\.?\d*f?\b(?!\s*[;})\]])", RegexOptions.CultureInvariant, TimeSpan.FromSeconds(2));
-            var matches = magicNumberPattern.Matches(contents);
-            if (matches.Count > 5)
-            {
-                errors.Add("WARNING: Consider using named constants instead of magic numbers");
-            }
-
-            // Check for long methods (simple line count check)
-            var methodPattern = new Regex(@"(public|private|protected|internal)?\s*(static)?\s*\w+\s+\w+\s*\([^)]*\)\s*{", RegexOptions.CultureInvariant, TimeSpan.FromSeconds(2));
-            var methodMatches = methodPattern.Matches(contents);
-            foreach (Match match in methodMatches)
-            {
-                var startIndex = match.Index;
-                var braceCount = 0;
-                var lineCount = 0;
-                var inMethod = false;
-
-                for (var i = startIndex; i < contents.Length; i++)
-                {
-                    if (contents[i] == '{')
-                    {
-                        braceCount++;
-                        inMethod = true;
-                    }
-                    else if (contents[i] == '}')
-                    {
-                        braceCount--;
-                        if (braceCount == 0 && inMethod)
-                            break;
-                    }
-                    else if (contents[i] == '\n' && inMethod)
-                    {
-                        lineCount++;
-                    }
-                }
-
-                if (lineCount > 50)
-                {
-                    errors.Add("WARNING: Method is very long, consider breaking it into smaller methods");
-                    break; // Only report once
-                }
-            }
-
-            // Check for proper exception handling
-            if (contents.Contains("catch") && contents.Contains("catch()"))
-            {
-                errors.Add("WARNING: Empty catch blocks should be avoided");
-            }
-
-            // Check for proper async/await usage
-            if (contents.Contains("async ") && !contents.Contains("await"))
-            {
-                errors.Add("WARNING: Async method should contain await or return Task");
-            }
-
-            // Check for hardcoded tags and layers
-            if (contents.Contains("\"Player\"") || contents.Contains("\"Enemy\""))
-            {
-                errors.Add("WARNING: Consider using constants for tags instead of hardcoded strings");
-            }
-        }
-
-        //TODO: A easier way for users to update incorrect scripts (now duplicated with the updateScript method and need to also update server side, put aside for now)
-        /// <summary>
-        /// Public method to validate script syntax with configurable validation level
-        /// Returns detailed validation results including errors and warnings
-        /// </summary>
-        // public static object ValidateScript(JObject @params)
-        // {
-        //     string contents = @params["contents"]?.ToString();
-        //     string validationLevel = @params["validationLevel"]?.ToString() ?? "standard";
-
-        //     if (string.IsNullOrEmpty(contents))
-        //     {
-        //         return Response.Error("Contents parameter is required for validation.");
-        //     }
-
-        //     // Parse validation level
-        //     ValidationLevel level = ValidationLevel.Standard;
-        //     switch (validationLevel.ToLower())
-        //     {
-        //         case "basic": level = ValidationLevel.Basic; break;
-        //         case "standard": level = ValidationLevel.Standard; break;
-        //         case "comprehensive": level = ValidationLevel.Comprehensive; break;
-        //         case "strict": level = ValidationLevel.Strict; break;
-        //         default:
-        //             return Response.Error($"Invalid validation level: '{validationLevel}'. Valid levels are: basic, standard, comprehensive, strict.");
-        //     }
-
-        //     // Perform validation
-        //     bool isValid = ValidateScriptSyntax(contents, level, out string[] validationErrors);
-
-        //     var errors = validationErrors?.Where(e => e.StartsWith("ERROR:")).ToArray() ?? new string[0];
-        //     var warnings = validationErrors?.Where(e => e.StartsWith("WARNING:")).ToArray() ?? new string[0];
-
-        //     var result = new
-        //     {
-        //         isValid = isValid,
-        //         validationLevel = validationLevel,
-        //         errorCount = errors.Length,
-        //         warningCount = warnings.Length,
-        //         errors = errors,
-        //         warnings = warnings,
-        //         summary = isValid
-        //             ? (warnings.Length > 0 ? $"Validation passed with {warnings.Length} warnings" : "Validation passed with no issues")
-        //             : $"Validation failed with {errors.Length} errors and {warnings.Length} warnings"
-        //     };
-
-        //     if (isValid)
-        //     {
-        //         return Response.Success("Script validation completed successfully.", result);
-        //     }
-        //     else
-        //     {
-        //         return Response.Error("Script validation failed.", result);
-        //     }
-        // }
-    }
-}
-
-// Debounced refresh/compile scheduler to coalesce bursts of edits
-static class RefreshDebounce
-{
-    private static int _pending;
-    private static readonly object _lock = new object();
-    private static readonly HashSet<string> _paths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-    // The timestamp of the most recent schedule request.
-    private static DateTime _lastRequest;
-
-    // Guard to ensure we only have a single ticking callback running.
-    private static bool _scheduled;
-
-    public static void Schedule(string relPath, TimeSpan window)
-    {
-        // Record that work is pending and track the path in a threadsafe way.
-        Interlocked.Exchange(ref _pending, 1);
-        lock (_lock)
-        {
-            _paths.Add(relPath);
-            _lastRequest = DateTime.UtcNow;
-
-            // If a debounce timer is already scheduled it will pick up the new request.
-            if (_scheduled)
-                return;
-
-            _scheduled = true;
-        }
-
-        // Kick off a ticking callback that waits until the window has elapsed
-        // from the last request before performing the refresh.
-        EditorApplication.delayCall += () => Tick(window);
-        // Nudge the editor loop so ticks run even if the window is unfocused
-        EditorApplication.QueuePlayerLoopUpdate();
-    }
-
-    private static void Tick(TimeSpan window)
-    {
-        bool ready;
-        lock (_lock)
-        {
-            // Only proceed once the debounce window has fully elapsed.
-            ready = (DateTime.UtcNow - _lastRequest) >= window;
-            if (ready)
-            {
-                _scheduled = false;
-            }
-        }
-
-        if (!ready)
-        {
-            // Window has not yet elapsed; check again on the next editor tick.
-            EditorApplication.delayCall += () => Tick(window);
-            return;
-        }
-
-        if (Interlocked.Exchange(ref _pending, 0) == 1)
-        {
-            string[] toImport;
-            lock (_lock) { toImport = _paths.ToArray(); _paths.Clear(); }
-            foreach (var p in toImport)
-            {
-                var sp = ManageScriptRefreshHelpers.SanitizeAssetsPath(p);
-                AssetDatabase.ImportAsset(sp, ImportAssetOptions.ForceUpdate | ImportAssetOptions.ForceSynchronousImport);
-            }
-#if UNITY_EDITOR
-            UnityEditor.Compilation.CompilationPipeline.RequestScriptCompilation();
-#endif
-            // Fallback if needed:
-            // AssetDatabase.Refresh();
-        }
-    }
-}
-
-static class ManageScriptRefreshHelpers
-{
-    public static string SanitizeAssetsPath(string p)
-    {
-        if (string.IsNullOrEmpty(p)) return p;
-        p = p.Replace('\\', '/').Trim();
-        if (p.StartsWith("unity://path/", StringComparison.OrdinalIgnoreCase))
-            p = p.Substring("unity://path/".Length);
-        while (p.StartsWith("Assets/Assets/", StringComparison.OrdinalIgnoreCase))
-            p = p.Substring("Assets/".Length);
-        if (!p.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase))
-            p = "Assets/" + p.TrimStart('/');
-        return p;
-    }
-
-    public static void ScheduleScriptRefresh(string relPath)
-    {
-        var sp = SanitizeAssetsPath(relPath);
-        RefreshDebounce.Schedule(sp, TimeSpan.FromMilliseconds(200));
-    }
-
-    public static void ImportAndRequestCompile(string relPath, bool synchronous = true)
-    {
-        var sp = SanitizeAssetsPath(relPath);
-        var opts = ImportAssetOptions.ForceUpdate;
-        if (synchronous) opts |= ImportAssetOptions.ForceSynchronousImport;
-        AssetDatabase.ImportAsset(sp, opts);
-#if UNITY_EDITOR
-        UnityEditor.Compilation.CompilationPipeline.RequestScriptCompilation();
-#endif
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs b/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/ManualConfigEditorWindow.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,289 +0,0 @@
-using System.Runtime.InteropServices;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Windows
-{
-    // Editor window to display manual configuration instructions
-    public class ManualConfigEditorWindow : EditorWindow
-    {
-        protected string configPath;
-        protected string configJson;
-        protected Vector2 scrollPos;
-        protected bool pathCopied = false;
-        protected bool jsonCopied = false;
-        protected float copyFeedbackTimer = 0;
-        protected McpClient mcpClient;
-
-        public static void ShowWindow(string configPath, string configJson, McpClient mcpClient)
-        {
-            var window = GetWindow<ManualConfigEditorWindow>("Manual Configuration");
-            window.configPath = configPath;
-            window.configJson = configJson;
-            window.mcpClient = mcpClient;
-            window.minSize = new Vector2(500, 400);
-            window.Show();
-        }
-
-        protected virtual void OnGUI()
-        {
-            scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
-
-            // Header with improved styling
-            EditorGUILayout.Space(10);
-            var titleRect = EditorGUILayout.GetControlRect(false, 30);
-            EditorGUI.DrawRect(
-                new Rect(titleRect.x, titleRect.y, titleRect.width, titleRect.height),
-                new Color(0.2f, 0.2f, 0.2f, 0.1f)
-            );
-            GUI.Label(
-                new Rect(titleRect.x + 10, titleRect.y + 6, titleRect.width - 20, titleRect.height),
-                (mcpClient?.name ?? "Unknown") + " Manual Configuration",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.Space(10);
-
-            // Instructions with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            var headerRect = EditorGUILayout.GetControlRect(false, 24);
-            EditorGUI.DrawRect(
-                new Rect(headerRect.x, headerRect.y, headerRect.width, headerRect.height),
-                new Color(0.1f, 0.1f, 0.1f, 0.2f)
-            );
-            GUI.Label(
-                new Rect(
-                    headerRect.x + 8,
-                    headerRect.y + 4,
-                    headerRect.width - 16,
-                    headerRect.height
-                ),
-                "The automatic configuration failed. Please follow these steps:",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.Space(10);
-
-            GUIStyle instructionStyle = new(EditorStyles.wordWrappedLabel)
-            {
-                margin = new RectOffset(10, 10, 5, 5),
-            };
-
-            EditorGUILayout.LabelField(
-                "1. Open " + (mcpClient?.name ?? "Unknown") + " config file by either:",
-                instructionStyle
-            );
-            if (mcpClient?.mcpType == McpTypes.ClaudeDesktop)
-            {
-                EditorGUILayout.LabelField(
-                    "    a) Going to Settings > Developer > Edit Config",
-                    instructionStyle
-                );
-            }
-            else if (mcpClient?.mcpType == McpTypes.Cursor)
-            {
-                EditorGUILayout.LabelField(
-                    "    a) Going to File > Preferences > Cursor Settings > MCP > Add new global MCP server",
-                    instructionStyle
-                );
-            }
-            else if (mcpClient?.mcpType == McpTypes.Windsurf)
-            {
-                EditorGUILayout.LabelField(
-                    "    a) Going to File > Preferences > Windsurf Settings > MCP > Manage MCPs -> View raw config",
-                    instructionStyle
-                );
-            }
-            else if (mcpClient?.mcpType == McpTypes.Kiro)
-            {
-                EditorGUILayout.LabelField(
-                    "    a) Going to File > Settings > Settings > Search for \"MCP\" > Open Workspace MCP Config",
-                    instructionStyle
-                );
-            }
-            EditorGUILayout.LabelField("    OR", instructionStyle);
-            EditorGUILayout.LabelField(
-                "    b) Opening the configuration file at:",
-                instructionStyle
-            );
-
-            // Path section with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-            string displayPath;
-            if (mcpClient != null)
-            {
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    displayPath = mcpClient.windowsConfigPath;
-                }
-                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
-                {
-                    displayPath = string.IsNullOrEmpty(mcpClient.macConfigPath)
-
-                        ? configPath
-
-                        : mcpClient.macConfigPath;
-                }
-                else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
-                {
-                    displayPath = mcpClient.linuxConfigPath;
-                }
-                else
-                {
-                    displayPath = configPath;
-                }
-            }
-            else
-            {
-                displayPath = configPath;
-            }
-
-            // Prevent text overflow by allowing the text field to wrap
-            GUIStyle pathStyle = new(EditorStyles.textField) { wordWrap = true };
-
-            EditorGUILayout.TextField(
-                displayPath,
-                pathStyle,
-                GUILayout.Height(EditorGUIUtility.singleLineHeight)
-            );
-
-            // Copy button with improved styling
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-            GUIStyle copyButtonStyle = new(GUI.skin.button)
-            {
-                padding = new RectOffset(15, 15, 5, 5),
-                margin = new RectOffset(10, 10, 5, 5),
-            };
-
-            if (
-                GUILayout.Button(
-                    "Copy Path",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                EditorGUIUtility.systemCopyBuffer = displayPath;
-                pathCopied = true;
-                copyFeedbackTimer = 2f;
-            }
-
-            if (
-                GUILayout.Button(
-                    "Open File",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                // Open the file using the system's default application
-                System.Diagnostics.Process.Start(
-                    new System.Diagnostics.ProcessStartInfo
-                    {
-                        FileName = displayPath,
-                        UseShellExecute = true,
-                    }
-                );
-            }
-
-            if (pathCopied)
-            {
-                GUIStyle feedbackStyle = new(EditorStyles.label);
-                feedbackStyle.normal.textColor = Color.green;
-                EditorGUILayout.LabelField("Copied!", feedbackStyle, GUILayout.Width(60));
-            }
-
-            EditorGUILayout.EndHorizontal();
-            EditorGUILayout.EndVertical();
-
-            EditorGUILayout.Space(10);
-
-            EditorGUILayout.LabelField(
-                "2. Paste the following JSON configuration:",
-                instructionStyle
-            );
-
-            // JSON section with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            // Improved text area for JSON with syntax highlighting colors
-            GUIStyle jsonStyle = new(EditorStyles.textArea)
-            {
-                font = EditorStyles.boldFont,
-                wordWrap = true,
-            };
-            jsonStyle.normal.textColor = new Color(0.3f, 0.6f, 0.9f); // Syntax highlighting blue
-
-            // Draw the JSON in a text area with a taller height for better readability
-            EditorGUILayout.TextArea(configJson, jsonStyle, GUILayout.Height(200));
-
-            // Copy JSON button with improved styling
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-
-            if (
-                GUILayout.Button(
-                    "Copy JSON",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                EditorGUIUtility.systemCopyBuffer = configJson;
-                jsonCopied = true;
-                copyFeedbackTimer = 2f;
-            }
-
-            if (jsonCopied)
-            {
-                GUIStyle feedbackStyle = new(EditorStyles.label);
-                feedbackStyle.normal.textColor = Color.green;
-                EditorGUILayout.LabelField("Copied!", feedbackStyle, GUILayout.Width(60));
-            }
-
-            EditorGUILayout.EndHorizontal();
-            EditorGUILayout.EndVertical();
-
-            EditorGUILayout.Space(10);
-            EditorGUILayout.LabelField(
-                "3. Save the file and restart " + (mcpClient?.name ?? "Unknown"),
-                instructionStyle
-            );
-
-            EditorGUILayout.EndVertical();
-
-            EditorGUILayout.Space(10);
-
-            // Close button at the bottom
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-            if (GUILayout.Button("Close", GUILayout.Height(30), GUILayout.Width(100)))
-            {
-                Close();
-            }
-            GUILayout.FlexibleSpace();
-            EditorGUILayout.EndHorizontal();
-
-            EditorGUILayout.EndScrollView();
-        }
-
-        protected virtual void Update()
-        {
-            // Handle the feedback message timer
-            if (copyFeedbackTimer > 0)
-            {
-                copyFeedbackTimer -= Time.deltaTime;
-                if (copyFeedbackTimer <= 0)
-                {
-                    pathCopied = false;
-                    jsonCopied = false;
-                    Repaint();
-                }
-            }
-        }
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs b/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/MCPConfigServer.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,19 +0,0 @@
-using System;
-using Newtonsoft.Json;
-
-namespace MCPForUnity.Editor.Models
-{
-    [Serializable]
-    public class McpConfigServer
-    {
-        [JsonProperty("command")]
-        public string command;
-
-        [JsonProperty("args")]
-        public string[] args;
-
-        // VSCode expects a transport type; include only when explicitly set
-        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
-        public string type;
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Data/McpClients.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Data/McpClients.cs b/Packages/UnityMcpBridge/Editor/Data/McpClients.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Data/McpClients.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,176 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Data
-{
-    public class McpClients
-    {
-        public List<McpClient> clients = new()
-        {
-            // 1) Cursor
-            new()
-            {
-                name = "Cursor",
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".cursor",
-                    "mcp.json"
-                ),
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".cursor",
-                    "mcp.json"
-                ),
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".cursor",
-                    "mcp.json"
-                ),
-                mcpType = McpTypes.Cursor,
-                configStatus = "Not Configured",
-            },
-            // 2) Claude Code
-            new()
-            {
-                name = "Claude Code",
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".claude.json"
-                ),
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".claude.json"
-                ),
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".claude.json"
-                ),
-                mcpType = McpTypes.ClaudeCode,
-                configStatus = "Not Configured",
-            },
-            // 3) Windsurf
-            new()
-            {
-                name = "Windsurf",
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".codeium",
-                    "windsurf",
-                    "mcp_config.json"
-                ),
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".codeium",
-                    "windsurf",
-                    "mcp_config.json"
-                ),
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".codeium",
-                    "windsurf",
-                    "mcp_config.json"
-                ),
-                mcpType = McpTypes.Windsurf,
-                configStatus = "Not Configured",
-            },
-            // 4) Claude Desktop
-            new()
-            {
-                name = "Claude Desktop",
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
-                    "Claude",
-                    "claude_desktop_config.json"
-                ),
-
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    "Library",
-                    "Application Support",
-                    "Claude",
-                    "claude_desktop_config.json"
-                ),
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".config",
-                    "Claude",
-                    "claude_desktop_config.json"
-                ),
-
-                mcpType = McpTypes.ClaudeDesktop,
-                configStatus = "Not Configured",
-            },
-            // 5) VSCode GitHub Copilot
-            new()
-            {
-                name = "VSCode GitHub Copilot",
-                // Windows path is canonical under %AppData%\Code\User
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
-                    "Code",
-                    "User",
-                    "mcp.json"
-                ),
-                // macOS: ~/Library/Application Support/Code/User/mcp.json
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    "Library",
-                    "Application Support",
-                    "Code",
-                    "User",
-                    "mcp.json"
-                ),
-                // Linux: ~/.config/Code/User/mcp.json
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".config",
-                    "Code",
-                    "User",
-                    "mcp.json"
-                ),
-                mcpType = McpTypes.VSCode,
-                configStatus = "Not Configured",
-            },
-            // 3) Kiro
-            new()
-            {
-                name = "Kiro",
-                windowsConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".kiro",
-                    "settings",
-                    "mcp.json"
-                ),
-                macConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".kiro",
-                    "settings",
-                    "mcp.json"
-                ),
-                linuxConfigPath = Path.Combine(
-                    Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
-                    ".kiro",
-                    "settings",
-                    "mcp.json"
-                ),
-                mcpType = McpTypes.Kiro,
-                configStatus = "Not Configured",
-            },
-        };
-
-        // Initialize status enums after construction
-        public McpClients()
-        {
-            foreach (var client in clients)
-            {
-                if (client.configStatus == "Not Configured")
-                {
-                    client.status = McpStatus.NotConfigured;
-                }
-            }
-        }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Models/Command.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/Command.cs.meta b/Packages/UnityMcpBridge/Editor/Models/Command.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/Command.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 6754c84e5deb74749bc3a19e0c9aa280
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs b/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,36 +0,0 @@
-using System;
-using Newtonsoft.Json;
-
-namespace MCPForUnity.Editor.Models
-{
-    [Serializable]
-    public class ServerConfig
-    {
-        [JsonProperty("unity_host")]
-        public string unityHost = "localhost";
-
-        [JsonProperty("unity_port")]
-        public int unityPort;
-
-        [JsonProperty("mcp_port")]
-        public int mcpPort;
-
-        [JsonProperty("connection_timeout")]
-        public float connectionTimeout;
-
-        [JsonProperty("buffer_size")]
-        public int bufferSize;
-
-        [JsonProperty("log_level")]
-        public string logLevel;
-
-        [JsonProperty("log_format")]
-        public string logFormat;
-
-        [JsonProperty("max_retries")]
-        public int maxRetries;
-
-        [JsonProperty("retry_delay")]
-        public float retryDelay;
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,613 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.IO;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEditorInternal; // Required for tag management
-using UnityEngine;
-using MCPForUnity.Editor.Helpers; // For Response class
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles operations related to controlling and querying the Unity Editor state,
-    /// including managing Tags and Layers.
-    /// </summary>
-    public static class ManageEditor
-    {
-        // Constant for starting user layer index
-        private const int FirstUserLayerIndex = 8;
-
-        // Constant for total layer count
-        private const int TotalLayerCount = 32;
-
-        /// <summary>
-        /// Main handler for editor management actions.
-        /// </summary>
-        public static object HandleCommand(JObject @params)
-        {
-            var action = @params["action"]?.ToString().ToLower();
-            // Parameters for specific actions
-            var tagName = @params["tagName"]?.ToString();
-            var layerName = @params["layerName"]?.ToString();
-            var waitForCompletion = @params["waitForCompletion"]?.ToObject<bool>() ?? false; // Example - not used everywhere
-
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-
-            // Route action
-            switch (action)
-            {
-                // Play Mode Control
-                case "play":
-                    try
-                    {
-                        if (!EditorApplication.isPlaying)
-                        {
-                            EditorApplication.isPlaying = true;
-                            return Response.Success("Entered play mode.");
-                        }
-                        return Response.Success("Already in play mode.");
-                    }
-                    catch (Exception e)
-                    {
-                        return Response.Error($"Error entering play mode: {e.Message}");
-                    }
-                case "pause":
-                    try
-                    {
-                        if (EditorApplication.isPlaying)
-                        {
-                            EditorApplication.isPaused = !EditorApplication.isPaused;
-                            return Response.Success(
-                                EditorApplication.isPaused ? "Game paused." : "Game resumed."
-                            );
-                        }
-                        return Response.Error("Cannot pause/resume: Not in play mode.");
-                    }
-                    catch (Exception e)
-                    {
-                        return Response.Error($"Error pausing/resuming game: {e.Message}");
-                    }
-                case "stop":
-                    try
-                    {
-                        if (EditorApplication.isPlaying)
-                        {
-                            EditorApplication.isPlaying = false;
-                            return Response.Success("Exited play mode.");
-                        }
-                        return Response.Success("Already stopped (not in play mode).");
-                    }
-                    catch (Exception e)
-                    {
-                        return Response.Error($"Error stopping play mode: {e.Message}");
-                    }
-
-                // Editor State/Info
-                case "get_state":
-                    return GetEditorState();
-                case "get_project_root":
-                    return GetProjectRoot();
-                case "get_windows":
-                    return GetEditorWindows();
-                case "get_active_tool":
-                    return GetActiveTool();
-                case "get_selection":
-                    return GetSelection();
-                case "set_active_tool":
-                    var toolName = @params["toolName"]?.ToString();
-                    if (string.IsNullOrEmpty(toolName))
-                        return Response.Error("'toolName' parameter required for set_active_tool.");
-                    return SetActiveTool(toolName);
-
-                // Tag Management
-                case "add_tag":
-                    if (string.IsNullOrEmpty(tagName))
-                        return Response.Error("'tagName' parameter required for add_tag.");
-                    return AddTag(tagName);
-                case "remove_tag":
-                    if (string.IsNullOrEmpty(tagName))
-                        return Response.Error("'tagName' parameter required for remove_tag.");
-                    return RemoveTag(tagName);
-                case "get_tags":
-                    return GetTags(); // Helper to list current tags
-
-                // Layer Management
-                case "add_layer":
-                    if (string.IsNullOrEmpty(layerName))
-                        return Response.Error("'layerName' parameter required for add_layer.");
-                    return AddLayer(layerName);
-                case "remove_layer":
-                    if (string.IsNullOrEmpty(layerName))
-                        return Response.Error("'layerName' parameter required for remove_layer.");
-                    return RemoveLayer(layerName);
-                case "get_layers":
-                    return GetLayers(); // Helper to list current layers
-
-                // --- Settings (Example) ---
-                // case "set_resolution":
-                //     int? width = @params["width"]?.ToObject<int?>();
-                //     int? height = @params["height"]?.ToObject<int?>();
-                //     if (!width.HasValue || !height.HasValue) return Response.Error("'width' and 'height' parameters required.");
-                //     return SetGameViewResolution(width.Value, height.Value);
-                // case "set_quality":
-                //     // Handle string name or int index
-                //     return SetQualityLevel(@params["qualityLevel"]);
-
-                default:
-                    return Response.Error(
-                        $"Unknown action: '{action}'. Supported actions include play, pause, stop, get_state, get_project_root, get_windows, get_active_tool, get_selection, set_active_tool, add_tag, remove_tag, get_tags, add_layer, remove_layer, get_layers."
-                    );
-            }
-        }
-
-        // --- Editor State/Info Methods ---
-        private static object GetEditorState()
-        {
-            try
-            {
-                var state = new
-                {
-                    EditorApplication.isPlaying,
-                    EditorApplication.isPaused,
-                    EditorApplication.isCompiling,
-                    EditorApplication.isUpdating,
-                    EditorApplication.applicationPath,
-                    EditorApplication.applicationContentsPath,
-                    EditorApplication.timeSinceStartup,
-                };
-                return Response.Success("Retrieved editor state.", state);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting editor state: {e.Message}");
-            }
-        }
-
-        private static object GetProjectRoot()
-        {
-            try
-            {
-                // Application.dataPath points to <Project>/Assets
-                var assetsPath = Application.dataPath.Replace('\\', '/');
-                var projectRoot = Directory.GetParent(assetsPath)?.FullName.Replace('\\', '/');
-                if (string.IsNullOrEmpty(projectRoot))
-                {
-                    return Response.Error("Could not determine project root from Application.dataPath");
-                }
-                return Response.Success("Project root resolved.", new { projectRoot });
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting project root: {e.Message}");
-            }
-        }
-
-        private static object GetEditorWindows()
-        {
-            try
-            {
-                // Get all types deriving from EditorWindow
-                var windowTypes = AppDomain
-                    .CurrentDomain.GetAssemblies()
-                    .SelectMany(assembly => assembly.GetTypes())
-                    .Where(type => type.IsSubclassOf(typeof(EditorWindow)))
-                    .ToList();
-
-                var openWindows = new List<object>();
-
-                // Find currently open instances
-                // Resources.FindObjectsOfTypeAll seems more reliable than GetWindow for finding *all* open windows
-                var allWindows = Resources.FindObjectsOfTypeAll<EditorWindow>();
-
-                foreach (var window in allWindows)
-                {
-                    if (window == null)
-                        continue; // Skip potentially destroyed windows
-
-                    try
-                    {
-                        openWindows.Add(
-                            new
-                            {
-                                title = window.titleContent.text,
-                                typeName = window.GetType().FullName,
-                                isFocused = EditorWindow.focusedWindow == window,
-                                position = new
-                                {
-                                    window.position.x,
-                                    window.position.y,
-                                    window.position.width,
-                                    window.position.height,
-                                },
-                                instanceID = window.GetInstanceID(),
-                            }
-                        );
-                    }
-                    catch (Exception ex)
-                    {
-                        Debug.LogWarning(
-                            $"Could not get info for window {window.GetType().Name}: {ex.Message}"
-                        );
-                    }
-                }
-
-                return Response.Success("Retrieved list of open editor windows.", openWindows);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting editor windows: {e.Message}");
-            }
-        }
-
-        private static object GetActiveTool()
-        {
-            try
-            {
-                var currentTool = UnityEditor.Tools.current;
-                var toolName = currentTool.ToString(); // Enum to string
-                var customToolActive = UnityEditor.Tools.current == Tool.Custom; // Check if a custom tool is active
-                var activeToolName = customToolActive
-                    ? EditorTools.GetActiveToolName()
-                    : toolName; // Get custom name if needed
-
-                var toolInfo = new
-                {
-                    activeTool = activeToolName,
-                    isCustom = customToolActive,
-                    pivotMode = UnityEditor.Tools.pivotMode.ToString(),
-                    pivotRotation = UnityEditor.Tools.pivotRotation.ToString(),
-                    handleRotation = UnityEditor.Tools.handleRotation.eulerAngles, // Euler for simplicity
-                    UnityEditor.Tools.handlePosition,
-                };
-
-                return Response.Success("Retrieved active tool information.", toolInfo);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting active tool: {e.Message}");
-            }
-        }
-
-        private static object SetActiveTool(string toolName)
-        {
-            try
-            {
-                Tool targetTool;
-                if (Enum.TryParse<Tool>(toolName, true, out targetTool)) // Case-insensitive parse
-                {
-                    // Check if it's a valid built-in tool
-                    if (targetTool != Tool.None && targetTool <= Tool.Custom) // Tool.Custom is the last standard tool
-                    {
-                        UnityEditor.Tools.current = targetTool;
-                        return Response.Success($"Set active tool to '{targetTool}'.");
-                    }
-                    else
-                    {
-                        return Response.Error(
-                            $"Cannot directly set tool to '{toolName}'. It might be None, Custom, or invalid."
-                        );
-                    }
-                }
-                else
-                {
-                    // Potentially try activating a custom tool by name here if needed
-                    // This often requires specific editor scripting knowledge for that tool.
-                    return Response.Error(
-                        $"Could not parse '{toolName}' as a standard Unity Tool (View, Move, Rotate, Scale, Rect, Transform, Custom)."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error setting active tool: {e.Message}");
-            }
-        }
-
-        private static object GetSelection()
-        {
-            try
-            {
-                var selectionInfo = new
-                {
-                    activeObject = Selection.activeObject?.name,
-                    activeGameObject = Selection.activeGameObject?.name,
-                    activeTransform = Selection.activeTransform?.name,
-                    Selection.activeInstanceID,
-                    Selection.count,
-                    objects = Selection
-                        .objects.Select(obj => new
-                        {
-                            obj?.name,
-                            type = obj?.GetType().FullName,
-                            instanceID = obj?.GetInstanceID(),
-                        })
-                        .ToList(),
-                    gameObjects = Selection
-                        .gameObjects.Select(go => new
-                        {
-                            go?.name,
-                            instanceID = go?.GetInstanceID(),
-                        })
-                        .ToList(),
-                    Selection.assetGUIDs, // GUIDs for selected assets in Project view
-                };
-
-                return Response.Success("Retrieved current selection details.", selectionInfo);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Error getting selection: {e.Message}");
-            }
-        }
-
-        // --- Tag Management Methods ---
-
-        private static object AddTag(string tagName)
-        {
-            if (string.IsNullOrWhiteSpace(tagName))
-                return Response.Error("Tag name cannot be empty or whitespace.");
-
-            // Check if tag already exists
-            if (InternalEditorUtility.tags.Contains(tagName))
-            {
-                return Response.Error($"Tag '{tagName}' already exists.");
-            }
-
-            try
-            {
-                // Add the tag using the internal utility
-                InternalEditorUtility.AddTag(tagName);
-                // Force save assets to ensure the change persists in the TagManager asset
-                AssetDatabase.SaveAssets();
-                return Response.Success($"Tag '{tagName}' added successfully.");
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to add tag '{tagName}': {e.Message}");
-            }
-        }
-
-        private static object RemoveTag(string tagName)
-        {
-            if (string.IsNullOrWhiteSpace(tagName))
-                return Response.Error("Tag name cannot be empty or whitespace.");
-            if (tagName.Equals("Untagged", StringComparison.OrdinalIgnoreCase))
-                return Response.Error("Cannot remove the built-in 'Untagged' tag.");
-
-            // Check if tag exists before attempting removal
-            if (!InternalEditorUtility.tags.Contains(tagName))
-            {
-                return Response.Error($"Tag '{tagName}' does not exist.");
-            }
-
-            try
-            {
-                // Remove the tag using the internal utility
-                InternalEditorUtility.RemoveTag(tagName);
-                // Force save assets
-                AssetDatabase.SaveAssets();
-                return Response.Success($"Tag '{tagName}' removed successfully.");
-            }
-            catch (Exception e)
-            {
-                // Catch potential issues if the tag is somehow in use or removal fails
-                return Response.Error($"Failed to remove tag '{tagName}': {e.Message}");
-            }
-        }
-
-        private static object GetTags()
-        {
-            try
-            {
-                var tags = InternalEditorUtility.tags;
-                return Response.Success("Retrieved current tags.", tags);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to retrieve tags: {e.Message}");
-            }
-        }
-
-        // --- Layer Management Methods ---
-
-        private static object AddLayer(string layerName)
-        {
-            if (string.IsNullOrWhiteSpace(layerName))
-                return Response.Error("Layer name cannot be empty or whitespace.");
-
-            // Access the TagManager asset
-            var tagManager = GetTagManager();
-            if (tagManager == null)
-                return Response.Error("Could not access TagManager asset.");
-
-            var layersProp = tagManager.FindProperty("layers");
-            if (layersProp == null || !layersProp.isArray)
-                return Response.Error("Could not find 'layers' property in TagManager.");
-
-            // Check if layer name already exists (case-insensitive check recommended)
-            for (var i = 0; i < TotalLayerCount; i++)
-            {
-                var layerSP = layersProp.GetArrayElementAtIndex(i);
-                if (
-                    layerSP != null
-                    && layerName.Equals(layerSP.stringValue, StringComparison.OrdinalIgnoreCase)
-                )
-                {
-                    return Response.Error($"Layer '{layerName}' already exists at index {i}.");
-                }
-            }
-
-            // Find the first empty user layer slot (indices 8 to 31)
-            var firstEmptyUserLayer = -1;
-            for (var i = FirstUserLayerIndex; i < TotalLayerCount; i++)
-            {
-                var layerSP = layersProp.GetArrayElementAtIndex(i);
-                if (layerSP != null && string.IsNullOrEmpty(layerSP.stringValue))
-                {
-                    firstEmptyUserLayer = i;
-                    break;
-                }
-            }
-
-            if (firstEmptyUserLayer == -1)
-            {
-                return Response.Error("No empty User Layer slots available (8-31 are full).");
-            }
-
-            // Assign the name to the found slot
-            try
-            {
-                var targetLayerSP = layersProp.GetArrayElementAtIndex(
-                    firstEmptyUserLayer
-                );
-                targetLayerSP.stringValue = layerName;
-                // Apply the changes to the TagManager asset
-                tagManager.ApplyModifiedProperties();
-                // Save assets to make sure it's written to disk
-                AssetDatabase.SaveAssets();
-                return Response.Success(
-                    $"Layer '{layerName}' added successfully to slot {firstEmptyUserLayer}."
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to add layer '{layerName}': {e.Message}");
-            }
-        }
-
-        private static object RemoveLayer(string layerName)
-        {
-            if (string.IsNullOrWhiteSpace(layerName))
-                return Response.Error("Layer name cannot be empty or whitespace.");
-
-            // Access the TagManager asset
-            var tagManager = GetTagManager();
-            if (tagManager == null)
-                return Response.Error("Could not access TagManager asset.");
-
-            var layersProp = tagManager.FindProperty("layers");
-            if (layersProp == null || !layersProp.isArray)
-                return Response.Error("Could not find 'layers' property in TagManager.");
-
-            // Find the layer by name (must be user layer)
-            var layerIndexToRemove = -1;
-            for (var i = FirstUserLayerIndex; i < TotalLayerCount; i++) // Start from user layers
-            {
-                var layerSP = layersProp.GetArrayElementAtIndex(i);
-                // Case-insensitive comparison is safer
-                if (
-                    layerSP != null
-                    && layerName.Equals(layerSP.stringValue, StringComparison.OrdinalIgnoreCase)
-                )
-                {
-                    layerIndexToRemove = i;
-                    break;
-                }
-            }
-
-            if (layerIndexToRemove == -1)
-            {
-                return Response.Error($"User layer '{layerName}' not found.");
-            }
-
-            // Clear the name for that index
-            try
-            {
-                var targetLayerSP = layersProp.GetArrayElementAtIndex(
-                    layerIndexToRemove
-                );
-                targetLayerSP.stringValue = string.Empty; // Set to empty string to remove
-                // Apply the changes
-                tagManager.ApplyModifiedProperties();
-                // Save assets
-                AssetDatabase.SaveAssets();
-                return Response.Success(
-                    $"Layer '{layerName}' (slot {layerIndexToRemove}) removed successfully."
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to remove layer '{layerName}': {e.Message}");
-            }
-        }
-
-        private static object GetLayers()
-        {
-            try
-            {
-                var layers = new Dictionary<int, string>();
-                for (var i = 0; i < TotalLayerCount; i++)
-                {
-                    var layerName = LayerMask.LayerToName(i);
-                    if (!string.IsNullOrEmpty(layerName)) // Only include layers that have names
-                    {
-                        layers.Add(i, layerName);
-                    }
-                }
-                return Response.Success("Retrieved current named layers.", layers);
-            }
-            catch (Exception e)
-            {
-                return Response.Error($"Failed to retrieve layers: {e.Message}");
-            }
-        }
-
-        // --- Helper Methods ---
-
-        /// <summary>
-        /// Gets the SerializedObject for the TagManager asset.
-        /// </summary>
-        private static SerializedObject GetTagManager()
-        {
-            try
-            {
-                // Load the TagManager asset from the ProjectSettings folder
-                var tagManagerAssets = AssetDatabase.LoadAllAssetsAtPath(
-                    "ProjectSettings/TagManager.asset"
-                );
-                if (tagManagerAssets == null || tagManagerAssets.Length == 0)
-                {
-                    Debug.LogError("[ManageEditor] TagManager.asset not found in ProjectSettings.");
-                    return null;
-                }
-                // The first object in the asset file should be the TagManager
-                return new SerializedObject(tagManagerAssets[0]);
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ManageEditor] Error accessing TagManager.asset: {e.Message}");
-                return null;
-            }
-        }
-
-        // --- Example Implementations for Settings ---
-        /*
-        private static object SetGameViewResolution(int width, int height) { ... }
-        private static object SetQualityLevel(JToken qualityLevelToken) { ... }
-        */
-    }
-
-    // Helper class to get custom tool names (remains the same)
-    internal static class EditorTools
-    {
-        public static string GetActiveToolName()
-        {
-            // This is a placeholder. Real implementation depends on how custom tools
-            // are registered and tracked in the specific Unity project setup.
-            // It might involve checking static variables, calling methods on specific tool managers, etc.
-            if (UnityEditor.Tools.current == Tool.Custom)
-            {
-                // Example: Check a known custom tool manager
-                // if (MyCustomToolManager.IsActive) return MyCustomToolManager.ActiveToolName;
-                return "Unknown Custom Tool";
-            }
-            return UnityEditor.Tools.current.ToString();
-        }
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageScene.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: b6ddda47f4077e74fbb5092388cefcc2
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor.meta b/Packages/UnityMcpBridge/Editor.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: 31e7fac5858840340a75cc6df0ad3d9e
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ExecuteMenuItem.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 896e8045986eb0d449ee68395479f1d6
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageQueue.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: 88a92c49ccb9157a78ff36ee02ea28ca
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs b/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/GameObjectSerializer.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,521 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using UnityEngine;
-using MCPForUnity.Runtime.Serialization; // For Converters
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Handles serialization of GameObjects and Components for MCP responses.
-    /// Includes reflection helpers and caching for performance.
-    /// </summary>
-    public static class GameObjectSerializer
-    {
-        // --- Data Serialization ---
-
-        /// <summary>
-        /// Creates a serializable representation of a GameObject.
-        /// </summary>
-        public static object GetGameObjectData(GameObject go)
-        {
-            if (go == null)
-                return null;
-            return new
-            {
-                go.name,
-                instanceID = go.GetInstanceID(),
-                go.tag,
-                go.layer,
-                go.activeSelf,
-                go.activeInHierarchy,
-                go.isStatic,
-                scenePath = go.scene.path, // Identify which scene it belongs to
-                transform = new // Serialize transform components carefully to avoid JSON issues
-                {
-                    // Serialize Vector3 components individually to prevent self-referencing loops.
-                    // The default serializer can struggle with properties like Vector3.normalized.
-                    position = new
-                    {
-                        go.transform.position.x,
-                        go.transform.position.y,
-                        go.transform.position.z,
-                    },
-                    localPosition = new
-                    {
-                        go.transform.localPosition.x,
-                        go.transform.localPosition.y,
-                        go.transform.localPosition.z,
-                    },
-                    rotation = new
-                    {
-                        go.transform.rotation.eulerAngles.x,
-                        go.transform.rotation.eulerAngles.y,
-                        go.transform.rotation.eulerAngles.z,
-                    },
-                    localRotation = new
-                    {
-                        go.transform.localRotation.eulerAngles.x,
-                        go.transform.localRotation.eulerAngles.y,
-                        go.transform.localRotation.eulerAngles.z,
-                    },
-                    scale = new
-                    {
-                        go.transform.localScale.x,
-                        go.transform.localScale.y,
-                        go.transform.localScale.z,
-                    },
-                    forward = new
-                    {
-                        go.transform.forward.x,
-                        go.transform.forward.y,
-                        go.transform.forward.z,
-                    },
-                    up = new
-                    {
-                        go.transform.up.x,
-                        go.transform.up.y,
-                        go.transform.up.z,
-                    },
-                    right = new
-                    {
-                        go.transform.right.x,
-                        go.transform.right.y,
-                        go.transform.right.z,
-                    },
-                },
-                parentInstanceID = go.transform.parent?.gameObject.GetInstanceID() ?? 0, // 0 if no parent
-                // Optionally include components, but can be large
-                // components = go.GetComponents<Component>().Select(c => GetComponentData(c)).ToList()
-                // Or just component names:
-                componentNames = go.GetComponents<Component>()
-                    .Select(c => c.GetType().FullName)
-                    .ToList(),
-            };
-        }
-
-        // --- Metadata Caching for Reflection ---
-        private class CachedMetadata
-        {
-            public readonly List<PropertyInfo> SerializableProperties;
-            public readonly List<FieldInfo> SerializableFields;
-
-            public CachedMetadata(List<PropertyInfo> properties, List<FieldInfo> fields)
-            {
-                SerializableProperties = properties;
-                SerializableFields = fields;
-            }
-        }
-        // Key becomes Tuple<Type, bool>
-        private static readonly Dictionary<Tuple<Type, bool>, CachedMetadata> _metadataCache = new Dictionary<Tuple<Type, bool>, CachedMetadata>();
-        // --- End Metadata Caching ---
-
-        /// <summary>
-        /// Creates a serializable representation of a Component, attempting to serialize
-        /// public properties and fields using reflection, with caching and control over non-public fields.
-        /// </summary>
-        // Add the flag parameter here
-        public static object GetComponentData(Component c, bool includeNonPublicSerializedFields = true)
-        {
-            // --- Add Early Logging ---
-            // Debug.Log($"[GetComponentData] Starting for component: {c?.GetType()?.FullName ?? "null"} (ID: {c?.GetInstanceID() ?? 0})");
-            // --- End Early Logging ---
-
-            if (c == null) return null;
-            var componentType = c.GetType();
-
-            // --- Special handling for Transform to avoid reflection crashes and problematic properties ---
-            if (componentType == typeof(Transform))
-            {
-                var tr = c as Transform;
-                // Debug.Log($"[GetComponentData] Manually serializing Transform (ID: {tr.GetInstanceID()})");
-                return new Dictionary<string, object>
-                {
-                    { "typeName", componentType.FullName },
-                    { "instanceID", tr.GetInstanceID() },
-                    // Manually extract known-safe properties. Avoid Quaternion 'rotation' and 'lossyScale'.
-                    { "position", CreateTokenFromValue(tr.position, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "localPosition", CreateTokenFromValue(tr.localPosition, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "eulerAngles", CreateTokenFromValue(tr.eulerAngles, typeof(Vector3))?.ToObject<object>() ?? new JObject() }, // Use Euler angles
-                    { "localEulerAngles", CreateTokenFromValue(tr.localEulerAngles, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "localScale", CreateTokenFromValue(tr.localScale, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "right", CreateTokenFromValue(tr.right, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "up", CreateTokenFromValue(tr.up, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "forward", CreateTokenFromValue(tr.forward, typeof(Vector3))?.ToObject<object>() ?? new JObject() },
-                    { "parentInstanceID", tr.parent?.gameObject.GetInstanceID() ?? 0 },
-                    { "rootInstanceID", tr.root?.gameObject.GetInstanceID() ?? 0 },
-                    { "childCount", tr.childCount },
-                    // Include standard Object/Component properties
-                    { "name", tr.name },
-                    { "tag", tr.tag },
-                    { "gameObjectInstanceID", tr.gameObject?.GetInstanceID() ?? 0 },
-                };
-            }
-            // --- End Special handling for Transform ---
-
-            // --- Special handling for Camera to avoid matrix-related crashes ---
-            if (componentType == typeof(Camera))
-            {
-                var cam = c as Camera;
-                var cameraProperties = new Dictionary<string, object>();
-
-                // List of safe properties to serialize
-                var safeProperties = new Dictionary<string, Func<object>>
-                {
-                    { "nearClipPlane", () => cam.nearClipPlane },
-                    { "farClipPlane", () => cam.farClipPlane },
-                    { "fieldOfView", () => cam.fieldOfView },
-                    { "renderingPath", () => (int)cam.renderingPath },
-                    { "actualRenderingPath", () => (int)cam.actualRenderingPath },
-                    { "allowHDR", () => cam.allowHDR },
-                    { "allowMSAA", () => cam.allowMSAA },
-                    { "allowDynamicResolution", () => cam.allowDynamicResolution },
-                    { "forceIntoRenderTexture", () => cam.forceIntoRenderTexture },
-                    { "orthographicSize", () => cam.orthographicSize },
-                    { "orthographic", () => cam.orthographic },
-                    { "opaqueSortMode", () => (int)cam.opaqueSortMode },
-                    { "transparencySortMode", () => (int)cam.transparencySortMode },
-                    { "depth", () => cam.depth },
-                    { "aspect", () => cam.aspect },
-                    { "cullingMask", () => cam.cullingMask },
-                    { "eventMask", () => cam.eventMask },
-                    { "backgroundColor", () => cam.backgroundColor },
-                    { "clearFlags", () => (int)cam.clearFlags },
-                    { "stereoEnabled", () => cam.stereoEnabled },
-                    { "stereoSeparation", () => cam.stereoSeparation },
-                    { "stereoConvergence", () => cam.stereoConvergence },
-                    { "enabled", () => cam.enabled },
-                    { "name", () => cam.name },
-                    { "tag", () => cam.tag },
-                    { "gameObject", () => new { cam.gameObject.name, instanceID = cam.gameObject.GetInstanceID() } },
-                };
-
-                foreach (var prop in safeProperties)
-                {
-                    try
-                    {
-                        var value = prop.Value();
-                        if (value != null)
-                        {
-                            AddSerializableValue(cameraProperties, prop.Key, value.GetType(), value);
-                        }
-                    }
-                    catch (Exception)
-                    {
-                        // Silently skip any property that fails
-                        continue;
-                    }
-                }
-
-                return new Dictionary<string, object>
-                {
-                    { "typeName", componentType.FullName },
-                    { "instanceID", cam.GetInstanceID() },
-                    { "properties", cameraProperties },
-                };
-            }
-            // --- End Special handling for Camera ---
-
-            var data = new Dictionary<string, object>
-            {
-                { "typeName", componentType.FullName },
-                { "instanceID", c.GetInstanceID() },
-            };
-
-            // --- Get Cached or Generate Metadata (using new cache key) ---
-            var cacheKey = new Tuple<Type, bool>(componentType, includeNonPublicSerializedFields);
-            if (!_metadataCache.TryGetValue(cacheKey, out var cachedData))
-            {
-                var propertiesToCache = new List<PropertyInfo>();
-                var fieldsToCache = new List<FieldInfo>();
-
-                // Traverse the hierarchy from the component type up to MonoBehaviour
-                var currentType = componentType;
-                while (currentType != null && currentType != typeof(MonoBehaviour) && currentType != typeof(object))
-                {
-                    // Get properties declared only at the current type level
-                    var propFlags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
-                    foreach (var propInfo in currentType.GetProperties(propFlags))
-                    {
-                        // Basic filtering (readable, not indexer, not transform which is handled elsewhere)
-                        if (!propInfo.CanRead || propInfo.GetIndexParameters().Length > 0 || propInfo.Name == "transform") continue;
-                        // Add if not already added (handles overrides - keep the most derived version)
-                        if (!propertiesToCache.Any(p => p.Name == propInfo.Name)) {
-                             propertiesToCache.Add(propInfo);
-                        }
-                    }
-
-                    // Get fields declared only at the current type level (both public and non-public)
-                    var fieldFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
-                    var declaredFields = currentType.GetFields(fieldFlags);
-
-                    // Process the declared Fields for caching
-                    foreach (var fieldInfo in declaredFields)
-                    {
-                        if (fieldInfo.Name.EndsWith("k__BackingField")) continue; // Skip backing fields
-
-                         // Add if not already added (handles hiding - keep the most derived version)
-                         if (fieldsToCache.Any(f => f.Name == fieldInfo.Name)) continue;
-
-                        var shouldInclude = false;
-                        if (includeNonPublicSerializedFields)
-                        {
-                            // If TRUE, include Public OR NonPublic with [SerializeField]
-                            shouldInclude = fieldInfo.IsPublic || (fieldInfo.IsPrivate && fieldInfo.IsDefined(typeof(SerializeField), inherit: false));
-                        }
-                        else // includeNonPublicSerializedFields is FALSE
-                        {
-                            // If FALSE, include ONLY if it is explicitly Public.
-                            shouldInclude = fieldInfo.IsPublic;
-                        }
-
-                        if (shouldInclude)
-                        {
-                            fieldsToCache.Add(fieldInfo);
-                        }
-                    }
-
-                    // Move to the base type
-                    currentType = currentType.BaseType;
-                }
-                // --- End Hierarchy Traversal ---
-
-                cachedData = new CachedMetadata(propertiesToCache, fieldsToCache);
-                _metadataCache[cacheKey] = cachedData; // Add to cache with combined key
-            }
-            // --- End Get Cached or Generate Metadata ---
-
-            // --- Use cached metadata ---
-            var serializablePropertiesOutput = new Dictionary<string, object>();
-
-            // --- Add Logging Before Property Loop ---
-            // Debug.Log($"[GetComponentData] Starting property loop for {componentType.Name}...");
-            // --- End Logging Before Property Loop ---
-
-            // Use cached properties
-            foreach (var propInfo in cachedData.SerializableProperties)
-            {
-                var propName = propInfo.Name;
-
-                // --- Skip known obsolete/problematic Component shortcut properties ---
-                var skipProperty = propName == "rigidbody" || propName == "rigidbody2D" || propName == "camera" ||
-                    propName == "light" || propName == "animation" || propName == "constantForce" ||
-                    propName == "renderer" || propName == "audio" || propName == "networkView" ||
-                    propName == "collider" || propName == "collider2D" || propName == "hingeJoint" ||
-                    propName == "particleSystem" ||
-                    // Also skip potentially problematic Matrix properties prone to cycles/errors
-                    propName == "worldToLocalMatrix" || propName == "localToWorldMatrix";
-                // --- End Skip Generic Properties ---
-
-                // --- Skip specific potentially problematic Camera properties ---
-                if (componentType == typeof(Camera) &&
-                    (propName == "pixelRect" ||
-                        propName == "rect" ||
-                        propName == "cullingMatrix" ||
-                        propName == "useOcclusionCulling" ||
-                        propName == "worldToCameraMatrix" ||
-                        propName == "projectionMatrix" ||
-                        propName == "nonJitteredProjectionMatrix" ||
-                        propName == "previousViewProjectionMatrix" ||
-                        propName == "cameraToWorldMatrix"))
-                {
-                    // Debug.Log($"[GetComponentData] Explicitly skipping Camera property: {propName}");
-                    skipProperty = true;
-                }
-                // --- End Skip Camera Properties ---
-
-                // --- Skip specific potentially problematic Transform properties ---
-                if (componentType == typeof(Transform) &&
-                    (propName == "lossyScale" ||
-                        propName == "rotation" ||
-                        propName == "worldToLocalMatrix" ||
-                        propName == "localToWorldMatrix"))
-                {
-                    // Debug.Log($"[GetComponentData] Explicitly skipping Transform property: {propName}");
-                    skipProperty = true;
-                }
-                // --- End Skip Transform Properties ---
-
-                // Skip if flagged
-                if (skipProperty)
-                {
-                    continue;
-                }
-
-                try
-                {
-                    // --- Add detailed logging ---
-                    // Debug.Log($"[GetComponentData] Accessing: {componentType.Name}.{propName}");
-                    // --- End detailed logging ---
-                    var value    = propInfo.GetValue(c);
-                    var propType = propInfo.PropertyType;
-                    AddSerializableValue(serializablePropertiesOutput, propName, propType, value);
-                }
-                catch (Exception)
-                {
-                    // Debug.LogWarning($"Could not read property {propName} on {componentType.Name}");
-                }
-            }
-
-            // --- Add Logging Before Field Loop ---
-            // Debug.Log($"[GetComponentData] Starting field loop for {componentType.Name}...");
-            // --- End Logging Before Field Loop ---
-
-            // Use cached fields
-            foreach (var fieldInfo in cachedData.SerializableFields)
-            {
-                 try
-                {
-                    // --- Add detailed logging for fields ---
-                    // Debug.Log($"[GetComponentData] Accessing Field: {componentType.Name}.{fieldInfo.Name}");
-                    // --- End detailed logging for fields ---
-                    var value = fieldInfo.GetValue(c);
-                    var fieldName = fieldInfo.Name;
-                    var fieldType = fieldInfo.FieldType;
-                    AddSerializableValue(serializablePropertiesOutput, fieldName, fieldType, value);
-                }
-                catch (Exception)
-                {
-                     // Debug.LogWarning($"Could not read field {fieldInfo.Name} on {componentType.Name}");
-                }
-            }
-            // --- End Use cached metadata ---
-
-            if (serializablePropertiesOutput.Count > 0)
-            {
-                data["properties"] = serializablePropertiesOutput;
-            }
-
-            return data;
-        }
-
-        // Helper function to decide how to serialize different types
-        private static void AddSerializableValue(Dictionary<string, object> dict, string name, Type type, object value)
-        {
-            // Simplified: Directly use CreateTokenFromValue which uses the serializer
-            if (value == null)
-            {
-                dict[name] = null;
-                return;
-            }
-
-            try
-            {
-                // Use the helper that employs our custom serializer settings
-                var token = CreateTokenFromValue(value, type);
-                if (token != null) // Check if serialization succeeded in the helper
-                {
-                    // Convert JToken back to a basic object structure for the dictionary
-                    dict[name] = ConvertJTokenToPlainObject(token);
-                }
-                // If token is null, it means serialization failed and a warning was logged.
-            }
-            catch (Exception e)
-            {
-                // Catch potential errors during JToken conversion or addition to dictionary
-                Debug.LogWarning($"[AddSerializableValue] Error processing value for '{name}' (Type: {type.FullName}): {e.Message}. Skipping.");
-            }
-        }
-
-        // Helper to convert JToken back to basic object structure
-        private static object ConvertJTokenToPlainObject(JToken token)
-        {
-            if (token == null) return null;
-
-            switch (token.Type)
-            {
-                case JTokenType.Object:
-                    var objDict = new Dictionary<string, object>();
-                    foreach (var prop in ((JObject)token).Properties())
-                    {
-                        objDict[prop.Name] = ConvertJTokenToPlainObject(prop.Value);
-                    }
-                    return objDict;
-
-                case JTokenType.Array:
-                    var list = new List<object>();
-                    foreach (var item in (JArray)token)
-                    {
-                        list.Add(ConvertJTokenToPlainObject(item));
-                    }
-                    return list;
-
-                case JTokenType.Integer:
-                    return token.ToObject<long>(); // Use long for safety
-                case JTokenType.Float:
-                    return token.ToObject<double>(); // Use double for safety
-                case JTokenType.String:
-                    return token.ToObject<string>();
-                case JTokenType.Boolean:
-                    return token.ToObject<bool>();
-                case JTokenType.Date:
-                     return token.ToObject<DateTime>();
-                 case JTokenType.Guid:
-                     return token.ToObject<Guid>();
-                 case JTokenType.Uri:
-                     return token.ToObject<Uri>();
-                 case JTokenType.TimeSpan:
-                     return token.ToObject<TimeSpan>();
-                case JTokenType.Bytes:
-                     return token.ToObject<byte[]>();
-                case JTokenType.Null:
-                    return null;
-                 case JTokenType.Undefined:
-                     return null; // Treat undefined as null
-
-                default:
-                    // Fallback for simple value types not explicitly listed
-                    if (token is JValue jValue && jValue.Value != null)
-                    {
-                        return jValue.Value;
-                    }
-                    // Debug.LogWarning($"Unsupported JTokenType encountered: {token.Type}. Returning null.");
-                    return null;
-            }
-        }
-
-        // --- Define custom JsonSerializerSettings for OUTPUT ---
-        private static readonly JsonSerializerSettings _outputSerializerSettings = new JsonSerializerSettings
-        {
-            Converters = new List<JsonConverter>
-            {
-                new Vector3Converter(),
-                new Vector2Converter(),
-                new QuaternionConverter(),
-                new ColorConverter(),
-                new RectConverter(),
-                new BoundsConverter(),
-                new UnityEngineObjectConverter(), // Handles serialization of references
-            },
-            ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
-            // ContractResolver = new DefaultContractResolver { NamingStrategy = new CamelCaseNamingStrategy() } // Example if needed
-        };
-        private static readonly JsonSerializer _outputSerializer = JsonSerializer.Create(_outputSerializerSettings);
-        // --- End Define custom JsonSerializerSettings ---
-
-        // Helper to create JToken using the output serializer
-        private static JToken CreateTokenFromValue(object value, Type type)
-        {
-            if (value == null) return JValue.CreateNull();
-
-            try
-            {
-                // Use the pre-configured OUTPUT serializer instance
-                return JToken.FromObject(value, _outputSerializer);
-            }
-            catch (JsonSerializationException e)
-            {
-                Debug.LogWarning($"[GameObjectSerializer] Newtonsoft.Json Error serializing value of type {type.FullName}: {e.Message}. Skipping property/field.");
-                return null; // Indicate serialization failure
-            }
-            catch (Exception e) // Catch other unexpected errors
-            {
-                Debug.LogWarning($"[GameObjectSerializer] Unexpected error serializing value of type {type.FullName}: {e}. Skipping property/field.");
-                return null; // Indicate serialization failure
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageScript.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 626d2d44668019a45ae52e9ee066b7ec
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/AssemblyInfo.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs b/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/AssemblyInfo.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,3 +0,0 @@
-using System.Runtime.CompilerServices;
-
-[assembly: InternalsVisibleTo("MCPForUnityTests.EditMode")]
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs.meta b/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/MCPForUnityEditorWindow.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 4f740bec3a8d04716adeab35c412a15f
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/UnityMcpServer~/src/server_version.txt
===================================================================
diff --git a/Packages/UnityMcpBridge/UnityMcpServer~/src/server_version.txt b/Packages/UnityMcpBridge/UnityMcpServer~/src/server_version.txt
deleted file mode 100644
--- a/Packages/UnityMcpBridge/UnityMcpServer~/src/server_version.txt	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,1 +0,0 @@
-3.3.0
Index: Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PackageInstaller.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 19e6eaa637484e9fa19f9a0459809de2
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs b/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,569 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Helpers; // For Response class
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles reading and clearing Unity Editor console log entries.
-    /// Uses reflection to access internal LogEntry methods/properties.
-    /// </summary>
-    public static class ReadConsole
-    {
-        // (Calibration removed)
-
-        // Reflection members for accessing internal LogEntry data
-        // private static MethodInfo _getEntriesMethod; // Removed as it's unused and fails reflection
-        private static MethodInfo _startGettingEntriesMethod;
-        private static MethodInfo _endGettingEntriesMethod; // Renamed from _stopGettingEntriesMethod, trying End...
-        private static MethodInfo _clearMethod;
-        private static MethodInfo _getCountMethod;
-        private static MethodInfo _getEntryMethod;
-        private static FieldInfo _modeField;
-        private static FieldInfo _messageField;
-        private static FieldInfo _fileField;
-        private static FieldInfo _lineField;
-        private static FieldInfo _instanceIdField;
-
-        // Note: Timestamp is not directly available in LogEntry; need to parse message or find alternative?
-
-        // Static constructor for reflection setup
-        static ReadConsole()
-        {
-            try
-            {
-                var logEntriesType = typeof(EditorApplication).Assembly.GetType(
-                    "UnityEditor.LogEntries"
-                );
-                if (logEntriesType == null)
-                    throw new Exception("Could not find internal type UnityEditor.LogEntries");
-
-
-
-                // Include NonPublic binding flags as internal APIs might change accessibility
-                var staticFlags =
-                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
-                var instanceFlags =
-                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
-
-                _startGettingEntriesMethod = logEntriesType.GetMethod(
-                    "StartGettingEntries",
-                    staticFlags
-                );
-                if (_startGettingEntriesMethod == null)
-                    throw new Exception("Failed to reflect LogEntries.StartGettingEntries");
-
-                // Try reflecting EndGettingEntries based on warning message
-                _endGettingEntriesMethod = logEntriesType.GetMethod(
-                    "EndGettingEntries",
-                    staticFlags
-                );
-                if (_endGettingEntriesMethod == null)
-                    throw new Exception("Failed to reflect LogEntries.EndGettingEntries");
-
-                _clearMethod = logEntriesType.GetMethod("Clear", staticFlags);
-                if (_clearMethod == null)
-                    throw new Exception("Failed to reflect LogEntries.Clear");
-
-                _getCountMethod = logEntriesType.GetMethod("GetCount", staticFlags);
-                if (_getCountMethod == null)
-                    throw new Exception("Failed to reflect LogEntries.GetCount");
-
-                _getEntryMethod = logEntriesType.GetMethod("GetEntryInternal", staticFlags);
-                if (_getEntryMethod == null)
-                    throw new Exception("Failed to reflect LogEntries.GetEntryInternal");
-
-                var logEntryType = typeof(EditorApplication).Assembly.GetType(
-                    "UnityEditor.LogEntry"
-                );
-                if (logEntryType == null)
-                    throw new Exception("Could not find internal type UnityEditor.LogEntry");
-
-                _modeField = logEntryType.GetField("mode", instanceFlags);
-                if (_modeField == null)
-                    throw new Exception("Failed to reflect LogEntry.mode");
-
-                _messageField = logEntryType.GetField("message", instanceFlags);
-                if (_messageField == null)
-                    throw new Exception("Failed to reflect LogEntry.message");
-
-                _fileField = logEntryType.GetField("file", instanceFlags);
-                if (_fileField == null)
-                    throw new Exception("Failed to reflect LogEntry.file");
-
-                _lineField = logEntryType.GetField("line", instanceFlags);
-                if (_lineField == null)
-                    throw new Exception("Failed to reflect LogEntry.line");
-
-                _instanceIdField = logEntryType.GetField("instanceID", instanceFlags);
-                if (_instanceIdField == null)
-                    throw new Exception("Failed to reflect LogEntry.instanceID");
-
-                // (Calibration removed)
-
-            }
-            catch (Exception e)
-            {
-                Debug.LogError(
-                    $"[ReadConsole] Static Initialization Failed: Could not setup reflection for LogEntries/LogEntry. Console reading/clearing will likely fail. Specific Error: {e.Message}"
-                );
-                // Set members to null to prevent NullReferenceExceptions later, HandleCommand should check this.
-                _startGettingEntriesMethod =
-                    _endGettingEntriesMethod =
-                    _clearMethod =
-                    _getCountMethod =
-                    _getEntryMethod =
-                        null;
-                _modeField = _messageField = _fileField = _lineField = _instanceIdField = null;
-            }
-        }
-
-        // --- Main Handler ---
-
-        public static object HandleCommand(JObject @params)
-        {
-            // Check if ALL required reflection members were successfully initialized.
-            if (
-                _startGettingEntriesMethod == null
-                || _endGettingEntriesMethod == null
-                || _clearMethod == null
-                || _getCountMethod == null
-                || _getEntryMethod == null
-                || _modeField == null
-                || _messageField == null
-                || _fileField == null
-                || _lineField == null
-                || _instanceIdField == null
-            )
-            {
-                // Log the error here as well for easier debugging in Unity Console
-                Debug.LogError(
-                    "[ReadConsole] HandleCommand called but reflection members are not initialized. Static constructor might have failed silently or there's an issue."
-                );
-                return Response.Error(
-                    "ReadConsole handler failed to initialize due to reflection errors. Cannot access console logs."
-                );
-            }
-
-            var action = @params["action"]?.ToString().ToLower() ?? "get";
-
-            try
-            {
-                if (action == "clear")
-                {
-                    return ClearConsole();
-                }
-                else if (action == "get")
-                {
-                    // Extract parameters for 'get'
-                    var types =
-                        (@params["types"] as JArray)?.Select(t => t.ToString().ToLower()).ToList()
-                        ?? new List<string> { "error", "warning", "log" };
-                    var count = @params["count"]?.ToObject<int?>();
-                    var filterText = @params["filterText"]?.ToString();
-                    var sinceTimestampStr = @params["sinceTimestamp"]?.ToString(); // TODO: Implement timestamp filtering
-                    var format = (@params["format"]?.ToString() ?? "detailed").ToLower();
-                    var includeStacktrace =
-                        @params["includeStacktrace"]?.ToObject<bool?>() ?? true;
-
-                    if (types.Contains("all"))
-                    {
-                        types = new List<string> { "error", "warning", "log" }; // Expand 'all'
-                    }
-
-                    if (!string.IsNullOrEmpty(sinceTimestampStr))
-                    {
-                        Debug.LogWarning(
-                            "[ReadConsole] Filtering by 'since_timestamp' is not currently implemented."
-                        );
-                        // Need a way to get timestamp per log entry.
-                    }
-
-                    return GetConsoleEntries(types, count, filterText, format, includeStacktrace);
-                }
-                else
-                {
-                    return Response.Error(
-                        $"Unknown action: '{action}'. Valid actions are 'get' or 'clear'."
-                    );
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ReadConsole] Action '{action}' failed: {e}");
-                return Response.Error($"Internal error processing action '{action}': {e.Message}");
-            }
-        }
-
-        // --- Action Implementations ---
-
-        private static object ClearConsole()
-        {
-            try
-            {
-                _clearMethod.Invoke(null, null); // Static method, no instance, no parameters
-                return Response.Success("Console cleared successfully.");
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ReadConsole] Failed to clear console: {e}");
-                return Response.Error($"Failed to clear console: {e.Message}");
-            }
-        }
-
-        private static object GetConsoleEntries(
-            List<string> types,
-            int? count,
-            string filterText,
-            string format,
-            bool includeStacktrace
-        )
-        {
-            var formattedEntries = new List<object>();
-            var retrievedCount = 0;
-
-            try
-            {
-                // LogEntries requires calling Start/Stop around GetEntries/GetEntryInternal
-                _startGettingEntriesMethod.Invoke(null, null);
-
-                var totalEntries = (int)_getCountMethod.Invoke(null, null);
-                // Create instance to pass to GetEntryInternal - Ensure the type is correct
-                var logEntryType = typeof(EditorApplication).Assembly.GetType(
-                    "UnityEditor.LogEntry"
-                );
-                if (logEntryType == null)
-                    throw new Exception(
-                        "Could not find internal type UnityEditor.LogEntry during GetConsoleEntries."
-                    );
-                var logEntryInstance = Activator.CreateInstance(logEntryType);
-
-                for (var i = 0; i < totalEntries; i++)
-                {
-                    // Get the entry data into our instance using reflection
-                    _getEntryMethod.Invoke(null, new object[] { i, logEntryInstance });
-
-                    // Extract data using reflection
-                    var mode = (int)_modeField.GetValue(logEntryInstance);
-                    var message = (string)_messageField.GetValue(logEntryInstance);
-                    var file = (string)_fileField.GetValue(logEntryInstance);
-
-                    var line = (int)_lineField.GetValue(logEntryInstance);
-                    // int instanceId = (int)_instanceIdField.GetValue(logEntryInstance);
-
-                    if (string.IsNullOrEmpty(message))
-                    {
-                        continue; // Skip empty messages
-                    }
-
-                    // (Calibration removed)
-
-                    // --- Filtering ---
-                    // Prefer classifying severity from message/stacktrace; fallback to mode bits if needed
-                    var unityType = InferTypeFromMessage(message);
-                    var isExplicitDebug = IsExplicitDebugLog(message);
-                    if (!isExplicitDebug && unityType == LogType.Log)
-                    {
-                        unityType = GetLogTypeFromMode(mode);
-                    }
-
-                    bool want;
-                    // Treat Exception/Assert as errors for filtering convenience
-                    if (unityType == LogType.Exception)
-                    {
-                        want = types.Contains("error") || types.Contains("exception");
-                    }
-                    else if (unityType == LogType.Assert)
-                    {
-                        want = types.Contains("error") || types.Contains("assert");
-                    }
-                    else
-                    {
-                        want = types.Contains(unityType.ToString().ToLowerInvariant());
-                    }
-
-                    if (!want) continue;
-
-                    // Filter by text (case-insensitive)
-                    if (
-                        !string.IsNullOrEmpty(filterText)
-                        && message.IndexOf(filterText, StringComparison.OrdinalIgnoreCase) < 0
-                    )
-                    {
-                        continue;
-                    }
-
-                    // TODO: Filter by timestamp (requires timestamp data)
-
-                    // --- Formatting ---
-                    var stackTrace = includeStacktrace ? ExtractStackTrace(message) : null;
-                    // Get first line if stack is present and requested, otherwise use full message
-                    var messageOnly =
-                        (includeStacktrace && !string.IsNullOrEmpty(stackTrace))
-                            ? message.Split(
-                                new[] { '\n', '\r' },
-                                StringSplitOptions.RemoveEmptyEntries
-                            )[0]
-                            : message;
-
-                    object formattedEntry = null;
-                    switch (format)
-                    {
-                        case "plain":
-                            formattedEntry = messageOnly;
-                            break;
-                        case "json":
-                        case "detailed": // Treat detailed as json for structured return
-                        default:
-                            formattedEntry = new
-                            {
-                                type = unityType.ToString(),
-                                message = messageOnly,
-                                file,
-                                line,
-                                // timestamp = "", // TODO
-                                stackTrace, // Will be null if includeStacktrace is false or no stack found
-                            };
-                            break;
-                    }
-
-                    formattedEntries.Add(formattedEntry);
-                    retrievedCount++;
-
-                    // Apply count limit (after filtering)
-                    if (count.HasValue && retrievedCount >= count.Value)
-                    {
-                        break;
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ReadConsole] Error while retrieving log entries: {e}");
-                // Ensure EndGettingEntries is called even if there's an error during iteration
-                try
-                {
-                    _endGettingEntriesMethod.Invoke(null, null);
-                }
-                catch
-                { /* Ignore nested exception */
-                }
-                return Response.Error($"Error retrieving log entries: {e.Message}");
-            }
-            finally
-            {
-                // Ensure we always call EndGettingEntries
-                try
-                {
-                    _endGettingEntriesMethod.Invoke(null, null);
-                }
-                catch (Exception e)
-                {
-                    Debug.LogError($"[ReadConsole] Failed to call EndGettingEntries: {e}");
-                    // Don't return error here as we might have valid data, but log it.
-                }
-            }
-
-            // Return the filtered and formatted list (might be empty)
-            return Response.Success(
-                $"Retrieved {formattedEntries.Count} log entries.",
-                formattedEntries
-            );
-        }
-
-        // --- Internal Helpers ---
-
-        // Mapping bits from LogEntry.mode. These may vary by Unity version.
-        private const int ModeBitError = 1 << 0;
-        private const int ModeBitAssert = 1 << 1;
-        private const int ModeBitWarning = 1 << 2;
-        private const int ModeBitLog = 1 << 3;
-        private const int ModeBitException = 1 << 4; // often combined with Error bits
-        private const int ModeBitScriptingError = 1 << 9;
-        private const int ModeBitScriptingWarning = 1 << 10;
-        private const int ModeBitScriptingLog = 1 << 11;
-        private const int ModeBitScriptingException = 1 << 18;
-        private const int ModeBitScriptingAssertion = 1 << 22;
-
-        private static LogType GetLogTypeFromMode(int mode)
-        {
-            // Preserve Unity's real type (no remapping); bits may vary by version
-            if ((mode & (ModeBitException | ModeBitScriptingException)) != 0) return LogType.Exception;
-            if ((mode & (ModeBitError | ModeBitScriptingError)) != 0) return LogType.Error;
-            if ((mode & (ModeBitAssert | ModeBitScriptingAssertion)) != 0) return LogType.Assert;
-            if ((mode & (ModeBitWarning | ModeBitScriptingWarning)) != 0) return LogType.Warning;
-            return LogType.Log;
-        }
-
-        // (Calibration helpers removed)
-
-        /// <summary>
-        /// Classifies severity using message/stacktrace content. Works across Unity versions.
-        /// </summary>
-        private static LogType InferTypeFromMessage(string fullMessage)
-        {
-            if (string.IsNullOrEmpty(fullMessage)) return LogType.Log;
-
-            // Fast path: look for explicit Debug API names in the appended stack trace
-            // e.g., "UnityEngine.Debug:LogError (object)" or "LogWarning"
-            if (fullMessage.IndexOf("LogError", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Error;
-            if (fullMessage.IndexOf("LogWarning", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Warning;
-
-            // Compiler diagnostics (C#): "warning CSxxxx" / "error CSxxxx"
-            if (fullMessage.IndexOf(" warning CS", StringComparison.OrdinalIgnoreCase) >= 0
-                || fullMessage.IndexOf(": warning CS", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Warning;
-            if (fullMessage.IndexOf(" error CS", StringComparison.OrdinalIgnoreCase) >= 0
-                || fullMessage.IndexOf(": error CS", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Error;
-
-            // Exceptions (avoid misclassifying compiler diagnostics)
-            if (fullMessage.IndexOf("Exception", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Exception;
-
-            // Unity assertions
-            if (fullMessage.IndexOf("Assertion", StringComparison.OrdinalIgnoreCase) >= 0)
-                return LogType.Assert;
-
-            return LogType.Log;
-        }
-
-        private static bool IsExplicitDebugLog(string fullMessage)
-        {
-            if (string.IsNullOrEmpty(fullMessage)) return false;
-            if (fullMessage.IndexOf("Debug:Log (", StringComparison.OrdinalIgnoreCase) >= 0) return true;
-            if (fullMessage.IndexOf("UnityEngine.Debug:Log (", StringComparison.OrdinalIgnoreCase) >= 0) return true;
-            return false;
-        }
-
-        /// <summary>
-        /// Applies the "one level lower" remapping for filtering, like the old version.
-        /// This ensures compatibility with the filtering logic that expects remapped types.
-        /// </summary>
-        private static LogType GetRemappedTypeForFiltering(LogType unityType)
-        {
-            switch (unityType)
-            {
-                case LogType.Error:
-                    return LogType.Warning; // Error becomes Warning
-                case LogType.Warning:
-                    return LogType.Log; // Warning becomes Log
-                case LogType.Assert:
-                    return LogType.Assert; // Assert remains Assert
-                case LogType.Log:
-                    return LogType.Log; // Log remains Log
-                case LogType.Exception:
-                    return LogType.Warning; // Exception becomes Warning
-                default:
-                    return LogType.Log; // Default fallback
-            }
-        }
-
-        /// <summary>
-        /// Attempts to extract the stack trace part from a log message.
-        /// Unity log messages often have the stack trace appended after the main message,
-        /// starting on a new line and typically indented or beginning with "at ".
-        /// </summary>
-        /// <param name="fullMessage">The complete log message including potential stack trace.</param>
-        /// <returns>The extracted stack trace string, or null if none is found.</returns>
-        private static string ExtractStackTrace(string fullMessage)
-        {
-            if (string.IsNullOrEmpty(fullMessage))
-                return null;
-
-            // Split into lines, removing empty ones to handle different line endings gracefully.
-            // Using StringSplitOptions.None might be better if empty lines matter within stack trace, but RemoveEmptyEntries is usually safer here.
-            var lines = fullMessage.Split(
-                new[] { '\r', '\n' },
-                StringSplitOptions.RemoveEmptyEntries
-            );
-
-            // If there's only one line or less, there's no separate stack trace.
-            if (lines.Length <= 1)
-                return null;
-
-            var stackStartIndex = -1;
-
-            // Start checking from the second line onwards.
-            for (var i = 1; i < lines.Length; ++i)
-            {
-                // Performance: TrimStart creates a new string. Consider using IsWhiteSpace check if performance critical.
-                var trimmedLine = lines[i].TrimStart();
-
-                // Check for common stack trace patterns.
-                if (
-                    trimmedLine.StartsWith("at ")
-                    || trimmedLine.StartsWith("UnityEngine.")
-                    || trimmedLine.StartsWith("UnityEditor.")
-                    || trimmedLine.Contains("(at ")
-                    || // Covers "(at Assets/..." pattern
-                    // Heuristic: Check if line starts with likely namespace/class pattern (Uppercase.Something)
-                    (
-                        trimmedLine.Length > 0
-                        && char.IsUpper(trimmedLine[0])
-                        && trimmedLine.Contains('.')
-                    )
-                )
-                {
-                    stackStartIndex = i;
-                    break; // Found the likely start of the stack trace
-                }
-            }
-
-            // If a potential start index was found...
-            if (stackStartIndex > 0)
-            {
-                // Join the lines from the stack start index onwards using standard newline characters.
-                // This reconstructs the stack trace part of the message.
-                return string.Join("\n", lines.Skip(stackStartIndex));
-            }
-
-            // No clear stack trace found based on the patterns.
-            return null;
-        }
-
-        /* LogEntry.mode bits exploration (based on Unity decompilation/observation):
-           May change between versions.
-
-           Basic Types:
-           kError = 1 << 0 (1)
-           kAssert = 1 << 1 (2)
-           kWarning = 1 << 2 (4)
-           kLog = 1 << 3 (8)
-           kFatal = 1 << 4 (16) - Often treated as Exception/Error
-
-           Modifiers/Context:
-           kAssetImportError = 1 << 7 (128)
-           kAssetImportWarning = 1 << 8 (256)
-           kScriptingError = 1 << 9 (512)
-           kScriptingWarning = 1 << 10 (1024)
-           kScriptingLog = 1 << 11 (2048)
-           kScriptCompileError = 1 << 12 (4096)
-           kScriptCompileWarning = 1 << 13 (8192)
-           kStickyError = 1 << 14 (16384) - Stays visible even after Clear On Play
-           kMayIgnoreLineNumber = 1 << 15 (32768)
-           kReportBug = 1 << 16 (65536) - Shows the "Report Bug" button
-           kDisplayPreviousErrorInStatusBar = 1 << 17 (131072)
-           kScriptingException = 1 << 18 (262144)
-           kDontExtractStacktrace = 1 << 19 (524288) - Hint to the console UI
-           kShouldClearOnPlay = 1 << 20 (1048576) - Default behavior
-           kGraphCompileError = 1 << 21 (2097152)
-           kScriptingAssertion = 1 << 22 (4194304)
-           kVisualScriptingError = 1 << 23 (8388608)
-
-           Example observed values:
-           Log: 2048 (ScriptingLog) or 8 (Log)
-           Warning: 1028 (ScriptingWarning | Warning) or 4 (Warning)
-           Error: 513 (ScriptingError | Error) or 1 (Error)
-           Exception: 262161 (ScriptingException | Error | kFatal?) - Complex combination
-           Assertion: 4194306 (ScriptingAssertion | Assert) or 2 (Assert)
-        */
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers.meta b/Packages/UnityMcpBridge/Editor/Helpers.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: 94cb070dc5e15024da86150b27699ca0
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef b/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/MCPForUnity.Editor.asmdef	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,19 +0,0 @@
-{
-    "name": "MCPForUnity.Editor",
-    "rootNamespace": "MCPForUnity.Editor",
-    "references": [
-        "MCPForUnity.Runtime",
-        "GUID:560b04d1a97f54a46a2660c3cc343a6f"
-    ],
-    "includePlatforms": [
-        "Editor"
-    ],
-    "excludePlatforms": [],
-    "allowUnsafeCode": false,
-    "overrideReferences": false,
-    "precompiledReferences": [],
-    "autoReferenced": true,
-    "defineConstraints": [],
-    "versionDefines": [],
-    "noEngineReferences": false
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/UnityMcpServer~/src/Dockerfile
===================================================================
diff --git a/Packages/UnityMcpBridge/UnityMcpServer~/src/Dockerfile b/Packages/UnityMcpBridge/UnityMcpServer~/src/Dockerfile
deleted file mode 100644
--- a/Packages/UnityMcpBridge/UnityMcpServer~/src/Dockerfile	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,27 +0,0 @@
-FROM python:3.12-slim
-
-# Install required system dependencies
-RUN apt-get update && apt-get install -y --no-install-recommends \
-    git \
-    && rm -rf /var/lib/apt/lists/*
-
-# Set working directory
-WORKDIR /app
-
-# Install uv package manager
-RUN pip install uv
-
-# Copy required files
-COPY config.py /app/
-COPY server.py /app/
-COPY unity_connection.py /app/
-COPY pyproject.toml /app/
-COPY __init__.py /app/
-COPY tools/ /app/tools/
-
-# Install dependencies using uv
-RUN uv pip install --system -e .
-
-
-# Command to run the server
-CMD ["uv", "run", "server.py"] 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs b/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PortManager.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,319 +0,0 @@
-using System;
-using System.IO;
-using UnityEditor;
-using System.Net;
-using System.Net.Sockets;
-using System.Security.Cryptography;
-using System.Text;
-using System.Threading;
-using Newtonsoft.Json;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Manages dynamic port allocation and persistent storage for MCP for Unity
-    /// </summary>
-    public static class PortManager
-    {
-        private static bool IsDebugEnabled()
-        {
-            try { return EditorPrefs.GetBool("MCPForUnity.DebugLogs", false); }
-            catch { return false; }
-        }
-
-        private const int DefaultPort = 6400;
-        private const int MaxPortAttempts = 100;
-        private const string RegistryFileName = "unity-mcp-port.json";
-
-        [Serializable]
-        public class PortConfig
-        {
-            public int unity_port;
-            public string created_date;
-            public string project_path;
-        }
-
-        /// <summary>
-        /// Get the port to use - either from storage or discover a new one
-        /// Will try stored port first, then fallback to discovering new port
-        /// </summary>
-        /// <returns>Port number to use</returns>
-        public static int GetPortWithFallback()
-        {
-            // Try to load stored port first, but only if it's from the current project
-            var storedConfig = GetStoredPortConfig();
-            if (storedConfig != null &&
-                storedConfig.unity_port > 0 &&
-                string.Equals(storedConfig.project_path ?? string.Empty, Application.dataPath ?? string.Empty, StringComparison.OrdinalIgnoreCase) &&
-                IsPortAvailable(storedConfig.unity_port))
-            {
-                if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Using stored port {storedConfig.unity_port} for current project");
-                return storedConfig.unity_port;
-            }
-
-            // If stored port exists but is currently busy, wait briefly for release
-            if (storedConfig != null && storedConfig.unity_port > 0)
-            {
-                if (WaitForPortRelease(storedConfig.unity_port, 1500))
-                {
-                    if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Stored port {storedConfig.unity_port} became available after short wait");
-                    return storedConfig.unity_port;
-                }
-                // Prefer sticking to the same port; let the caller handle bind retries/fallbacks
-                return storedConfig.unity_port;
-            }
-
-            // If no valid stored port, find a new one and save it
-            var newPort = FindAvailablePort();
-            SavePort(newPort);
-            return newPort;
-        }
-
-        /// <summary>
-        /// Discover and save a new available port (used by Auto-Connect button)
-        /// </summary>
-        /// <returns>New available port</returns>
-        public static int DiscoverNewPort()
-        {
-            var newPort = FindAvailablePort();
-            SavePort(newPort);
-            if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Discovered and saved new port: {newPort}");
-            return newPort;
-        }
-
-        /// <summary>
-        /// Find an available port starting from the default port
-        /// </summary>
-        /// <returns>Available port number</returns>
-        private static int FindAvailablePort()
-        {
-            // Always try default port first
-            if (IsPortAvailable(DefaultPort))
-            {
-                if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Using default port {DefaultPort}");
-                return DefaultPort;
-            }
-
-            if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Default port {DefaultPort} is in use, searching for alternative...");
-
-            // Search for alternatives
-            for (var port = DefaultPort + 1; port < DefaultPort + MaxPortAttempts; port++)
-            {
-                if (IsPortAvailable(port))
-                {
-                    if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Found available port {port}");
-                    return port;
-                }
-            }
-
-            throw new Exception($"No available ports found in range {DefaultPort}-{DefaultPort + MaxPortAttempts}");
-        }
-
-        /// <summary>
-        /// Check if a specific port is available for binding
-        /// </summary>
-        /// <param name="port">Port to check</param>
-        /// <returns>True if port is available</returns>
-        public static bool IsPortAvailable(int port)
-        {
-            try
-            {
-                var testListener = new TcpListener(IPAddress.Loopback, port);
-                testListener.Start();
-                testListener.Stop();
-                return true;
-            }
-            catch (SocketException)
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Check if a port is currently being used by MCP for Unity
-        /// This helps avoid unnecessary port changes when Unity itself is using the port
-        /// </summary>
-        /// <param name="port">Port to check</param>
-        /// <returns>True if port appears to be used by MCP for Unity</returns>
-        public static bool IsPortUsedByMCPForUnity(int port)
-        {
-            try
-            {
-                // Try to make a quick connection to see if it's an MCP for Unity server
-                using var client = new TcpClient();
-                var connectTask = client.ConnectAsync(IPAddress.Loopback, port);
-                if (connectTask.Wait(100)) // 100ms timeout
-                {
-                    // If connection succeeded, it's likely the MCP for Unity server
-                    return client.Connected;
-                }
-                return false;
-            }
-            catch
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Wait for a port to become available for a limited amount of time.
-        /// Used to bridge the gap during domain reload when the old listener
-        /// hasn't released the socket yet.
-        /// </summary>
-        private static bool WaitForPortRelease(int port, int timeoutMs)
-        {
-            var waited = 0;
-            const int step = 100;
-            while (waited < timeoutMs)
-            {
-                if (IsPortAvailable(port))
-                {
-                    return true;
-                }
-
-                // If the port is in use by an MCP instance, continue waiting briefly
-                if (!IsPortUsedByMCPForUnity(port))
-                {
-                    // In use by something else; don't keep waiting
-                    return false;
-                }
-
-                Thread.Sleep(step);
-                waited += step;
-            }
-            return IsPortAvailable(port);
-        }
-
-        /// <summary>
-        /// Save port to persistent storage
-        /// </summary>
-        /// <param name="port">Port to save</param>
-        private static void SavePort(int port)
-        {
-            try
-            {
-                var portConfig = new PortConfig
-                {
-                    unity_port = port,
-                    created_date = DateTime.UtcNow.ToString("O"),
-                    project_path = Application.dataPath,
-                };
-
-                var registryDir = GetRegistryDirectory();
-                Directory.CreateDirectory(registryDir);
-
-                var registryFile = GetRegistryFilePath();
-                var json = JsonConvert.SerializeObject(portConfig, Formatting.Indented);
-                // Write to hashed, project-scoped file
-                File.WriteAllText(registryFile, json, new System.Text.UTF8Encoding(false));
-                // Also write to legacy stable filename to avoid hash/case drift across reloads
-                var legacy = Path.Combine(GetRegistryDirectory(), RegistryFileName);
-                File.WriteAllText(legacy, json, new System.Text.UTF8Encoding(false));
-
-                if (IsDebugEnabled()) Debug.Log($"<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Saved port {port} to storage");
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning($"Could not save port to storage: {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Load port from persistent storage
-        /// </summary>
-        /// <returns>Stored port number, or 0 if not found</returns>
-        private static int LoadStoredPort()
-        {
-            try
-            {
-                var registryFile = GetRegistryFilePath();
-
-                if (!File.Exists(registryFile))
-                {
-                    // Backwards compatibility: try the legacy file name
-                    var legacy = Path.Combine(GetRegistryDirectory(), RegistryFileName);
-                    if (!File.Exists(legacy))
-                    {
-                        return 0;
-                    }
-                    registryFile = legacy;
-                }
-
-                var json = File.ReadAllText(registryFile);
-                var portConfig = JsonConvert.DeserializeObject<PortConfig>(json);
-
-                return portConfig?.unity_port ?? 0;
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning($"Could not load port from storage: {ex.Message}");
-                return 0;
-            }
-        }
-
-        /// <summary>
-        /// Get the current stored port configuration
-        /// </summary>
-        /// <returns>Port configuration if exists, null otherwise</returns>
-        public static PortConfig GetStoredPortConfig()
-        {
-            try
-            {
-                var registryFile = GetRegistryFilePath();
-
-                if (!File.Exists(registryFile))
-                {
-                    // Backwards compatibility: try the legacy file
-                    var legacy = Path.Combine(GetRegistryDirectory(), RegistryFileName);
-                    if (!File.Exists(legacy))
-                    {
-                        return null;
-                    }
-                    registryFile = legacy;
-                }
-
-                var json = File.ReadAllText(registryFile);
-                return JsonConvert.DeserializeObject<PortConfig>(json);
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning($"Could not load port config: {ex.Message}");
-                return null;
-            }
-        }
-
-        private static string GetRegistryDirectory()
-        {
-            return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".unity-mcp");
-        }
-
-        private static string GetRegistryFilePath()
-        {
-            var dir = GetRegistryDirectory();
-            var hash = ComputeProjectHash(Application.dataPath);
-            var fileName = $"unity-mcp-port-{hash}.json";
-            return Path.Combine(dir, fileName);
-        }
-
-        private static string ComputeProjectHash(string input)
-        {
-            try
-            {
-                using var sha1 = SHA1.Create();
-                var bytes = Encoding.UTF8.GetBytes(input ?? string.Empty);
-                var hashBytes = sha1.ComputeHash(bytes);
-                var sb = new StringBuilder();
-                foreach (var b in hashBytes)
-                {
-                    sb.Append(b.ToString("x2"));
-                }
-                return sb.ToString()[..8]; // short, sufficient for filenames
-            }
-            catch
-            {
-                return "default";
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/Response.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/Response.cs b/Packages/UnityMcpBridge/Editor/Helpers/Response.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/Response.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,191 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// Provides static methods for creating standardized success and error response objects.
-    /// Ensures consistent JSON structure for communication back to the Python server.
-    /// </summary>
-    public static class Response
-    {
-        /// <summary>
-        /// Creates a standardized success response object.
-        /// </summary>
-        /// <param name="message">A message describing the successful operation.</param>
-        /// <param name="data">Optional additional data to include in the response.</param>
-        /// <returns>An object representing the success response.</returns>
-        public static object Success(string message, object data = null)
-        {
-            if (data != null)
-            {
-                return new
-                {
-                    success = true,
-                    message,
-                    data,
-                };
-            }
-            else
-            {
-                return new { success = true, message };
-            }
-        }
-
-        /// <summary>
-        /// Creates a standardized error response object.
-        /// </summary>
-        /// <param name="errorCodeOrMessage">A message describing the error.</param>
-        /// <param name="data">Optional additional data (e.g., error details) to include.</param>
-        /// <returns>An object representing the error response.</returns>
-        public static object Error(string errorCodeOrMessage, object data = null)
-        {
-            if (data != null)
-            {
-                // Note: The key is "error" for error messages, not "message"
-                return new
-                {
-                    success = false,
-                    // Preserve original behavior while adding a machine-parsable code field.
-                    // If callers pass a code string, it will be echoed in both code and error.
-                    code = errorCodeOrMessage,
-                    error = errorCodeOrMessage,
-                    data,
-                };
-            }
-            else
-            {
-                return new { success = false, code = errorCodeOrMessage, error = errorCodeOrMessage };
-            }
-        }
-
-        /// <summary>
-        /// Creates an enhanced error response with context, suggestions, and related information.
-        /// STUDIO: Enhanced error reporting for better AI assistant interaction.
-        /// </summary>
-        /// <param name="message">Primary error message</param>
-        /// <param name="context">Contextual information about what was being attempted</param>
-        /// <param name="suggestion">Actionable suggestion to resolve the error</param>
-        /// <param name="relatedItems">Array of related items (files, assets, etc.)</param>
-        /// <param name="errorCode">Machine-parsable error code</param>
-        /// <param name="filePath">File path where error occurred (if applicable)</param>
-        /// <param name="lineNumber">Line number where error occurred (if applicable)</param>
-        /// <returns>Enhanced error response object</returns>
-        public static object EnhancedError(
-            string message,
-            string context = null,
-            string suggestion = null,
-            string[] relatedItems = null,
-            string errorCode = null,
-            string filePath = null,
-            int? lineNumber = null)
-        {
-            var errorDetails = new Dictionary<string, object>
-            {
-                { "timestamp", DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC") },
-                { "unity_version", Application.unityVersion },
-                { "platform", Application.platform.ToString() },
-            };
-
-            if (!string.IsNullOrEmpty(context))
-                errorDetails["context"] = context;
-            
-            if (!string.IsNullOrEmpty(suggestion))
-                errorDetails["suggestion"] = suggestion;
-            
-            if (relatedItems != null && relatedItems.Length > 0)
-                errorDetails["related_items"] = relatedItems;
-            
-            if (!string.IsNullOrEmpty(filePath))
-                errorDetails["file_path"] = filePath;
-            
-            if (lineNumber.HasValue)
-                errorDetails["line_number"] = lineNumber.Value;
-
-            return new
-            {
-                success = false,
-                error = message,
-                code = errorCode ?? "STUDIO_ERROR",
-                error_details = errorDetails,
-            };
-        }
-
-        /// <summary>
-        /// Creates an enhanced error response for asset-related operations.
-        /// STUDIO: Specialized error reporting for asset operations.
-        /// </summary>
-        public static object AssetError(string message, string assetPath, string assetType = null, string[] suggestions = null)
-        {
-            var context = $"Asset operation on '{assetPath}'";
-            if (!string.IsNullOrEmpty(assetType))
-                context += $" (type: {assetType})";
-
-            var suggestion = "Check asset path and permissions.";
-            if (suggestions != null && suggestions.Length > 0)
-                suggestion = string.Join(" ", suggestions);
-
-            var relatedItems = GetSimilarAssets(assetPath);
-            
-            return EnhancedError(message, context, suggestion, relatedItems, "ASSET_ERROR", assetPath);
-        }
-
-        /// <summary>
-        /// Creates an enhanced error response for script-related operations.
-        /// STUDIO: Specialized error reporting for script operations.
-        /// </summary>
-        public static object ScriptError(string message, string scriptPath, int? lineNumber = null, string[] suggestions = null)
-        {
-            var context = $"Script operation on '{scriptPath}'";
-            if (lineNumber.HasValue)
-                context += $" at line {lineNumber.Value}";
-
-            var suggestion = "Check script syntax and Unity compilation messages.";
-            if (suggestions != null && suggestions.Length > 0)
-                suggestion = string.Join(" ", suggestions);
-
-            return EnhancedError(message, context, suggestion, null, "SCRIPT_ERROR", scriptPath, lineNumber);
-        }
-
-        /// <summary>
-        /// Helper method to find similar assets when an asset operation fails.
-        /// STUDIO: Provides suggestions for similar assets to help users.
-        /// </summary>
-        private static string[] GetSimilarAssets(string assetPath)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(assetPath))
-                    return new string[0];
-
-                var fileName = System.IO.Path.GetFileNameWithoutExtension(assetPath);
-                var directory = System.IO.Path.GetDirectoryName(assetPath);
-
-                if (string.IsNullOrEmpty(fileName) || string.IsNullOrEmpty(directory))
-                    return new string[0];
-
-                // Find assets with similar names in the same directory
-                var similarAssets = new List<string>();
-
-                if (System.IO.Directory.Exists(directory))
-                {
-                    var files = System.IO.Directory.GetFiles(directory, "*" + fileName + "*", System.IO.SearchOption.TopDirectoryOnly);
-                    foreach (var file in files.Take(3)) // Limit to 3 suggestions
-                    {
-                        var relativePath = file.Replace(Application.dataPath, "Assets");
-                        if (relativePath != assetPath) // Don't include the failed path itself
-                            similarAssets.Add(relativePath);
-                    }
-                }
-
-                return similarAssets.ToArray();
-            }
-            catch
-            {
-                return new string[0]; // Return empty array on any error to avoid cascading failures
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools.meta b/Packages/UnityMcpBridge/Editor/Tools.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,8 +0,0 @@
-fileFormatVersion: 2
-guid: c97b83a6ac92a704b864eef27c3d285b
-folderAsset: yes
-DefaultImporter:
-  externalObjects: {}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ReadConsole.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 46c4f3614ed61f547ba823f0b2790267
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ConfigJsonBuilder.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 5c07c3369f73943919d9e086a81d1dcc
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/McpLog.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,13 +0,0 @@
-fileFormatVersion: 2
-guid: 9e2c3f8a4f4f48d8a4c1b7b8e3f5a1c2
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
-
-
Index: Packages/UnityMcpBridge/Editor/Models/McpStatus.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs.meta b/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: aa63057c9e5282d4887352578bf49971
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/README.md
===================================================================
diff --git a/Packages/UnityMcpBridge/README.md b/Packages/UnityMcpBridge/README.md
deleted file mode 100644
--- a/Packages/UnityMcpBridge/README.md	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,88 +0,0 @@
-# MCP for Unity — Editor Plugin Guide
-
-Use this guide to configure and run MCP for Unity inside the Unity Editor. Installation is covered elsewhere; this document focuses on the Editor window, client configuration, and troubleshooting.
-
-## Open the window
-- Unity menu: Window > MCP for Unity
-
-The window has four areas: Server Status, Unity Bridge, MCP Client Configuration, and Script Validation.
-
----
-
-## Quick start
-1. Open Window > MCP for Unity.
-2. Click “Auto-Setup”.
-3. If prompted:
-   - Select the server folder that contains `server.py` (UnityMcpServer~/src).
-   - Install Python and/or uv if missing.
-   - For Claude Code, ensure the `claude` CLI is installed.
-4. Click “Start Bridge” if the Unity Bridge shows “Stopped”.
-5. Use your MCP client (Cursor, VS Code, Windsurf, Claude Code) to connect.
-
----
-
-## Server Status
-- Status dot and label:
-  - Installed / Installed (Embedded) / Not Installed.
-- Mode and ports:
-  - Mode: Auto or Standard.
-  - Ports: Unity (varies; shown in UI), MCP 6500.
-- Actions:
-  - Auto-Setup: Registers/updates your selected MCP client(s), ensures bridge connectivity. Shows “Connected ✓” after success.
-  - Repair Python Env: Rebuilds a clean Python environment (deletes `.venv`, runs `uv sync`).
-  - Select server folder…: Choose the folder containing `server.py`.
-  - Verify again: Re-checks server presence.
-  - If Python isn’t detected, use “Open Install Instructions”.
-
----
-
-## Unity Bridge
-- Shows Running or Stopped with a status dot.
-- Start/Stop Bridge button toggles the Unity bridge process used by MCP clients to talk to Unity.
-- Tip: After Auto-Setup, the bridge may auto-start in Auto mode.
-
----
-
-## MCP Client Configuration
-- Select Client: Choose your target MCP client (e.g., Cursor, VS Code, Windsurf, Claude Code).
-- Per-client actions:
-  - Cursor / VS Code / Windsurf:
-    - Auto Configure: Writes/updates your config to launch the server via uv:
-      - Command: uv
-      - Args: run --directory <pythonDir> server.py
-    - Manual Setup: Opens a window with a pre-filled JSON snippet to copy/paste into your client config.
-    - Choose `uv` Install Location: If uv isn’t on PATH, select the uv binary.
-    - A compact “Config:” line shows the resolved config file name once uv/server are detected.
-  - Claude Code:
-    - Register with Claude Code / Unregister MCP for Unity with Claude Code.
-    - If the CLI isn’t found, click “Choose Claude Install Location”.
-    - The window displays the resolved Claude CLI path when detected.
-
-Notes:
-- The UI shows a status dot and a short status text (e.g., “Configured”, “uv Not Found”, “Claude Not Found”).
-- Use “Auto Configure” for one-click setup; use “Manual Setup” when you prefer to review/copy config.
-
----
-
-## Script Validation
-- Validation Level options:
-  - Basic — Only syntax checks
-  - Standard — Syntax + Unity practices
-  - Comprehensive — All checks + semantic analysis
-  - Strict — Full semantic validation (requires Roslyn)
-- Pick a level based on your project’s needs. A description is shown under the dropdown.
-
----
-
-## Troubleshooting
-- Python or `uv` not found:
-  - Help: [Fix MCP for Unity with Cursor, VS Code & Windsurf](https://github.com/CoplayDev/unity-mcp/wiki/1.-Fix-Unity-MCP-and-Cursor,-VSCode-&-Windsurf)
-- Claude CLI not found:
-  - Help: [Fix MCP for Unity with Claude Code](https://github.com/CoplayDev/unity-mcp/wiki/2.-Fix-Unity-MCP-and-Claude-Code)
-
----
-
-## Tips
-- Enable “Show Debug Logs” in the header for more details in the Console when diagnosing issues.
-
----
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 7641d7388f0f6634b9d83d34de87b2ee
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs b/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/ServerInstaller.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,739 +0,0 @@
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-using System.Collections.Generic;
-using System.Linq;
-using UnityEditor;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    public static class ServerInstaller
-    {
-        private const string RootFolder = "UnityMCP";
-        private const string ServerFolder = "UnityMcpServer";
-        private const string VersionFileName = "server_version.txt";
-
-        /// <summary>
-        /// Ensures the mcp-for-unity-server is installed locally by copying from the embedded package source.
-        /// No network calls or Git operations are performed.
-        /// </summary>
-        public static void EnsureServerInstalled()
-        {
-            try
-            {
-                var saveLocation = GetSaveLocation();
-                TryCreateMacSymlinkForAppSupport();
-                var destRoot = Path.Combine(saveLocation, ServerFolder);
-                var destSrc = Path.Combine(destRoot, "src");
-
-                // Detect legacy installs and version state (logs)
-                DetectAndLogLegacyInstallStates(destRoot);
-
-                // Resolve embedded source and versions
-                if (!TryGetEmbeddedServerSource(out var embeddedSrc))
-                {
-                    throw new Exception("Could not find embedded UnityMcpServer/src in the package.");
-                }
-                var embeddedVer = ReadVersionFile(Path.Combine(embeddedSrc, VersionFileName)) ?? "unknown";
-                var installedVer = ReadVersionFile(Path.Combine(destSrc, VersionFileName));
-
-                var destHasServer = File.Exists(Path.Combine(destSrc, "server.py"));
-                var needOverwrite = !destHasServer
-                                     || string.IsNullOrEmpty(installedVer)
-                                     || (!string.IsNullOrEmpty(embeddedVer) && CompareSemverSafe(installedVer, embeddedVer) < 0);
-
-                // Ensure destination exists
-                Directory.CreateDirectory(destRoot);
-
-                if (needOverwrite)
-                {
-                    // Copy the entire UnityMcpServer folder (parent of src)
-                    var embeddedRoot = Path.GetDirectoryName(embeddedSrc) ?? embeddedSrc; // go up from src to UnityMcpServer
-                    CopyDirectoryRecursive(embeddedRoot, destRoot);
-                    // Write/refresh version file
-                    try { File.WriteAllText(Path.Combine(destSrc, VersionFileName), embeddedVer ?? "unknown"); } catch { }
-                    McpLog.Info($"Installed/updated server to {destRoot} (version {embeddedVer}).");
-                }
-
-                // Cleanup legacy installs that are missing version or older than embedded
-                foreach (var legacyRoot in GetLegacyRootsForDetection())
-                {
-                    try
-                    {
-                        var legacySrc = Path.Combine(legacyRoot, "src");
-                        if (!File.Exists(Path.Combine(legacySrc, "server.py"))) continue;
-                        var legacyVer = ReadVersionFile(Path.Combine(legacySrc, VersionFileName));
-                        var legacyOlder = string.IsNullOrEmpty(legacyVer)
-                                           || (!string.IsNullOrEmpty(embeddedVer) && CompareSemverSafe(legacyVer, embeddedVer) < 0);
-                        if (legacyOlder)
-                        {
-                            TryKillUvForPath(legacySrc);
-                            try
-                            {
-                                Directory.Delete(legacyRoot, recursive: true);
-                                McpLog.Info($"Removed legacy server at '{legacyRoot}'.");
-                            }
-                            catch (Exception ex)
-                            {
-                                McpLog.Warn($"Failed to remove legacy server at '{legacyRoot}': {ex.Message}");
-                            }
-                        }
-                    }
-                    catch { }
-                }
-
-                // Clear overrides that might point at legacy locations
-                try
-                {
-                    EditorPrefs.DeleteKey("MCPForUnity.ServerSrc");
-                    EditorPrefs.DeleteKey("MCPForUnity.PythonDirOverride");
-                }
-                catch { }
-                return;
-            }
-            catch (Exception ex)
-            {
-                // If a usable server is already present (installed or embedded), don't fail hard—just warn.
-                var hasInstalled = false;
-                try { hasInstalled = File.Exists(Path.Combine(GetServerPath(), "server.py")); } catch { }
-
-                if (hasInstalled || TryGetEmbeddedServerSource(out _))
-                {
-                    McpLog.Warn($"Using existing server; skipped install. Details: {ex.Message}");
-                    return;
-                }
-
-                McpLog.Error($"Failed to ensure server installation: {ex.Message}");
-            }
-        }
-
-        public static string GetServerPath()
-        {
-            return Path.Combine(GetSaveLocation(), ServerFolder, "src");
-        }
-
-        /// <summary>
-        /// Gets the platform-specific save location for the server.
-        /// </summary>
-        private static string GetSaveLocation()
-        {
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                // Use per-user LocalApplicationData for canonical install location
-                var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)
-                                   ?? Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty, "AppData", "Local");
-                return Path.Combine(localAppData, RootFolder);
-            }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
-            {
-                var xdg = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
-                if (string.IsNullOrEmpty(xdg))
-                {
-                    xdg = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty,
-                                       ".local", "share");
-                }
-                return Path.Combine(xdg, RootFolder);
-            }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
-            {
-                // On macOS, use LocalApplicationData (~/Library/Application Support)
-                var localAppSupport = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
-                // Unity/Mono may map LocalApplicationData to ~/.local/share on macOS; normalize to Application Support
-                var looksLikeXdg = !string.IsNullOrEmpty(localAppSupport) && localAppSupport.Replace('\\', '/').Contains("/.local/share");
-                if (string.IsNullOrEmpty(localAppSupport) || looksLikeXdg)
-                {
-                    // Fallback: construct from $HOME
-                    var home = Environment.GetFolderPath(Environment.SpecialFolder.Personal) ?? string.Empty;
-                    localAppSupport = Path.Combine(home, "Library", "Application Support");
-                }
-                TryCreateMacSymlinkForAppSupport();
-                return Path.Combine(localAppSupport, RootFolder);
-            }
-            throw new Exception("Unsupported operating system.");
-        }
-
-        /// <summary>
-        /// On macOS, create a no-spaces symlink ~/Library/AppSupport -> ~/Library/Application Support
-        /// to mitigate arg parsing and quoting issues in some MCP clients.
-        /// Safe to call repeatedly.
-        /// </summary>
-        private static void TryCreateMacSymlinkForAppSupport()
-        {
-            try
-            {
-                if (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX)) return;
-                var home = Environment.GetFolderPath(Environment.SpecialFolder.Personal) ?? string.Empty;
-                if (string.IsNullOrEmpty(home)) return;
-
-                var canonical = Path.Combine(home, "Library", "Application Support");
-                var symlink = Path.Combine(home, "Library", "AppSupport");
-
-                // If symlink exists already, nothing to do
-                if (Directory.Exists(symlink) || File.Exists(symlink)) return;
-
-                // Create symlink only if canonical exists
-                if (!Directory.Exists(canonical)) return;
-
-                // Use 'ln -s' to create a directory symlink (macOS)
-                var psi = new System.Diagnostics.ProcessStartInfo
-                {
-                    FileName = "/bin/ln",
-                    Arguments = $"-s \"{canonical}\" \"{symlink}\"",
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    RedirectStandardError = true,
-                    CreateNoWindow = true,
-                };
-                using var p = System.Diagnostics.Process.Start(psi);
-                p?.WaitForExit(2000);
-            }
-            catch { /* best-effort */ }
-        }
-
-        private static bool IsDirectoryWritable(string path)
-        {
-            try
-            {
-                File.Create(Path.Combine(path, "test.txt")).Dispose();
-                File.Delete(Path.Combine(path, "test.txt"));
-                return true;
-            }
-            catch
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Checks if the server is installed at the specified location.
-        /// </summary>
-        private static bool IsServerInstalled(string location)
-        {
-            return Directory.Exists(location)
-                && File.Exists(Path.Combine(location, ServerFolder, "src", "server.py"));
-        }
-
-        /// <summary>
-        /// Detects legacy installs or older versions and logs findings (no deletion yet).
-        /// </summary>
-        private static void DetectAndLogLegacyInstallStates(string canonicalRoot)
-        {
-            try
-            {
-                var canonicalSrc = Path.Combine(canonicalRoot, "src");
-                // Normalize canonical root for comparisons
-                var normCanonicalRoot = NormalizePathSafe(canonicalRoot);
-                string embeddedSrc = null;
-                TryGetEmbeddedServerSource(out embeddedSrc);
-
-                var embeddedVer = ReadVersionFile(Path.Combine(embeddedSrc ?? string.Empty, VersionFileName));
-                var installedVer = ReadVersionFile(Path.Combine(canonicalSrc, VersionFileName));
-
-                // Legacy paths (macOS/Linux .config; Windows roaming as example)
-                foreach (var legacyRoot in GetLegacyRootsForDetection())
-                {
-                    // Skip logging for the canonical root itself
-                    if (PathsEqualSafe(legacyRoot, normCanonicalRoot))
-                        continue;
-                    var legacySrc = Path.Combine(legacyRoot, "src");
-                    var hasServer = File.Exists(Path.Combine(legacySrc, "server.py"));
-                    var legacyVer = ReadVersionFile(Path.Combine(legacySrc, VersionFileName));
-
-                    if (hasServer)
-                    {
-                        // Case 1: No version file
-                        if (string.IsNullOrEmpty(legacyVer))
-                        {
-                            McpLog.Info("Detected legacy install without version file at: " + legacyRoot, always: false);
-                        }
-
-                        // Case 2: Lives in legacy path
-                        McpLog.Info("Detected legacy install path: " + legacyRoot, always: false);
-
-                        // Case 3: Has version but appears older than embedded
-                        if (!string.IsNullOrEmpty(embeddedVer) && !string.IsNullOrEmpty(legacyVer) && CompareSemverSafe(legacyVer, embeddedVer) < 0)
-                        {
-                            McpLog.Info($"Legacy install version {legacyVer} is older than embedded {embeddedVer}", always: false);
-                        }
-                    }
-                }
-
-                // Also log if canonical is missing version (treated as older)
-                if (Directory.Exists(canonicalRoot))
-                {
-                    if (string.IsNullOrEmpty(installedVer))
-                    {
-                        McpLog.Info("Canonical install missing version file (treat as older). Path: " + canonicalRoot, always: false);
-                    }
-                    else if (!string.IsNullOrEmpty(embeddedVer) && CompareSemverSafe(installedVer, embeddedVer) < 0)
-                    {
-                        McpLog.Info($"Canonical install version {installedVer} is older than embedded {embeddedVer}", always: false);
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                McpLog.Warn("Detect legacy/version state failed: " + ex.Message);
-            }
-        }
-
-        private static string NormalizePathSafe(string path)
-        {
-            try { return string.IsNullOrEmpty(path) ? path : Path.GetFullPath(path.Trim()); }
-            catch { return path; }
-        }
-
-        private static bool PathsEqualSafe(string a, string b)
-        {
-            if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return false;
-            var na = NormalizePathSafe(a);
-            var nb = NormalizePathSafe(b);
-            try
-            {
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    return string.Equals(na, nb, StringComparison.OrdinalIgnoreCase);
-                }
-                return string.Equals(na, nb, StringComparison.Ordinal);
-            }
-            catch { return false; }
-        }
-
-        private static IEnumerable<string> GetLegacyRootsForDetection()
-        {
-            var roots = new System.Collections.Generic.List<string>();
-            var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-            // macOS/Linux legacy
-            roots.Add(Path.Combine(home, ".config", "UnityMCP", "UnityMcpServer"));
-            roots.Add(Path.Combine(home, ".local", "share", "UnityMCP", "UnityMcpServer"));
-            // Windows roaming example
-            try
-            {
-                var roaming = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) ?? string.Empty;
-                if (!string.IsNullOrEmpty(roaming))
-                    roots.Add(Path.Combine(roaming, "UnityMCP", "UnityMcpServer"));
-            }
-            catch { }
-            return roots;
-        }
-
-        private static void TryKillUvForPath(string serverSrcPath)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(serverSrcPath)) return;
-                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) return;
-
-                var psi = new System.Diagnostics.ProcessStartInfo
-                {
-                    FileName = "/usr/bin/pgrep",
-                    Arguments = $"-f \"uv .*--directory {serverSrcPath}\"",
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    RedirectStandardError = true,
-                    CreateNoWindow = true,
-                };
-                using var p = System.Diagnostics.Process.Start(psi);
-                if (p == null) return;
-                var outp = p.StandardOutput.ReadToEnd();
-                p.WaitForExit(1500);
-                if (p.ExitCode == 0 && !string.IsNullOrEmpty(outp))
-                {
-                    foreach (var line in outp.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries))
-                    {
-                        if (int.TryParse(line.Trim(), out var pid))
-                        {
-                            try { System.Diagnostics.Process.GetProcessById(pid).Kill(); } catch { }
-                        }
-                    }
-                }
-            }
-            catch { }
-        }
-
-        private static string ReadVersionFile(string path)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(path) || !File.Exists(path)) return null;
-                var v = File.ReadAllText(path).Trim();
-                return string.IsNullOrEmpty(v) ? null : v;
-            }
-            catch { return null; }
-        }
-
-        private static int CompareSemverSafe(string a, string b)
-        {
-            try
-            {
-                if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return 0;
-                var ap = a.Split('.');
-                var bp = b.Split('.');
-                for (var i = 0; i < Math.Max(ap.Length, bp.Length); i++)
-                {
-                    var ai = (i < ap.Length && int.TryParse(ap[i], out var t1)) ? t1 : 0;
-                    var bi = (i < bp.Length && int.TryParse(bp[i], out var t2)) ? t2 : 0;
-                    if (ai != bi) return ai.CompareTo(bi);
-                }
-                return 0;
-            }
-            catch { return 0; }
-        }
-
-        /// <summary>
-        /// Attempts to locate the embedded UnityMcpServer/src directory inside the installed package
-        /// or common development locations.
-        /// </summary>
-        private static bool TryGetEmbeddedServerSource(out string srcPath)
-        {
-            return ServerPathResolver.TryFindEmbeddedServerSource(out srcPath);
-        }
-
-        private static readonly string[] _skipDirs = { ".venv", "__pycache__", ".pytest_cache", ".mypy_cache", ".git" };
-        private static void CopyDirectoryRecursive(string sourceDir, string destinationDir)
-        {
-            Directory.CreateDirectory(destinationDir);
-
-            foreach (var filePath in Directory.GetFiles(sourceDir))
-            {
-                var fileName = Path.GetFileName(filePath);
-                var destFile = Path.Combine(destinationDir, fileName);
-                File.Copy(filePath, destFile, overwrite: true);
-            }
-
-            foreach (var dirPath in Directory.GetDirectories(sourceDir))
-            {
-                var dirName = Path.GetFileName(dirPath);
-                foreach (var skip in _skipDirs)
-                {
-                    if (dirName.Equals(skip, StringComparison.OrdinalIgnoreCase))
-                        goto NextDir;
-                }
-                try { if ((File.GetAttributes(dirPath) & FileAttributes.ReparsePoint) != 0) continue; } catch { }
-                var destSubDir = Path.Combine(destinationDir, dirName);
-                CopyDirectoryRecursive(dirPath, destSubDir);
-            NextDir: ;
-            }
-        }
-
-        public static bool RepairPythonEnvironment()
-        {
-            try
-            {
-                var serverSrc = GetServerPath();
-                var hasServer = File.Exists(Path.Combine(serverSrc, "server.py"));
-                if (!hasServer)
-                {
-                    // In dev mode or if not installed yet, try the embedded/dev source
-                    if (TryGetEmbeddedServerSource(out var embeddedSrc) && File.Exists(Path.Combine(embeddedSrc, "server.py")))
-                    {
-                        serverSrc = embeddedSrc;
-                        hasServer = true;
-                    }
-                    else
-                    {
-                        // Attempt to install then retry
-                        EnsureServerInstalled();
-                        serverSrc = GetServerPath();
-                        hasServer = File.Exists(Path.Combine(serverSrc, "server.py"));
-                    }
-                }
-
-                if (!hasServer)
-                {
-                    Debug.LogWarning("RepairPythonEnvironment: server.py not found; ensure server is installed first.");
-                    return false;
-                }
-
-                // Remove stale venv and pinned version file if present
-                var venvPath = Path.Combine(serverSrc, ".venv");
-                if (Directory.Exists(venvPath))
-                {
-                    try { Directory.Delete(venvPath, recursive: true); } catch (Exception ex) { Debug.LogWarning($"Failed to delete .venv: {ex.Message}"); }
-                }
-                var pyPin = Path.Combine(serverSrc, ".python-version");
-                if (File.Exists(pyPin))
-                {
-                    try { File.Delete(pyPin); } catch (Exception ex) { Debug.LogWarning($"Failed to delete .python-version: {ex.Message}"); }
-                }
-
-                var uvPath = FindUvPath();
-                if (uvPath == null)
-                {
-                    Debug.LogError("UV not found. Please install uv (https://docs.astral.sh/uv/)." );
-                    return false;
-                }
-
-                var psi = new System.Diagnostics.ProcessStartInfo
-                {
-                    FileName = uvPath,
-                    Arguments = "sync",
-                    WorkingDirectory = serverSrc,
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    RedirectStandardError = true,
-                    CreateNoWindow = true,
-                };
-
-                using var proc = new System.Diagnostics.Process { StartInfo = psi };
-                var sbOut = new StringBuilder();
-                var sbErr = new StringBuilder();
-                proc.OutputDataReceived += (_, e) => { if (e.Data != null) sbOut.AppendLine(e.Data); };
-                proc.ErrorDataReceived  += (_, e) => { if (e.Data != null) sbErr.AppendLine(e.Data); };
-
-                if (!proc.Start())
-                {
-                    Debug.LogError("Failed to start uv process.");
-                    return false;
-                }
-
-                proc.BeginOutputReadLine();
-                proc.BeginErrorReadLine();
-
-                if (!proc.WaitForExit(60000))
-                {
-                    try { proc.Kill(); } catch { }
-                    Debug.LogError("uv sync timed out.");
-                    return false;
-                }
-
-                // Ensure async buffers flushed
-                proc.WaitForExit();
-
-                var stdout = sbOut.ToString();
-                var stderr = sbErr.ToString();
-
-                if (proc.ExitCode != 0)
-                {
-                    Debug.LogError($"uv sync failed: {stderr}\n{stdout}");
-                    return false;
-                }
-
-                Debug.Log("<b><color=#2EA3FF>MCP-FOR-UNITY</color></b>: Python environment repaired successfully.");
-                return true;
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError($"RepairPythonEnvironment failed: {ex.Message}");
-                return false;
-            }
-        }
-
-        internal static string FindUvPath()
-        {
-            // Allow user override via EditorPrefs
-            try
-            {
-                var overridePath = EditorPrefs.GetString("MCPForUnity.UvPath", string.Empty);
-                if (!string.IsNullOrEmpty(overridePath) && File.Exists(overridePath))
-                {
-                    if (ValidateUvBinary(overridePath)) return overridePath;
-                }
-            }
-            catch { }
-
-            var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-
-            // Platform-specific candidate lists
-            string[] candidates;
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) ?? string.Empty;
-                var programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) ?? string.Empty;
-                var appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) ?? string.Empty;
-
-                // Fast path: resolve from PATH first
-                try
-                {
-                    var wherePsi = new System.Diagnostics.ProcessStartInfo
-                    {
-                        FileName = "where",
-                        Arguments = "uv.exe",
-                        UseShellExecute = false,
-                        RedirectStandardOutput = true,
-                        RedirectStandardError = true,
-                        CreateNoWindow = true,
-                    };
-                    using var wp = System.Diagnostics.Process.Start(wherePsi);
-                    var output = wp.StandardOutput.ReadToEnd().Trim();
-                    wp.WaitForExit(1500);
-                    if (wp.ExitCode == 0 && !string.IsNullOrEmpty(output))
-                    {
-                        foreach (var line in output.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
-                        {
-                            var path = line.Trim();
-                            if (File.Exists(path) && ValidateUvBinary(path)) return path;
-                        }
-                    }
-                }
-                catch { }
-
-                // Windows Store (PythonSoftwareFoundation) install location probe
-                // Example: %LOCALAPPDATA%\Packages\PythonSoftwareFoundation.Python.3.13_*\LocalCache\local-packages\Python313\Scripts\uv.exe
-                try
-                {
-                    var pkgsRoot = Path.Combine(localAppData, "Packages");
-                    if (Directory.Exists(pkgsRoot))
-                    {
-                        var pythonPkgs = Directory.GetDirectories(pkgsRoot, "PythonSoftwareFoundation.Python.*", SearchOption.TopDirectoryOnly)
-                                                 .OrderByDescending(p => p, StringComparer.OrdinalIgnoreCase);
-                        foreach (var pkg in pythonPkgs)
-                        {
-                            var localCache = Path.Combine(pkg, "LocalCache", "local-packages");
-                            if (!Directory.Exists(localCache)) continue;
-                            var pyRoots = Directory.GetDirectories(localCache, "Python*", SearchOption.TopDirectoryOnly)
-                                                   .OrderByDescending(d => d, StringComparer.OrdinalIgnoreCase);
-                            foreach (var pyRoot in pyRoots)
-                            {
-                                var uvExe = Path.Combine(pyRoot, "Scripts", "uv.exe");
-                                if (File.Exists(uvExe) && ValidateUvBinary(uvExe)) return uvExe;
-                            }
-                        }
-                    }
-                }
-                catch { }
-
-                candidates = new[]
-                {
-                    // Preferred: WinGet Links shims (stable entrypoints)
-                    // Per-user shim (LOCALAPPDATA) → machine-wide shim (Program Files\WinGet\Links)
-                    Path.Combine(localAppData, "Microsoft", "WinGet", "Links", "uv.exe"),
-                    Path.Combine(programFiles, "WinGet", "Links", "uv.exe"),
-
-                    // Common per-user installs
-                    Path.Combine(localAppData, @"Programs\Python\Python313\Scripts\uv.exe"),
-                    Path.Combine(localAppData, @"Programs\Python\Python312\Scripts\uv.exe"),
-                    Path.Combine(localAppData, @"Programs\Python\Python311\Scripts\uv.exe"),
-                    Path.Combine(localAppData, @"Programs\Python\Python310\Scripts\uv.exe"),
-                    Path.Combine(appData, @"Python\Python313\Scripts\uv.exe"),
-                    Path.Combine(appData, @"Python\Python312\Scripts\uv.exe"),
-                    Path.Combine(appData, @"Python\Python311\Scripts\uv.exe"),
-                    Path.Combine(appData, @"Python\Python310\Scripts\uv.exe"),
-
-                    // Program Files style installs (if a native installer was used)
-                    Path.Combine(programFiles, @"uv\uv.exe"),
-
-                    // Try simple name resolution later via PATH
-                    "uv.exe",
-                    "uv",
-                };
-            }
-            else
-            {
-                candidates = new[]
-                {
-                    "/opt/homebrew/bin/uv",
-                    "/usr/local/bin/uv",
-                    "/usr/bin/uv",
-                    "/opt/local/bin/uv",
-                    Path.Combine(home, ".local", "bin", "uv"),
-                    "/opt/homebrew/opt/uv/bin/uv",
-                    // Framework Python installs
-                    "/Library/Frameworks/Python.framework/Versions/3.13/bin/uv",
-                    "/Library/Frameworks/Python.framework/Versions/3.12/bin/uv",
-                    // Fallback to PATH resolution by name
-                    "uv",
-                };
-            }
-
-            foreach (var c in candidates)
-            {
-                try
-                {
-                    if (File.Exists(c) && ValidateUvBinary(c)) return c;
-                }
-                catch { /* ignore */ }
-            }
-
-            // Use platform-appropriate which/where to resolve from PATH (non-Windows handled here; Windows tried earlier)
-            try
-            {
-                if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-                {
-                    var whichPsi = new System.Diagnostics.ProcessStartInfo
-                    {
-                        FileName = "/usr/bin/which",
-                        Arguments = "uv",
-                        UseShellExecute = false,
-                        RedirectStandardOutput = true,
-                        RedirectStandardError = true,
-                        CreateNoWindow = true,
-                    };
-                    try
-                    {
-                        // Prepend common user-local and package manager locations so 'which' can see them in Unity's GUI env
-                        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ?? string.Empty;
-                        var prepend = string.Join(":", new[]
-                        {
-                            System.IO.Path.Combine(homeDir, ".local", "bin"),
-                            "/opt/homebrew/bin",
-                            "/usr/local/bin",
-                            "/usr/bin",
-                            "/bin",
-                        });
-                        var currentPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
-                        whichPsi.EnvironmentVariables["PATH"] = string.IsNullOrEmpty(currentPath) ? prepend : (prepend + ":" + currentPath);
-                    }
-                    catch { }
-                    using var wp = System.Diagnostics.Process.Start(whichPsi);
-                    var output = wp.StandardOutput.ReadToEnd().Trim();
-                    wp.WaitForExit(3000);
-                    if (wp.ExitCode == 0 && !string.IsNullOrEmpty(output) && File.Exists(output))
-                    {
-                        if (ValidateUvBinary(output)) return output;
-                    }
-                }
-            }
-            catch { }
-
-            // Manual PATH scan
-            try
-            {
-                var pathEnv = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
-                var parts = pathEnv.Split(Path.PathSeparator);
-                foreach (var part in parts)
-                {
-                    try
-                    {
-                        // Check both uv and uv.exe
-                        var candidateUv = Path.Combine(part, "uv");
-                        var candidateUvExe = Path.Combine(part, "uv.exe");
-                        if (File.Exists(candidateUv) && ValidateUvBinary(candidateUv)) return candidateUv;
-                        if (File.Exists(candidateUvExe) && ValidateUvBinary(candidateUvExe)) return candidateUvExe;
-                    }
-                    catch { }
-                }
-            }
-            catch { }
-
-            return null;
-        }
-
-        private static bool ValidateUvBinary(string uvPath)
-        {
-            try
-            {
-                var psi = new System.Diagnostics.ProcessStartInfo
-                {
-                    FileName = uvPath,
-                    Arguments = "--version",
-                    UseShellExecute = false,
-                    RedirectStandardOutput = true,
-                    RedirectStandardError = true,
-                    CreateNoWindow = true,
-                };
-                using var p = System.Diagnostics.Process.Start(psi);
-                if (!p.WaitForExit(5000)) { try { p.Kill(); } catch { } return false; }
-                if (p.ExitCode == 0)
-                {
-                    var output = p.StandardOutput.ReadToEnd().Trim();
-                    return output.StartsWith("uv ");
-                }
-            }
-            catch { }
-            return false;
-        }
-    }
-}
Index: Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs b/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Windows/VSCodeManualSetupWindow.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,291 +0,0 @@
-using System.Runtime.InteropServices;
-using UnityEditor;
-using UnityEngine;
-using MCPForUnity.Editor.Models;
-
-namespace MCPForUnity.Editor.Windows
-{
-    public class VSCodeManualSetupWindow : ManualConfigEditorWindow
-    {
-        public static void ShowWindow(string configPath, string configJson)
-        {
-            var window = GetWindow<VSCodeManualSetupWindow>("VSCode GitHub Copilot Setup");
-            window.configPath = configPath;
-            window.configJson = configJson;
-            window.minSize = new Vector2(550, 500);
-            
-            // Create a McpClient for VSCode
-            window.mcpClient = new McpClient
-            {
-                name = "VSCode GitHub Copilot",
-                mcpType = McpTypes.VSCode
-            };
-            
-            window.Show();
-        }
-
-        protected override void OnGUI()
-        {
-            scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
-
-            // Header with improved styling
-            EditorGUILayout.Space(10);
-            var titleRect = EditorGUILayout.GetControlRect(false, 30);
-            EditorGUI.DrawRect(
-                new Rect(titleRect.x, titleRect.y, titleRect.width, titleRect.height),
-                new Color(0.2f, 0.2f, 0.2f, 0.1f)
-            );
-            GUI.Label(
-                new Rect(titleRect.x + 10, titleRect.y + 6, titleRect.width - 20, titleRect.height),
-                "VSCode GitHub Copilot MCP Setup",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.Space(10);
-
-            // Instructions with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            var headerRect = EditorGUILayout.GetControlRect(false, 24);
-            EditorGUI.DrawRect(
-                new Rect(headerRect.x, headerRect.y, headerRect.width, headerRect.height),
-                new Color(0.1f, 0.1f, 0.1f, 0.2f)
-            );
-            GUI.Label(
-                new Rect(
-                    headerRect.x + 8,
-                    headerRect.y + 4,
-                    headerRect.width - 16,
-                    headerRect.height
-                ),
-                "Setting up GitHub Copilot in VSCode with MCP for Unity",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.Space(10);
-
-            GUIStyle instructionStyle = new(EditorStyles.wordWrappedLabel)
-            {
-                margin = new RectOffset(10, 10, 5, 5),
-            };
-
-            EditorGUILayout.LabelField(
-                "1. Prerequisites",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.LabelField(
-                "• Ensure you have VSCode installed",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "• Ensure you have GitHub Copilot extension installed in VSCode",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "• Ensure you have a valid GitHub Copilot subscription",
-                instructionStyle
-            );
-            EditorGUILayout.Space(5);
-
-            EditorGUILayout.LabelField(
-                "2. Steps to Configure",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.LabelField(
-                "a) Open or create your VSCode MCP config file (mcp.json) at the path below",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "b) Paste the JSON shown below into mcp.json",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "c) Save the file and restart VSCode",
-                instructionStyle
-            );
-            EditorGUILayout.Space(5);
-
-            EditorGUILayout.LabelField(
-                "3. VSCode mcp.json location:",
-                EditorStyles.boldLabel
-            );
-
-            // Path section with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-            string displayPath;
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                displayPath = System.IO.Path.Combine(
-                    System.Environment.GetFolderPath(System.Environment.SpecialFolder.ApplicationData),
-                    "Code",
-                    "User",
-                    "mcp.json"
-                );
-            }
-            else
-            {
-                displayPath = System.IO.Path.Combine(
-                    System.Environment.GetFolderPath(System.Environment.SpecialFolder.UserProfile),
-                    "Library",
-                    "Application Support",
-                    "Code",
-                    "User",
-                    "mcp.json"
-                );
-            }
-
-            // Store the path in the base class config path
-            if (string.IsNullOrEmpty(configPath))
-            {
-                configPath = displayPath;
-            }
-
-            // Prevent text overflow by allowing the text field to wrap
-            GUIStyle pathStyle = new(EditorStyles.textField) { wordWrap = true };
-
-            EditorGUILayout.TextField(
-                displayPath,
-                pathStyle,
-                GUILayout.Height(EditorGUIUtility.singleLineHeight)
-            );
-
-            // Copy button with improved styling
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-            GUIStyle copyButtonStyle = new(GUI.skin.button)
-            {
-                padding = new RectOffset(15, 15, 5, 5),
-                margin = new RectOffset(10, 10, 5, 5),
-            };
-
-            if (
-                GUILayout.Button(
-                    "Copy Path",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                EditorGUIUtility.systemCopyBuffer = displayPath;
-                pathCopied = true;
-                copyFeedbackTimer = 2f;
-            }
-
-            if (
-                GUILayout.Button(
-                    "Open File",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                // Open the file using the system's default application
-                System.Diagnostics.Process.Start(
-                    new System.Diagnostics.ProcessStartInfo
-                    {
-                        FileName = displayPath,
-                        UseShellExecute = true,
-                    }
-                );
-            }
-
-            if (pathCopied)
-            {
-                GUIStyle feedbackStyle = new(EditorStyles.label);
-                feedbackStyle.normal.textColor = Color.green;
-                EditorGUILayout.LabelField("Copied!", feedbackStyle, GUILayout.Width(60));
-            }
-
-            EditorGUILayout.EndHorizontal();
-            EditorGUILayout.EndVertical();
-            EditorGUILayout.Space(10);
-
-            EditorGUILayout.LabelField(
-                "4. Add this configuration to your mcp.json:",
-                EditorStyles.boldLabel
-            );
-
-            // JSON section with improved styling
-            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
-
-            // Improved text area for JSON with syntax highlighting colors
-            GUIStyle jsonStyle = new(EditorStyles.textArea)
-            {
-                font = EditorStyles.boldFont,
-                wordWrap = true,
-            };
-            jsonStyle.normal.textColor = new Color(0.3f, 0.6f, 0.9f); // Syntax highlighting blue
-
-            // Draw the JSON in a text area with a taller height for better readability
-            EditorGUILayout.TextArea(configJson, jsonStyle, GUILayout.Height(200));
-
-            // Copy JSON button with improved styling
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-
-            if (
-                GUILayout.Button(
-                    "Copy JSON",
-                    copyButtonStyle,
-                    GUILayout.Height(25),
-                    GUILayout.Width(100)
-                )
-            )
-            {
-                EditorGUIUtility.systemCopyBuffer = configJson;
-                jsonCopied = true;
-                copyFeedbackTimer = 2f;
-            }
-
-            if (jsonCopied)
-            {
-                GUIStyle feedbackStyle = new(EditorStyles.label);
-                feedbackStyle.normal.textColor = Color.green;
-                EditorGUILayout.LabelField("Copied!", feedbackStyle, GUILayout.Width(60));
-            }
-
-            EditorGUILayout.EndHorizontal();
-            EditorGUILayout.EndVertical();
-
-            EditorGUILayout.Space(10);
-            EditorGUILayout.LabelField(
-                "5. After configuration:",
-                EditorStyles.boldLabel
-            );
-            EditorGUILayout.LabelField(
-                "• Restart VSCode",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "• GitHub Copilot will now be able to interact with your Unity project through the MCP protocol",
-                instructionStyle
-            );
-            EditorGUILayout.LabelField(
-                "• Remember to have the MCP for Unity Bridge running in Unity Editor",
-                instructionStyle
-            );
-
-            EditorGUILayout.EndVertical();
-
-            EditorGUILayout.Space(10);
-
-            // Close button at the bottom
-            EditorGUILayout.BeginHorizontal();
-            GUILayout.FlexibleSpace();
-            if (GUILayout.Button("Close", GUILayout.Height(30), GUILayout.Width(100)))
-            {
-                Close();
-            }
-            GUILayout.FlexibleSpace();
-            EditorGUILayout.EndHorizontal();
-
-            EditorGUILayout.EndScrollView();
-        }
-
-        protected override void Update()
-        {
-            // Call the base implementation which handles the copy feedback timer
-            base.Update();
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageAsset.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: de90a1d9743a2874cb235cf0b83444b1
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs.meta b/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Data/DefaultServerConfig.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: de8f5721c34f7194392e9d8c7d0226c0
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/McpStatus.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs b/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/McpStatus.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,18 +0,0 @@
-namespace MCPForUnity.Editor.Models
-{
-    // Enum representing the various status states for MCP clients
-    public enum McpStatus
-    {
-        NotConfigured, // Not set up yet
-        Configured, // Successfully configured
-        Running, // Service is running
-        Connected, // Successfully connected
-        IncorrectPath, // Configuration has incorrect paths
-        CommunicationError, // Connected but communication issues
-        NoResponse, // Connected but not responding
-        MissingConfig, // Config file exists but missing required elements
-        UnsupportedOS, // OS is not supported
-        Error, // General error state
-    }
-}
-
Index: Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs b/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageGameObject.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2458 +0,0 @@
-#nullable disable
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-using Newtonsoft.Json; // Added for JsonSerializationException
-using Newtonsoft.Json.Linq;
-using UnityEditor;
-// For CompilationPipeline
-using UnityEditorInternal;
-using UnityEngine;
-using UnityEngine.SceneManagement;
-using MCPForUnity.Editor.Helpers; // For Response class
-using MCPForUnity.Runtime.Serialization;
-
-namespace MCPForUnity.Editor.Tools
-{
-    /// <summary>
-    /// Handles GameObject manipulation within the current scene (CRUD, find, components).
-    /// </summary>
-    public static class ManageGameObject
-    {
-        // Shared JsonSerializer to avoid per-call allocation overhead
-        private static readonly JsonSerializer InputSerializer = JsonSerializer.Create(new JsonSerializerSettings
-        {
-            Converters = new List<JsonConverter>
-            {
-                new Vector3Converter(),
-                new Vector2Converter(),
-                new QuaternionConverter(),
-                new ColorConverter(),
-                new RectConverter(),
-                new BoundsConverter(),
-                new UnityEngineObjectConverter()
-            }
-        });
-
-        // --- Main Handler ---
-
-        public static object HandleCommand(JObject @params)
-        {
-            if (@params == null)
-            {
-                return Response.Error("Parameters cannot be null.");
-            }
-
-            var action = @params["action"]?.ToString().ToLower();
-            if (string.IsNullOrEmpty(action))
-            {
-                return Response.Error("Action parameter is required.");
-            }
-
-            // Parameters used by various actions
-            var targetToken = @params["target"]; // Can be string (name/path) or int (instanceID)
-            var searchMethod = @params["searchMethod"]?.ToString().ToLower();
-
-            // Get common parameters (consolidated)
-            var name = @params["name"]?.ToString();
-            var tag = @params["tag"]?.ToString();
-            var layer = @params["layer"]?.ToString();
-            var parentToken = @params["parent"];
-
-            // --- Add parameter for controlling non-public field inclusion ---
-            var includeNonPublicSerialized = @params["includeNonPublicSerialized"]?.ToObject<bool>() ?? true; // Default to true
-            // --- End add parameter ---
-
-            // --- Prefab Redirection Check ---
-            var targetPath =
-                targetToken?.Type == JTokenType.String ? targetToken.ToString() : null;
-            if (
-                !string.IsNullOrEmpty(targetPath)
-                && targetPath.EndsWith(".prefab", StringComparison.OrdinalIgnoreCase)
-            )
-            {
-                // Allow 'create' (instantiate), 'find' (?), 'get_components' (?)
-                if (action == "modify" || action == "set_component_property")
-                {
-                    Debug.Log(
-                        $"[ManageGameObject->ManageAsset] Redirecting action '{action}' for prefab '{targetPath}' to ManageAsset."
-                    );
-                    // Prepare params for ManageAsset.ModifyAsset
-                    var assetParams = new JObject();
-                    assetParams["action"] = "modify"; // ManageAsset uses "modify"
-                    assetParams["path"] = targetPath;
-
-                    // Extract properties.
-                    // For 'set_component_property', combine componentName and componentProperties.
-                    // For 'modify', directly use componentProperties.
-                    JObject properties = null;
-                    if (action == "set_component_property")
-                    {
-                        var compName = @params["componentName"]?.ToString();
-                        var compProps = @params["componentProperties"]?[compName] as JObject; // Handle potential nesting
-                        if (string.IsNullOrEmpty(compName))
-                            return Response.Error(
-                                "Missing 'componentName' for 'set_component_property' on prefab."
-                            );
-                        if (compProps == null)
-                            return Response.Error(
-                                $"Missing or invalid 'componentProperties' for component '{compName}' for 'set_component_property' on prefab."
-                            );
-
-                        properties = new JObject();
-                        properties[compName] = compProps;
-                    }
-                    else // action == "modify"
-                    {
-                        properties = @params["componentProperties"] as JObject;
-                        if (properties == null)
-                            return Response.Error(
-                                "Missing 'componentProperties' for 'modify' action on prefab."
-                            );
-                    }
-
-                    assetParams["properties"] = properties;
-
-                    // Call ManageAsset handler
-                    return ManageAsset.HandleCommand(assetParams);
-                }
-                else if (
-                    action == "delete"
-                    || action == "add_component"
-                    || action == "remove_component"
-                    || action == "get_components"
-                ) // Added get_components here too
-                {
-                    // Explicitly block other modifications on the prefab asset itself via manage_gameobject
-                    return Response.Error(
-                        $"Action '{action}' on a prefab asset ('{targetPath}') should be performed using the 'manage_asset' command."
-                    );
-                }
-                // Allow 'create' (instantiation) and 'find' to proceed, although finding a prefab asset by path might be less common via manage_gameobject.
-                // No specific handling needed here, the code below will run.
-            }
-            // --- End Prefab Redirection Check ---
-
-            try
-            {
-                switch (action)
-                {
-                    case "create":
-                        return CreateGameObject(@params);
-                    case "modify":
-                        return ModifyGameObject(@params, targetToken, searchMethod);
-                    case "delete":
-                        return DeleteGameObject(targetToken, searchMethod);
-                    case "find":
-                        return FindGameObjects(@params, targetToken, searchMethod);
-                    case "get_components":
-                        var getCompTarget = targetToken?.ToString(); // Expect name, path, or ID string
-                        if (getCompTarget == null)
-                            return Response.Error(
-                                "'target' parameter required for get_components."
-                            );
-                        // Pass the includeNonPublicSerialized flag here
-                        return GetComponentsFromTarget(getCompTarget, searchMethod, includeNonPublicSerialized);
-                    case "add_component":
-                        return AddComponentToTarget(@params, targetToken, searchMethod);
-                    case "remove_component":
-                        return RemoveComponentFromTarget(@params, targetToken, searchMethod);
-                    case "set_component_property":
-                        return SetComponentPropertyOnTarget(@params, targetToken, searchMethod);
-
-                    default:
-                        return Response.Error($"Unknown action: '{action}'.");
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.LogError($"[ManageGameObject] Action '{action}' failed: {e}");
-                return Response.Error($"Internal error processing action '{action}': {e.Message}");
-            }
-        }
-
-        // --- Action Implementations ---
-
-        private static object CreateGameObject(JObject @params)
-        {
-            var name = @params["name"]?.ToString();
-            if (string.IsNullOrEmpty(name))
-            {
-                return Response.Error("'name' parameter is required for 'create' action.");
-            }
-
-            // Get prefab creation parameters
-            var saveAsPrefab = @params["saveAsPrefab"]?.ToObject<bool>() ?? false;
-            var prefabPath = @params["prefabPath"]?.ToString();
-            var tag = @params["tag"]?.ToString(); // Get tag for creation
-            var primitiveType = @params["primitiveType"]?.ToString(); // Keep primitiveType check
-            GameObject newGo = null; // Initialize as null
-
-            // --- Try Instantiating Prefab First ---
-            var originalPrefabPath = prefabPath; // Keep original for messages
-            if (!string.IsNullOrEmpty(prefabPath))
-            {
-                // If no extension, search for the prefab by name
-                if (
-                    !prefabPath.Contains("/")
-                    && !prefabPath.EndsWith(".prefab", StringComparison.OrdinalIgnoreCase)
-                )
-                {
-                    var prefabNameOnly = prefabPath;
-                    Debug.Log(
-                        $"[ManageGameObject.Create] Searching for prefab named: '{prefabNameOnly}'"
-                    );
-                    var guids = AssetDatabase.FindAssets($"t:Prefab {prefabNameOnly}");
-                    if (guids.Length == 0)
-                    {
-                        return Response.Error(
-                            $"Prefab named '{prefabNameOnly}' not found anywhere in the project."
-                        );
-                    }
-                    else if (guids.Length > 1)
-                    {
-                        var foundPaths = string.Join(
-                            ", ",
-                            guids.Select(g => AssetDatabase.GUIDToAssetPath(g))
-                        );
-                        return Response.Error(
-                            $"Multiple prefabs found matching name '{prefabNameOnly}': {foundPaths}. Please provide a more specific path."
-                        );
-                    }
-                    else // Exactly one found
-                    {
-                        prefabPath = AssetDatabase.GUIDToAssetPath(guids[0]); // Update prefabPath with the full path
-                        Debug.Log(
-                            $"[ManageGameObject.Create] Found unique prefab at path: '{prefabPath}'"
-                        );
-                    }
-                }
-                else if (!prefabPath.EndsWith(".prefab", StringComparison.OrdinalIgnoreCase))
-                {
-                    // If it looks like a path but doesn't end with .prefab, assume user forgot it and append it.
-                    Debug.LogWarning(
-                        $"[ManageGameObject.Create] Provided prefabPath '{prefabPath}' does not end with .prefab. Assuming it's missing and appending."
-                    );
-                    prefabPath += ".prefab";
-                    // Note: This path might still not exist, AssetDatabase.LoadAssetAtPath will handle that.
-                }
-                // The logic above now handles finding or assuming the .prefab extension.
-
-                var prefabAsset = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);
-                if (prefabAsset != null)
-                {
-                    try
-                    {
-                        // Instantiate the prefab, initially place it at the root
-                        // Parent will be set later if specified
-                        newGo = PrefabUtility.InstantiatePrefab(prefabAsset) as GameObject;
-
-                        if (newGo == null)
-                        {
-                            // This might happen if the asset exists but isn't a valid GameObject prefab somehow
-                            Debug.LogError(
-                                $"[ManageGameObject.Create] Failed to instantiate prefab at '{prefabPath}', asset might be corrupted or not a GameObject."
-                            );
-                            return Response.Error(
-                                $"Failed to instantiate prefab at '{prefabPath}'."
-                            );
-                        }
-                        // Name the instance based on the 'name' parameter, not the prefab's default name
-                        if (!string.IsNullOrEmpty(name))
-                        {
-                            newGo.name = name;
-                        }
-                        // Register Undo for prefab instantiation
-                        Undo.RegisterCreatedObjectUndo(
-                            newGo,
-                            $"Instantiate Prefab '{prefabAsset.name}' as '{newGo.name}'"
-                        );
-                        Debug.Log(
-                            $"[ManageGameObject.Create] Instantiated prefab '{prefabAsset.name}' from path '{prefabPath}' as '{newGo.name}'."
-                        );
-                    }
-                    catch (Exception e)
-                    {
-                        return Response.Error(
-                            $"Error instantiating prefab '{prefabPath}': {e.Message}"
-                        );
-                    }
-                }
-                else
-                {
-                    // Only return error if prefabPath was specified but not found.
-                    // If prefabPath was empty/null, we proceed to create primitive/empty.
-                    Debug.LogWarning(
-                        $"[ManageGameObject.Create] Prefab asset not found at path: '{prefabPath}'. Will proceed to create new object if specified."
-                    );
-                    // Do not return error here, allow fallback to primitive/empty creation
-                }
-            }
-
-            // --- Fallback: Create Primitive or Empty GameObject ---
-            var createdNewObject = false; // Flag to track if we created (not instantiated)
-            if (newGo == null) // Only proceed if prefab instantiation didn't happen
-            {
-                if (!string.IsNullOrEmpty(primitiveType))
-                {
-                    try
-                    {
-                        var type = (PrimitiveType)
-                            Enum.Parse(typeof(PrimitiveType), primitiveType, true);
-                        newGo = GameObject.CreatePrimitive(type);
-                        // Set name *after* creation for primitives
-                        if (!string.IsNullOrEmpty(name))
-                        {
-                            newGo.name = name;
-                        }
-                        else
-                        {
-                            UnityEngine.Object.DestroyImmediate(newGo); // cleanup leak
-                            return Response.Error(
-                                "'name' parameter is required when creating a primitive."
-                            );
-                        }
-                        createdNewObject = true;
-                    }
-                    catch (ArgumentException)
-                    {
-                        return Response.Error(
-                            $"Invalid primitive type: '{primitiveType}'. Valid types: {string.Join(", ", Enum.GetNames(typeof(PrimitiveType)))}"
-                        );
-                    }
-                    catch (Exception e)
-                    {
-                        return Response.Error(
-                            $"Failed to create primitive '{primitiveType}': {e.Message}"
-                        );
-                    }
-                }
-                else // Create empty GameObject
-                {
-                    if (string.IsNullOrEmpty(name))
-                    {
-                        return Response.Error(
-                            "'name' parameter is required for 'create' action when not instantiating a prefab or creating a primitive."
-                        );
-                    }
-                    newGo = new GameObject(name);
-                    createdNewObject = true;
-                }
-                // Record creation for Undo *only* if we created a new object
-                if (createdNewObject)
-                {
-                    Undo.RegisterCreatedObjectUndo(newGo, $"Create GameObject '{newGo.name}'");
-                }
-            }
-            // --- Common Setup (Parent, Transform, Tag, Components) - Applied AFTER object exists ---
-            if (newGo == null)
-            {
-                // Should theoretically not happen if logic above is correct, but safety check.
-                return Response.Error("Failed to create or instantiate the GameObject.");
-            }
-
-            // Record potential changes to the existing prefab instance or the new GO
-            // Record transform separately in case parent changes affect it
-            Undo.RecordObject(newGo.transform, "Set GameObject Transform");
-            Undo.RecordObject(newGo, "Set GameObject Properties");
-
-            // Set Parent
-            var parentToken = @params["parent"];
-            if (parentToken != null)
-            {
-                var parentGo = FindObjectInternal(parentToken, "by_id_or_name_or_path"); // Flexible parent finding
-                if (parentGo == null)
-                {
-                    UnityEngine.Object.DestroyImmediate(newGo); // Clean up created object
-                    return Response.Error($"Parent specified ('{parentToken}') but not found.");
-                }
-                newGo.transform.SetParent(parentGo.transform, true); // worldPositionStays = true
-            }
-
-            // Set Transform
-            var position = ParseVector3(@params["position"] as JArray);
-            var rotation = ParseVector3(@params["rotation"] as JArray);
-            var scale = ParseVector3(@params["scale"] as JArray);
-
-            if (position.HasValue)
-                newGo.transform.localPosition = position.Value;
-            if (rotation.HasValue)
-                newGo.transform.localEulerAngles = rotation.Value;
-            if (scale.HasValue)
-                newGo.transform.localScale = scale.Value;
-
-            // Set Tag (added for create action)
-            if (!string.IsNullOrEmpty(tag))
-            {
-                // Similar logic as in ModifyGameObject for setting/creating tags
-                var tagToSet = string.IsNullOrEmpty(tag) ? "Untagged" : tag;
-                try
-                {
-                    newGo.tag = tagToSet;
-                }
-                catch (UnityException ex)
-                {
-                    if (ex.Message.Contains("is not defined"))
-                    {
-                        Debug.LogWarning(
-                            $"[ManageGameObject.Create] Tag '{tagToSet}' not found. Attempting to create it."
-                        );
-                        try
-                        {
-                            InternalEditorUtility.AddTag(tagToSet);
-                            newGo.tag = tagToSet; // Retry
-                            Debug.Log(
-                                $"[ManageGameObject.Create] Tag '{tagToSet}' created and assigned successfully."
-                            );
-                        }
-                        catch (Exception innerEx)
-                        {
-                            UnityEngine.Object.DestroyImmediate(newGo); // Clean up
-                            return Response.Error(
-                                $"Failed to create or assign tag '{tagToSet}' during creation: {innerEx.Message}."
-                            );
-                        }
-                    }
-                    else
-                    {
-                        UnityEngine.Object.DestroyImmediate(newGo); // Clean up
-                        return Response.Error(
-                            $"Failed to set tag to '{tagToSet}' during creation: {ex.Message}."
-                        );
-                    }
-                }
-            }
-
-            // Set Layer (new for create action)
-            var layerName = @params["layer"]?.ToString();
-            if (!string.IsNullOrEmpty(layerName))
-            {
-                var layerId = LayerMask.NameToLayer(layerName);
-                if (layerId != -1)
-                {
-                    newGo.layer = layerId;
-                }
-                else
-                {
-                    Debug.LogWarning(
-                        $"[ManageGameObject.Create] Layer '{layerName}' not found. Using default layer."
-                    );
-                }
-            }
-
-            // Add Components
-            if (@params["componentsToAdd"] is JArray componentsToAddArray)
-            {
-                foreach (var compToken in componentsToAddArray)
-                {
-                    string typeName = null;
-                    JObject properties = null;
-
-                    if (compToken.Type == JTokenType.String)
-                    {
-                        typeName = compToken.ToString();
-                    }
-                    else if (compToken is JObject compObj)
-                    {
-                        typeName = compObj["typeName"]?.ToString();
-                        properties = compObj["properties"] as JObject;
-                    }
-
-                    if (!string.IsNullOrEmpty(typeName))
-                    {
-                        var addResult = AddComponentInternal(newGo, typeName, properties);
-                        if (addResult != null) // Check if AddComponentInternal returned an error object
-                        {
-                            UnityEngine.Object.DestroyImmediate(newGo); // Clean up
-                            return addResult; // Return the error response
-                        }
-                    }
-                    else
-                    {
-                        Debug.LogWarning(
-                            $"[ManageGameObject] Invalid component format in componentsToAdd: {compToken}"
-                        );
-                    }
-                }
-            }
-
-            // Save as Prefab ONLY if we *created* a new object AND saveAsPrefab is true
-            var finalInstance = newGo; // Use this for selection and return data
-            if (createdNewObject && saveAsPrefab)
-            {
-                var finalPrefabPath = prefabPath; // Use a separate variable for saving path
-                // This check should now happen *before* attempting to save
-                if (string.IsNullOrEmpty(finalPrefabPath))
-                {
-                    // Clean up the created object before returning error
-                    UnityEngine.Object.DestroyImmediate(newGo);
-                    return Response.Error(
-                        "'prefabPath' is required when 'saveAsPrefab' is true and creating a new object."
-                    );
-                }
-                // Ensure the *saving* path ends with .prefab
-                if (!finalPrefabPath.EndsWith(".prefab", StringComparison.OrdinalIgnoreCase))
-                {
-                    Debug.Log(
-                        $"[ManageGameObject.Create] Appending .prefab extension to save path: '{finalPrefabPath}' -> '{finalPrefabPath}.prefab'"
-                    );
-                    finalPrefabPath += ".prefab";
-                }
-
-                try
-                {
-                    // Ensure directory exists using the final saving path
-                    var directoryPath = System.IO.Path.GetDirectoryName(finalPrefabPath);
-                    if (
-                        !string.IsNullOrEmpty(directoryPath)
-                        && !System.IO.Directory.Exists(directoryPath)
-                    )
-                    {
-                        System.IO.Directory.CreateDirectory(directoryPath);
-                        AssetDatabase.Refresh(); // Refresh asset database to recognize the new folder
-                        Debug.Log(
-                            $"[ManageGameObject.Create] Created directory for prefab: {directoryPath}"
-                        );
-                    }
-                    // Use SaveAsPrefabAssetAndConnect with the final saving path
-                    finalInstance = PrefabUtility.SaveAsPrefabAssetAndConnect(
-                        newGo,
-                        finalPrefabPath,
-                        InteractionMode.UserAction
-                    );
-
-                    if (finalInstance == null)
-                    {
-                        // Destroy the original if saving failed somehow (shouldn't usually happen if path is valid)
-                        UnityEngine.Object.DestroyImmediate(newGo);
-                        return Response.Error(
-                            $"Failed to save GameObject '{name}' as prefab at '{finalPrefabPath}'. Check path and permissions."
-                        );
-                    }
-                    Debug.Log(
-                        $"[ManageGameObject.Create] GameObject '{name}' saved as prefab to '{finalPrefabPath}' and instance connected."
-                    );
-                    // Mark the new prefab asset as dirty? Not usually necessary, SaveAsPrefabAsset handles it.
-                    // EditorUtility.SetDirty(finalInstance); // Instance is handled by SaveAsPrefabAssetAndConnect
-                }
-                catch (Exception e)
-                {
-                    // Clean up the instance if prefab saving fails
-                    UnityEngine.Object.DestroyImmediate(newGo); // Destroy the original attempt
-                    return Response.Error($"Error saving prefab '{finalPrefabPath}': {e.Message}");
-                }
-            }
-
-            // Select the instance in the scene (either prefab instance or newly created/saved one)
-            Selection.activeGameObject = finalInstance;
-
-            // Determine appropriate success message using the potentially updated or original path
-            var messagePrefabPath =
-                finalInstance == null
-                    ? originalPrefabPath
-                    : AssetDatabase.GetAssetPath(
-                        PrefabUtility.GetCorrespondingObjectFromSource(finalInstance)
-                            ?? (UnityEngine.Object)finalInstance
-                    );
-            string successMessage;
-            if (!createdNewObject && !string.IsNullOrEmpty(messagePrefabPath)) // Instantiated existing prefab
-            {
-                successMessage =
-                    $"Prefab '{messagePrefabPath}' instantiated successfully as '{finalInstance.name}'.";
-            }
-            else if (createdNewObject && saveAsPrefab && !string.IsNullOrEmpty(messagePrefabPath)) // Created new and saved as prefab
-            {
-                successMessage =
-                    $"GameObject '{finalInstance.name}' created and saved as prefab to '{messagePrefabPath}'.";
-            }
-            else // Created new primitive or empty GO, didn't save as prefab
-            {
-                successMessage =
-                    $"GameObject '{finalInstance.name}' created successfully in scene.";
-            }
-
-            // Use the new serializer helper
-            //return Response.Success(successMessage, GetGameObjectData(finalInstance));
-            return Response.Success(successMessage, Helpers.GameObjectSerializer.GetGameObjectData(finalInstance));
-        }
-
-        private static object ModifyGameObject(
-            JObject @params,
-            JToken targetToken,
-            string searchMethod
-        )
-        {
-            var targetGo = FindObjectInternal(targetToken, searchMethod);
-            if (targetGo == null)
-            {
-                return Response.Error(
-                    $"Target GameObject ('{targetToken}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            // Record state for Undo *before* modifications
-            Undo.RecordObject(targetGo.transform, "Modify GameObject Transform");
-            Undo.RecordObject(targetGo, "Modify GameObject Properties");
-
-            var modified = false;
-
-            // Rename (using consolidated 'name' parameter)
-            var name = @params["name"]?.ToString();
-            if (!string.IsNullOrEmpty(name) && targetGo.name != name)
-            {
-                targetGo.name = name;
-                modified = true;
-            }
-
-            // Change Parent (using consolidated 'parent' parameter)
-            var parentToken = @params["parent"];
-            if (parentToken != null)
-            {
-                var newParentGo = FindObjectInternal(parentToken, "by_id_or_name_or_path");
-                // Check for hierarchy loops
-                if (
-                    newParentGo == null
-                    && !(
-                        parentToken.Type == JTokenType.Null
-                        || (
-                            parentToken.Type == JTokenType.String
-                            && string.IsNullOrEmpty(parentToken.ToString())
-                        )
-                    )
-                )
-                {
-                    return Response.Error($"New parent ('{parentToken}') not found.");
-                }
-                if (newParentGo != null && newParentGo.transform.IsChildOf(targetGo.transform))
-                {
-                    return Response.Error(
-                        $"Cannot parent '{targetGo.name}' to '{newParentGo.name}', as it would create a hierarchy loop."
-                    );
-                }
-                if (targetGo.transform.parent != (newParentGo?.transform))
-                {
-                    targetGo.transform.SetParent(newParentGo?.transform, true); // worldPositionStays = true
-                    modified = true;
-                }
-            }
-
-            // Set Active State
-            var setActive = @params["setActive"]?.ToObject<bool?>();
-            if (setActive.HasValue && targetGo.activeSelf != setActive.Value)
-            {
-                targetGo.SetActive(setActive.Value);
-                modified = true;
-            }
-
-            // Change Tag (using consolidated 'tag' parameter)
-            var tag = @params["tag"]?.ToString();
-            // Only attempt to change tag if a non-null tag is provided and it's different from the current one.
-            // Allow setting an empty string to remove the tag (Unity uses "Untagged").
-            if (tag != null && targetGo.tag != tag)
-            {
-                // Ensure the tag is not empty, if empty, it means "Untagged" implicitly
-                var tagToSet = string.IsNullOrEmpty(tag) ? "Untagged" : tag;
-                try
-                {
-                    targetGo.tag = tagToSet;
-                    modified = true;
-                }
-                catch (UnityException ex)
-                {
-                    // Check if the error is specifically because the tag doesn't exist
-                    if (ex.Message.Contains("is not defined"))
-                    {
-                        Debug.LogWarning(
-                            $"[ManageGameObject] Tag '{tagToSet}' not found. Attempting to create it."
-                        );
-                        try
-                        {
-                            // Attempt to create the tag using internal utility
-                            InternalEditorUtility.AddTag(tagToSet);
-                            // Wait a frame maybe? Not strictly necessary but sometimes helps editor updates.
-                            // yield return null; // Cannot yield here, editor script limitation
-
-                            // Retry setting the tag immediately after creation
-                            targetGo.tag = tagToSet;
-                            modified = true;
-                            Debug.Log(
-                                $"[ManageGameObject] Tag '{tagToSet}' created and assigned successfully."
-                            );
-                        }
-                        catch (Exception innerEx)
-                        {
-                            // Handle failure during tag creation or the second assignment attempt
-                            Debug.LogError(
-                                $"[ManageGameObject] Failed to create or assign tag '{tagToSet}' after attempting creation: {innerEx.Message}"
-                            );
-                            return Response.Error(
-                                $"Failed to create or assign tag '{tagToSet}': {innerEx.Message}. Check Tag Manager and permissions."
-                            );
-                        }
-                    }
-                    else
-                    {
-                        // If the exception was for a different reason, return the original error
-                        return Response.Error($"Failed to set tag to '{tagToSet}': {ex.Message}.");
-                    }
-                }
-            }
-
-            // Change Layer (using consolidated 'layer' parameter)
-            var layerName = @params["layer"]?.ToString();
-            if (!string.IsNullOrEmpty(layerName))
-            {
-                var layerId = LayerMask.NameToLayer(layerName);
-                if (layerId == -1 && layerName != "Default")
-                {
-                    return Response.Error(
-                        $"Invalid layer specified: '{layerName}'. Use a valid layer name."
-                    );
-                }
-                if (layerId != -1 && targetGo.layer != layerId)
-                {
-                    targetGo.layer = layerId;
-                    modified = true;
-                }
-            }
-
-            // Transform Modifications
-            var position = ParseVector3(@params["position"] as JArray);
-            var rotation = ParseVector3(@params["rotation"] as JArray);
-            var scale = ParseVector3(@params["scale"] as JArray);
-
-            if (position.HasValue && targetGo.transform.localPosition != position.Value)
-            {
-                targetGo.transform.localPosition = position.Value;
-                modified = true;
-            }
-            if (rotation.HasValue && targetGo.transform.localEulerAngles != rotation.Value)
-            {
-                targetGo.transform.localEulerAngles = rotation.Value;
-                modified = true;
-            }
-            if (scale.HasValue && targetGo.transform.localScale != scale.Value)
-            {
-                targetGo.transform.localScale = scale.Value;
-                modified = true;
-            }
-
-            // --- Component Modifications ---
-            // Note: These might need more specific Undo recording per component
-
-            // Remove Components
-            if (@params["componentsToRemove"] is JArray componentsToRemoveArray)
-            {
-                foreach (var compToken in componentsToRemoveArray)
-                {
-                    // ... (parsing logic as in CreateGameObject) ...
-                    var typeName = compToken.ToString();
-                    if (!string.IsNullOrEmpty(typeName))
-                    {
-                        var removeResult = RemoveComponentInternal(targetGo, typeName);
-                        if (removeResult != null)
-                            return removeResult; // Return error if removal failed
-                        modified = true;
-                    }
-                }
-            }
-
-            // Add Components (similar to create)
-            if (@params["componentsToAdd"] is JArray componentsToAddArrayModify)
-            {
-                foreach (var compToken in componentsToAddArrayModify)
-                {
-                    string typeName = null;
-                    JObject properties = null;
-                    if (compToken.Type == JTokenType.String)
-                        typeName = compToken.ToString();
-                    else if (compToken is JObject compObj)
-                    {
-                        typeName = compObj["typeName"]?.ToString();
-                        properties = compObj["properties"] as JObject;
-                    }
-
-                    if (!string.IsNullOrEmpty(typeName))
-                    {
-                        var addResult = AddComponentInternal(targetGo, typeName, properties);
-                        if (addResult != null)
-                            return addResult;
-                        modified = true;
-                    }
-                }
-            }
-
-            // Set Component Properties
-            var componentErrors = new List<object>();
-            if (@params["componentProperties"] is JObject componentPropertiesObj)
-            {
-                foreach (var prop in componentPropertiesObj.Properties())
-                {
-                    var compName = prop.Name;
-                    var propertiesToSet = prop.Value as JObject;
-                    if (propertiesToSet != null)
-                    {
-                        var setResult = SetComponentPropertiesInternal(
-                            targetGo,
-                            compName,
-                            propertiesToSet
-                        );
-                        if (setResult != null)
-                        {
-                            componentErrors.Add(setResult);
-                        }
-                        else
-                        {
-                            modified = true;
-                        }
-                    }
-                }
-            }
-
-            // Return component errors if any occurred (after processing all components)
-            if (componentErrors.Count > 0)
-            {
-                // Aggregate flattened error strings to make tests/API assertions simpler
-                var aggregatedErrors = new System.Collections.Generic.List<string>();
-                foreach (var errorObj in componentErrors)
-                {
-                    try
-                    {
-                        var dataProp = errorObj?.GetType().GetProperty("data");
-                        var dataVal = dataProp?.GetValue(errorObj);
-                        if (dataVal != null)
-                        {
-                            var errorsProp = dataVal.GetType().GetProperty("errors");
-                            var errorsEnum = errorsProp?.GetValue(dataVal) as System.Collections.IEnumerable;
-                            if (errorsEnum != null)
-                            {
-                                foreach (var item in errorsEnum)
-                                {
-                                    var s = item?.ToString();
-                                    if (!string.IsNullOrEmpty(s)) aggregatedErrors.Add(s);
-                                }
-                            }
-                        }
-                    }
-                    catch { }
-                }
-
-                return Response.Error(
-                    $"One or more component property operations failed on '{targetGo.name}'.",
-                    new { componentErrors, errors = aggregatedErrors }
-                );
-            }
-
-            if (!modified)
-            {
-                // Use the new serializer helper
-                // return Response.Success(
-                //     $"No modifications applied to GameObject '{targetGo.name}'.",
-                //     GetGameObjectData(targetGo));
-
-                return Response.Success(
-                    $"No modifications applied to GameObject '{targetGo.name}'.",
-                    Helpers.GameObjectSerializer.GetGameObjectData(targetGo)
-                );
-            }
-
-            EditorUtility.SetDirty(targetGo); // Mark scene as dirty
-            // Use the new serializer helper
-            return Response.Success(
-                $"GameObject '{targetGo.name}' modified successfully.",
-                Helpers.GameObjectSerializer.GetGameObjectData(targetGo)
-            );
-            // return Response.Success(
-            //     $"GameObject '{targetGo.name}' modified successfully.",
-            //     GetGameObjectData(targetGo));
-            
-        }
-
-        private static object DeleteGameObject(JToken targetToken, string searchMethod)
-        {
-            // Find potentially multiple objects if name/tag search is used without find_all=false implicitly
-            var targets = FindObjectsInternal(targetToken, searchMethod, true); // find_all=true for delete safety
-
-            if (targets.Count == 0)
-            {
-                return Response.Error(
-                    $"Target GameObject(s) ('{targetToken}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            var deletedObjects = new List<object>();
-            foreach (var targetGo in targets)
-            {
-                if (targetGo != null)
-                {
-                    var goName = targetGo.name;
-                    var goId = targetGo.GetInstanceID();
-                    // Use Undo.DestroyObjectImmediate for undo support
-                    Undo.DestroyObjectImmediate(targetGo);
-                    deletedObjects.Add(new { name = goName, instanceID = goId });
-                }
-            }
-
-            if (deletedObjects.Count > 0)
-            {
-                var message =
-                    targets.Count == 1
-                        ? $"GameObject '{deletedObjects[0].GetType().GetProperty("name").GetValue(deletedObjects[0])}' deleted successfully."
-                        : $"{deletedObjects.Count} GameObjects deleted successfully.";
-                return Response.Success(message, deletedObjects);
-            }
-            else
-            {
-                // Should not happen if targets.Count > 0 initially, but defensive check
-                return Response.Error("Failed to delete target GameObject(s).");
-            }
-        }
-
-        private static object FindGameObjects(
-            JObject @params,
-            JToken targetToken,
-            string searchMethod
-        )
-        {
-            var findAll = @params["findAll"]?.ToObject<bool>() ?? false;
-            var foundObjects = FindObjectsInternal(
-                targetToken,
-                searchMethod,
-                findAll,
-                @params
-            );
-
-            if (foundObjects.Count == 0)
-            {
-                return Response.Success("No matching GameObjects found.", new List<object>());
-            }
-
-            // Use the new serializer helper
-            //var results = foundObjects.Select(go => GetGameObjectData(go)).ToList();
-            var results = foundObjects.Select(go => Helpers.GameObjectSerializer.GetGameObjectData(go)).ToList();
-            return Response.Success($"Found {results.Count} GameObject(s).", results);
-        }
-
-        private static object GetComponentsFromTarget(string target, string searchMethod, bool includeNonPublicSerialized = true)
-        {
-            var targetGo = FindObjectInternal(target, searchMethod);
-            if (targetGo == null)
-            {
-                return Response.Error(
-                    $"Target GameObject ('{target}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            try
-            {
-                // --- Get components, immediately copy to list, and null original array ---
-                var originalComponents = targetGo.GetComponents<Component>();
-                var componentsToIterate = new List<Component>(originalComponents ?? Array.Empty<Component>()); // Copy immediately, handle null case
-                var componentCount = componentsToIterate.Count;
-                originalComponents = null; // Null the original reference
-                // Debug.Log($"[GetComponentsFromTarget] Found {componentCount} components on {targetGo.name}. Copied to list, nulled original. Starting REVERSE for loop...");
-                // --- End Copy and Null ---
-
-                var componentData = new List<object>();
-
-                for (var i = componentCount - 1; i >= 0; i--) // Iterate backwards over the COPY
-                {
-                    var c = componentsToIterate[i]; // Use the copy
-                    if (c == null)
-                    {
-                        // Debug.LogWarning($"[GetComponentsFromTarget REVERSE for] Encountered a null component at index {i} on {targetGo.name}. Skipping.");
-                        continue; // Safety check
-                    }
-                    // Debug.Log($"[GetComponentsFromTarget REVERSE for] Processing component: {c.GetType()?.FullName ?? "null"} (ID: {c.GetInstanceID()}) at index {i} on {targetGo.name}");
-                    try
-                    {
-                        var data = Helpers.GameObjectSerializer.GetComponentData(c, includeNonPublicSerialized);
-                        if (data != null) // Ensure GetComponentData didn't return null
-                        {
-                            componentData.Insert(0, data); // Insert at beginning to maintain original order in final list
-                        }
-                        // else
-                        // {
-                        //     Debug.LogWarning($"[GetComponentsFromTarget REVERSE for] GetComponentData returned null for component {c.GetType().FullName} (ID: {c.GetInstanceID()}) on {targetGo.name}. Skipping addition.");
-                        // }
-                    }
-                    catch (Exception ex)
-                    {
-                        Debug.LogError($"[GetComponentsFromTarget REVERSE for] Error processing component {c.GetType().FullName} (ID: {c.GetInstanceID()}) on {targetGo.name}: {ex.Message}\n{ex.StackTrace}");
-                        // Optionally add placeholder data or just skip
-                        componentData.Insert(0, new JObject( // Insert error marker at beginning
-                            new JProperty("typeName", c.GetType().FullName + " (Serialization Error)"),
-                            new JProperty("instanceID", c.GetInstanceID()),
-                            new JProperty("error", ex.Message)
-                        ));
-                    }
-                }
-                // Debug.Log($"[GetComponentsFromTarget] Finished REVERSE for loop.");
-
-                // Cleanup the list we created
-                componentsToIterate.Clear();
-                componentsToIterate = null;
-
-                return Response.Success(
-                    $"Retrieved {componentData.Count} components from '{targetGo.name}'.",
-                    componentData // List was built in original order
-                );
-            }
-            catch (Exception e)
-            {
-                return Response.Error(
-                    $"Error getting components from '{targetGo.name}': {e.Message}"
-                );
-            }
-        }
-
-        private static object AddComponentToTarget(
-            JObject @params,
-            JToken targetToken,
-            string searchMethod
-        )
-        {
-            var targetGo = FindObjectInternal(targetToken, searchMethod);
-            if (targetGo == null)
-            {
-                return Response.Error(
-                    $"Target GameObject ('{targetToken}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            string typeName = null;
-            JObject properties = null;
-
-            // Allow adding component specified directly or via componentsToAdd array (take first)
-            if (@params["componentName"] != null)
-            {
-                typeName = @params["componentName"]?.ToString();
-                properties = @params["componentProperties"]?[typeName] as JObject; // Check if props are nested under name
-            }
-            else if (
-                @params["componentsToAdd"] is JArray componentsToAddArray
-                && componentsToAddArray.Count > 0
-            )
-            {
-                var compToken = componentsToAddArray.First;
-                if (compToken.Type == JTokenType.String)
-                    typeName = compToken.ToString();
-                else if (compToken is JObject compObj)
-                {
-                    typeName = compObj["typeName"]?.ToString();
-                    properties = compObj["properties"] as JObject;
-                }
-            }
-
-            if (string.IsNullOrEmpty(typeName))
-            {
-                return Response.Error(
-                    "Component type name ('componentName' or first element in 'componentsToAdd') is required."
-                );
-            }
-
-            var addResult = AddComponentInternal(targetGo, typeName, properties);
-            if (addResult != null)
-                return addResult; // Return error
-
-            EditorUtility.SetDirty(targetGo);
-            // Use the new serializer helper
-            return Response.Success(
-                $"Component '{typeName}' added to '{targetGo.name}'.",
-                Helpers.GameObjectSerializer.GetGameObjectData(targetGo)
-            ); // Return updated GO data
-        }
-
-        private static object RemoveComponentFromTarget(
-            JObject @params,
-            JToken targetToken,
-            string searchMethod
-        )
-        {
-            var targetGo = FindObjectInternal(targetToken, searchMethod);
-            if (targetGo == null)
-            {
-                return Response.Error(
-                    $"Target GameObject ('{targetToken}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            string typeName = null;
-            // Allow removing component specified directly or via componentsToRemove array (take first)
-            if (@params["componentName"] != null)
-            {
-                typeName = @params["componentName"]?.ToString();
-            }
-            else if (
-                @params["componentsToRemove"] is JArray componentsToRemoveArray
-                && componentsToRemoveArray.Count > 0
-            )
-            {
-                typeName = componentsToRemoveArray.First?.ToString();
-            }
-
-            if (string.IsNullOrEmpty(typeName))
-            {
-                return Response.Error(
-                    "Component type name ('componentName' or first element in 'componentsToRemove') is required."
-                );
-            }
-
-            var removeResult = RemoveComponentInternal(targetGo, typeName);
-            if (removeResult != null)
-                return removeResult; // Return error
-
-            EditorUtility.SetDirty(targetGo);
-             // Use the new serializer helper
-            return Response.Success(
-                $"Component '{typeName}' removed from '{targetGo.name}'.",
-                Helpers.GameObjectSerializer.GetGameObjectData(targetGo)
-            );
-        }
-
-        private static object SetComponentPropertyOnTarget(
-            JObject @params,
-            JToken targetToken,
-            string searchMethod
-        )
-        {
-            var targetGo = FindObjectInternal(targetToken, searchMethod);
-            if (targetGo == null)
-            {
-                return Response.Error(
-                    $"Target GameObject ('{targetToken}') not found using method '{searchMethod ?? "default"}'."
-                );
-            }
-
-            var compName = @params["componentName"]?.ToString();
-            JObject propertiesToSet = null;
-
-            if (!string.IsNullOrEmpty(compName))
-            {
-                // Properties might be directly under componentProperties or nested under the component name
-                if (@params["componentProperties"] is JObject compProps)
-                {
-                    propertiesToSet = compProps[compName] as JObject ?? compProps; // Allow flat or nested structure
-                }
-            }
-            else
-            {
-                return Response.Error("'componentName' parameter is required.");
-            }
-
-            if (propertiesToSet == null || !propertiesToSet.HasValues)
-            {
-                return Response.Error(
-                    "'componentProperties' dictionary for the specified component is required and cannot be empty."
-                );
-            }
-
-            var setResult = SetComponentPropertiesInternal(targetGo, compName, propertiesToSet);
-            if (setResult != null)
-                return setResult; // Return error
-
-            EditorUtility.SetDirty(targetGo);
-             // Use the new serializer helper
-            return Response.Success(
-                $"Properties set for component '{compName}' on '{targetGo.name}'.",
-                Helpers.GameObjectSerializer.GetGameObjectData(targetGo)
-            );
-        }
-
-        // --- Internal Helpers ---
-
-        /// <summary>
-        /// Parses a JArray like [x, y, z] into a Vector3.
-        /// </summary>
-        private static Vector3? ParseVector3(JArray array)
-        {
-            if (array != null && array.Count == 3)
-            {
-                try
-                {
-                    return new Vector3(
-                        array[0].ToObject<float>(),
-                        array[1].ToObject<float>(),
-                        array[2].ToObject<float>()
-                    );
-                }
-                catch (Exception ex)
-                {
-                    Debug.LogWarning($"Failed to parse JArray as Vector3: {array}. Error: {ex.Message}");
-                }
-            }
-            return null;
-        }
-
-        /// <summary>
-        /// Finds a single GameObject based on token (ID, name, path) and search method.
-        /// </summary>
-        private static GameObject FindObjectInternal(
-            JToken targetToken,
-            string searchMethod,
-            JObject findParams = null
-        )
-        {
-            // If find_all is not explicitly false, we still want only one for most single-target operations.
-            var findAll = findParams?["findAll"]?.ToObject<bool>() ?? false;
-            // If a specific target ID is given, always find just that one.
-            if (
-                targetToken?.Type == JTokenType.Integer
-                || (searchMethod == "by_id" && int.TryParse(targetToken?.ToString(), out _))
-            )
-            {
-                findAll = false;
-            }
-            var results = FindObjectsInternal(
-                targetToken,
-                searchMethod,
-                findAll,
-                findParams
-            );
-            return results.Count > 0 ? results[0] : null;
-        }
-
-        /// <summary>
-        /// Core logic for finding GameObjects based on various criteria.
-        /// </summary>
-        private static List<GameObject> FindObjectsInternal(
-            JToken targetToken,
-            string searchMethod,
-            bool findAll,
-            JObject findParams = null
-        )
-        {
-            var results = new List<GameObject>();
-            var searchTerm = findParams?["searchTerm"]?.ToString() ?? targetToken?.ToString(); // Use searchTerm if provided, else the target itself
-            var searchInChildren = findParams?["searchInChildren"]?.ToObject<bool>() ?? false;
-            var searchInactive = findParams?["searchInactive"]?.ToObject<bool>() ?? false;
-
-            // Default search method if not specified
-            if (string.IsNullOrEmpty(searchMethod))
-            {
-                if (targetToken?.Type == JTokenType.Integer)
-                    searchMethod = "by_id";
-                else if (!string.IsNullOrEmpty(searchTerm) && searchTerm.Contains('/'))
-                    searchMethod = "by_path";
-                else
-                    searchMethod = "by_name"; // Default fallback
-            }
-
-            GameObject rootSearchObject = null;
-            // If searching in children, find the initial target first
-            if (searchInChildren && targetToken != null)
-            {
-                rootSearchObject = FindObjectInternal(targetToken, "by_id_or_name_or_path"); // Find the root for child search
-                if (rootSearchObject == null)
-                {
-                    Debug.LogWarning(
-                        $"[ManageGameObject.Find] Root object '{targetToken}' for child search not found."
-                    );
-                    return results; // Return empty if root not found
-                }
-            }
-
-            switch (searchMethod)
-            {
-                case "by_id":
-                    if (int.TryParse(searchTerm, out var instanceId))
-                    {
-                        // EditorUtility.InstanceIDToObject is slow, iterate manually if possible
-                        // GameObject obj = EditorUtility.InstanceIDToObject(instanceId) as GameObject;
-                        var allObjects = GetAllSceneObjects(searchInactive); // More efficient
-                        var obj = allObjects.FirstOrDefault(go =>
-                            go.GetInstanceID() == instanceId
-                        );
-                        if (obj != null)
-                            results.Add(obj);
-                    }
-                    break;
-                case "by_name":
-                    var searchPoolName = rootSearchObject
-                        ? rootSearchObject
-                            .GetComponentsInChildren<Transform>(searchInactive)
-                            .Select(t => t.gameObject)
-                        : GetAllSceneObjects(searchInactive);
-                    results.AddRange(searchPoolName.Where(go => go.name == searchTerm));
-                    break;
-                case "by_path":
-                    // Path is relative to scene root or rootSearchObject
-                    var foundTransform = rootSearchObject
-                        ? rootSearchObject.transform.Find(searchTerm)
-                        : GameObject.Find(searchTerm)?.transform;
-                    if (foundTransform != null)
-                        results.Add(foundTransform.gameObject);
-                    break;
-                case "by_tag":
-                    var searchPoolTag = rootSearchObject
-                        ? rootSearchObject
-                            .GetComponentsInChildren<Transform>(searchInactive)
-                            .Select(t => t.gameObject)
-                        : GetAllSceneObjects(searchInactive);
-                    results.AddRange(searchPoolTag.Where(go => go.CompareTag(searchTerm)));
-                    break;
-                case "by_layer":
-                    var searchPoolLayer = rootSearchObject
-                        ? rootSearchObject
-                            .GetComponentsInChildren<Transform>(searchInactive)
-                            .Select(t => t.gameObject)
-                        : GetAllSceneObjects(searchInactive);
-                    if (int.TryParse(searchTerm, out var layerIndex))
-                    {
-                        results.AddRange(searchPoolLayer.Where(go => go.layer == layerIndex));
-                    }
-                    else
-                    {
-                        var namedLayer = LayerMask.NameToLayer(searchTerm);
-                        if (namedLayer != -1)
-                            results.AddRange(searchPoolLayer.Where(go => go.layer == namedLayer));
-                    }
-                    break;
-                case "by_component":
-                    var componentType = FindType(searchTerm);
-                    if (componentType != null)
-                    {
-                        // Determine FindObjectsInactive based on the searchInactive flag
-                        var findInactive = searchInactive
-                            ? FindObjectsInactive.Include
-                            : FindObjectsInactive.Exclude;
-                        // Replace FindObjectsOfType with FindObjectsByType, specifying the sorting mode and inactive state
-                        var searchPoolComp = rootSearchObject
-                            ? rootSearchObject
-                                .GetComponentsInChildren(componentType, searchInactive)
-                                .Select(c => (c as Component).gameObject)
-                            : UnityEngine
-                                .Object.FindObjectsByType(
-                                    componentType,
-                                    findInactive,
-                                    FindObjectsSortMode.None
-                                )
-                                .Select(c => (c as Component).gameObject);
-                        results.AddRange(searchPoolComp.Where(go => go != null)); // Ensure GO is valid
-                    }
-                    else
-                    {
-                        Debug.LogWarning(
-                            $"[ManageGameObject.Find] Component type not found: {searchTerm}"
-                        );
-                    }
-                    break;
-                case "by_id_or_name_or_path": // Helper method used internally
-                    if (int.TryParse(searchTerm, out var id))
-                    {
-                        var allObjectsId = GetAllSceneObjects(true); // Search inactive for internal lookup
-                        var objById = allObjectsId.FirstOrDefault(go =>
-                            go.GetInstanceID() == id
-                        );
-                        if (objById != null)
-                        {
-                            results.Add(objById);
-                            break;
-                        }
-                    }
-                    var objByPath = GameObject.Find(searchTerm);
-                    if (objByPath != null)
-                    {
-                        results.Add(objByPath);
-                        break;
-                    }
-
-                    var allObjectsName = GetAllSceneObjects(true);
-                    results.AddRange(allObjectsName.Where(go => go.name == searchTerm));
-                    break;
-                default:
-                    Debug.LogWarning(
-                        $"[ManageGameObject.Find] Unknown search method: {searchMethod}"
-                    );
-                    break;
-            }
-
-            // If only one result is needed, return just the first one found.
-            if (!findAll && results.Count > 1)
-            {
-                return new List<GameObject> { results[0] };
-            }
-
-            return results.Distinct().ToList(); // Ensure uniqueness
-        }
-
-        // Helper to get all scene objects efficiently
-        private static IEnumerable<GameObject> GetAllSceneObjects(bool includeInactive)
-        {
-            // SceneManager.GetActiveScene().GetRootGameObjects() is faster than FindObjectsOfType<GameObject>()
-            var rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();
-            var allObjects = new List<GameObject>();
-            foreach (var root in rootObjects)
-            {
-                allObjects.AddRange(
-                    root.GetComponentsInChildren<Transform>(includeInactive)
-                        .Select(t => t.gameObject)
-                );
-            }
-            return allObjects;
-        }
-
-        /// <summary>
-        /// Adds a component by type name and optionally sets properties.
-        /// Returns null on success, or an error response object on failure.
-        /// </summary>
-        private static object AddComponentInternal(
-            GameObject targetGo,
-            string typeName,
-            JObject properties
-        )
-        {
-            var componentType = FindType(typeName);
-            if (componentType == null)
-            {
-                return Response.Error(
-                    $"Component type '{typeName}' not found or is not a valid Component."
-                );
-            }
-            if (!typeof(Component).IsAssignableFrom(componentType))
-            {
-                return Response.Error($"Type '{typeName}' is not a Component.");
-            }
-
-            // Prevent adding Transform again
-            if (componentType == typeof(Transform))
-            {
-                return Response.Error("Cannot add another Transform component.");
-            }
-
-            // Check for 2D/3D physics component conflicts
-            var isAdding2DPhysics =
-                typeof(Rigidbody2D).IsAssignableFrom(componentType)
-                || typeof(Collider2D).IsAssignableFrom(componentType);
-            var isAdding3DPhysics =
-                typeof(Rigidbody).IsAssignableFrom(componentType)
-                || typeof(Collider).IsAssignableFrom(componentType);
-
-            if (isAdding2DPhysics)
-            {
-                // Check if the GameObject already has any 3D Rigidbody or Collider
-                if (
-                    targetGo.GetComponent<Rigidbody>() != null
-                    || targetGo.GetComponent<Collider>() != null
-                )
-                {
-                    return Response.Error(
-                        $"Cannot add 2D physics component '{typeName}' because the GameObject '{targetGo.name}' already has a 3D Rigidbody or Collider."
-                    );
-                }
-            }
-            else if (isAdding3DPhysics)
-            {
-                // Check if the GameObject already has any 2D Rigidbody or Collider
-                if (
-                    targetGo.GetComponent<Rigidbody2D>() != null
-                    || targetGo.GetComponent<Collider2D>() != null
-                )
-                {
-                    return Response.Error(
-                        $"Cannot add 3D physics component '{typeName}' because the GameObject '{targetGo.name}' already has a 2D Rigidbody or Collider."
-                    );
-                }
-            }
-
-            try
-            {
-                // Use Undo.AddComponent for undo support
-                var newComponent = Undo.AddComponent(targetGo, componentType);
-                if (newComponent == null)
-                {
-                    return Response.Error(
-                        $"Failed to add component '{typeName}' to '{targetGo.name}'. It might be disallowed (e.g., adding script twice)."
-                    );
-                }
-
-                // Set default values for specific component types
-                if (newComponent is Light light)
-                {
-                    // Default newly added lights to directional
-                    light.type = LightType.Directional;
-                }
-
-                // Set properties if provided
-                if (properties != null)
-                {
-                    var setResult = SetComponentPropertiesInternal(
-                        targetGo,
-                        typeName,
-                        properties,
-                        newComponent
-                    ); // Pass the new component instance
-                    if (setResult != null)
-                    {
-                        // If setting properties failed, maybe remove the added component?
-                        Undo.DestroyObjectImmediate(newComponent);
-                        return setResult; // Return the error from setting properties
-                    }
-                }
-
-                return null; // Success
-            }
-            catch (Exception e)
-            {
-                return Response.Error(
-                    $"Error adding component '{typeName}' to '{targetGo.name}': {e.Message}"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Removes a component by type name.
-        /// Returns null on success, or an error response object on failure.
-        /// </summary>
-        private static object RemoveComponentInternal(GameObject targetGo, string typeName)
-        {
-            var componentType = FindType(typeName);
-            if (componentType == null)
-            {
-                return Response.Error($"Component type '{typeName}' not found for removal.");
-            }
-
-            // Prevent removing essential components
-            if (componentType == typeof(Transform))
-            {
-                return Response.Error("Cannot remove the Transform component.");
-            }
-
-            var componentToRemove = targetGo.GetComponent(componentType);
-            if (componentToRemove == null)
-            {
-                return Response.Error(
-                    $"Component '{typeName}' not found on '{targetGo.name}' to remove."
-                );
-            }
-
-            try
-            {
-                // Use Undo.DestroyObjectImmediate for undo support
-                Undo.DestroyObjectImmediate(componentToRemove);
-                return null; // Success
-            }
-            catch (Exception e)
-            {
-                return Response.Error(
-                    $"Error removing component '{typeName}' from '{targetGo.name}': {e.Message}"
-                );
-            }
-        }
-
-        /// <summary>
-        /// Sets properties on a component.
-        /// Returns null on success, or an error response object on failure.
-        /// </summary>
-        private static object SetComponentPropertiesInternal(
-            GameObject targetGo,
-            string compName,
-            JObject propertiesToSet,
-            Component targetComponentInstance = null
-        )
-        {
-            var targetComponent = targetComponentInstance;
-            if (targetComponent == null)
-            {
-                if (ComponentResolver.TryResolve(compName, out var compType, out var compError))
-                {
-                    targetComponent = targetGo.GetComponent(compType);
-                }
-                else
-                {
-                    targetComponent = targetGo.GetComponent(compName); // fallback to string-based lookup
-                }
-            }
-            if (targetComponent == null)
-            {
-                return Response.Error(
-                    $"Component '{compName}' not found on '{targetGo.name}' to set properties."
-                );
-            }
-
-            Undo.RecordObject(targetComponent, "Set Component Properties");
-
-            var failures = new List<string>();
-            foreach (var prop in propertiesToSet.Properties())
-            {
-                var propName = prop.Name;
-                var propValue = prop.Value;
-
-                try
-                {
-                    var setResult = SetProperty(targetComponent, propName, propValue);
-                    if (!setResult)
-                    {
-                        var availableProperties = ComponentResolver.GetAllComponentProperties(targetComponent.GetType());
-                        var suggestions = ComponentResolver.GetAIPropertySuggestions(propName, availableProperties);
-                        var msg = suggestions.Any()
-                            ? $"Property '{propName}' not found. Did you mean: {string.Join(", ", suggestions)}? Available: [{string.Join(", ", availableProperties)}]"
-                            : $"Property '{propName}' not found. Available: [{string.Join(", ", availableProperties)}]";
-                        Debug.LogWarning($"[ManageGameObject] {msg}");
-                        failures.Add(msg);
-                    }
-                }
-                catch (Exception e)
-                {
-                    Debug.LogError(
-                        $"[ManageGameObject] Error setting property '{propName}' on '{compName}': {e.Message}"
-                    );
-                    failures.Add($"Error setting '{propName}': {e.Message}");
-                }
-            }
-            EditorUtility.SetDirty(targetComponent);
-            return failures.Count == 0
-                ? null
-                : Response.Error($"One or more properties failed on '{compName}'.", new { errors = failures });
-        }
-
-        /// <summary>
-        /// Helper to set a property or field via reflection, handling basic types.
-        /// </summary>
-        private static bool SetProperty(object target, string memberName, JToken value)
-        {
-            var type = target.GetType();
-            var flags =
-                BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase;
-
-             // Use shared serializer to avoid per-call allocation
-             var inputSerializer = InputSerializer;
-
-            try
-            {
-                // Handle special case for materials with dot notation (material.property)
-                // Examples: material.color, sharedMaterial.color, materials[0].color
-                if (memberName.Contains('.') || memberName.Contains('['))
-                {
-                    // Pass the inputSerializer down for nested conversions
-                    return SetNestedProperty(target, memberName, value, inputSerializer);
-                }
-
-                var propInfo = type.GetProperty(memberName, flags);
-                if (propInfo != null && propInfo.CanWrite)
-                {
-                    // Use the inputSerializer for conversion
-                    var convertedValue = ConvertJTokenToType(value, propInfo.PropertyType, inputSerializer);
-                    if (convertedValue != null || value.Type == JTokenType.Null) // Allow setting null
-                    {
-                        propInfo.SetValue(target, convertedValue);
-                        return true;
-                    }
-                    else {
-                         Debug.LogWarning($"[SetProperty] Conversion failed for property '{memberName}' (Type: {propInfo.PropertyType.Name}) from token: {value.ToString(Formatting.None)}");
-                    }
-                }
-                else
-                {
-                    var fieldInfo = type.GetField(memberName, flags);
-                    if (fieldInfo != null) // Check if !IsLiteral?
-                    {
-                         // Use the inputSerializer for conversion
-                        var convertedValue = ConvertJTokenToType(value, fieldInfo.FieldType, inputSerializer);
-                         if (convertedValue != null || value.Type == JTokenType.Null) // Allow setting null
-                        {
-                            fieldInfo.SetValue(target, convertedValue);
-                            return true;
-                        }
-                         else {
-                             Debug.LogWarning($"[SetProperty] Conversion failed for field '{memberName}' (Type: {fieldInfo.FieldType.Name}) from token: {value.ToString(Formatting.None)}");
-                         }
-                    }
-                    else
-                    {
-                        // Try NonPublic [SerializeField] fields
-                        var npField = type.GetField(memberName, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);
-                        if (npField != null && npField.GetCustomAttribute<SerializeField>() != null)
-                        {
-                            var convertedValue = ConvertJTokenToType(value, npField.FieldType, inputSerializer);
-                            if (convertedValue != null || value.Type == JTokenType.Null)
-                            {
-                                npField.SetValue(target, convertedValue);
-                                return true;
-                            }
-                        }
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError(
-                    $"[SetProperty] Failed to set '{memberName}' on {type.Name}: {ex.Message}\nToken: {value.ToString(Formatting.None)}"
-                );
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Sets a nested property using dot notation (e.g., "material.color") or array access (e.g., "materials[0]")
-        /// </summary>
-        // Pass the input serializer for conversions
-        //Using the serializer helper
-        private static bool SetNestedProperty(object target, string path, JToken value, JsonSerializer inputSerializer)
-        {
-            try
-            {
-                // Split the path into parts (handling both dot notation and array indexing)
-                var pathParts = SplitPropertyPath(path);
-                if (pathParts.Length == 0)
-                    return false;
-
-                var currentObject = target;
-                var currentType = currentObject.GetType();
-                var flags =
-                    BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase;
-
-                // Traverse the path until we reach the final property
-                for (var i = 0; i < pathParts.Length - 1; i++)
-                {
-                    var part = pathParts[i];
-                    var isArray = false;
-                    var arrayIndex = -1;
-
-                    // Check if this part contains array indexing
-                    if (part.Contains("["))
-                    {
-                        var startBracket = part.IndexOf('[');
-                        var endBracket = part.IndexOf(']');
-                        if (startBracket > 0 && endBracket > startBracket)
-                        {
-                            var indexStr = part.Substring(
-                                startBracket + 1,
-                                endBracket - startBracket - 1
-                            );
-                            if (int.TryParse(indexStr, out arrayIndex))
-                            {
-                                isArray = true;
-                                part = part.Substring(0, startBracket);
-                            }
-                        }
-                    }
-                    // Get the property/field
-                    var propInfo = currentType.GetProperty(part, flags);
-                    FieldInfo fieldInfo = null;
-                    if (propInfo == null)
-                    {
-                        fieldInfo = currentType.GetField(part, flags);
-                        if (fieldInfo == null)
-                        {
-                            Debug.LogWarning(
-                                $"[SetNestedProperty] Could not find property or field '{part}' on type '{currentType.Name}'"
-                            );
-                            return false;
-                        }
-                    }
-
-                    // Get the value
-                    currentObject =
-                        propInfo != null
-                            ? propInfo.GetValue(currentObject)
-                            : fieldInfo.GetValue(currentObject);
-                    //Need to stop if current property is null
-                    if (currentObject == null)
-                    {
-                        Debug.LogWarning(
-                            $"[SetNestedProperty] Property '{part}' is null, cannot access nested properties."
-                        );
-                        return false;
-                    }
-                    // If this part was an array or list, access the specific index
-                    if (isArray)
-                    {
-                        if (currentObject is Material[])
-                        {
-                            var materials = currentObject as Material[];
-                            if (arrayIndex < 0 || arrayIndex >= materials.Length)
-                            {
-                                Debug.LogWarning(
-                                    $"[SetNestedProperty] Material index {arrayIndex} out of range (0-{materials.Length - 1})"
-                                );
-                                return false;
-                            }
-                            currentObject = materials[arrayIndex];
-                        }
-                        else if (currentObject is System.Collections.IList)
-                        {
-                            var list = currentObject as System.Collections.IList;
-                            if (arrayIndex < 0 || arrayIndex >= list.Count)
-                            {
-                                Debug.LogWarning(
-                                    $"[SetNestedProperty] Index {arrayIndex} out of range (0-{list.Count - 1})"
-                                );
-                                return false;
-                            }
-                            currentObject = list[arrayIndex];
-                        }
-                        else
-                        {
-                            Debug.LogWarning(
-                                $"[SetNestedProperty] Property '{part}' is not an array or list, cannot access by index."
-                            );
-                            return false;
-                        }
-                    }
-                    currentType = currentObject.GetType();
-                }
-
-                // Set the final property
-                var finalPart = pathParts[pathParts.Length - 1];
-
-                // Special handling for Material properties (shader properties)
-                if (currentObject is Material material && finalPart.StartsWith("_"))
-                {
-                    // Use the serializer to convert the JToken value first
-                    if (value is JArray jArray)
-                    {
-                        // Try converting to known types that SetColor/SetVector accept
-                        if (jArray.Count == 4) {
-                            try { var color = value.ToObject<Color>(inputSerializer); material.SetColor(finalPart, color); return true; } catch { }
-                            try { var vec = value.ToObject<Vector4>(inputSerializer); material.SetVector(finalPart, vec); return true; } catch { }
-                        } else if (jArray.Count == 3) {
-                            try { var color = value.ToObject<Color>(inputSerializer); material.SetColor(finalPart, color); return true; } catch { } // ToObject handles conversion to Color
-                        } else if (jArray.Count == 2) {
-                            try { var vec = value.ToObject<Vector2>(inputSerializer); material.SetVector(finalPart, vec); return true; } catch { }
-                        }
-                    }
-                    else if (value.Type == JTokenType.Float || value.Type == JTokenType.Integer)
-                    {
-                        try { material.SetFloat(finalPart, value.ToObject<float>(inputSerializer)); return true; } catch { }
-                    }
-                    else if (value.Type == JTokenType.Boolean)
-                    {
-                        try { material.SetFloat(finalPart, value.ToObject<bool>(inputSerializer) ? 1f : 0f); return true; } catch { }
-                    }
-                    else if (value.Type == JTokenType.String)
-                    {
-                        // Try converting to Texture using the serializer/converter
-                        try {
-                            var texture = value.ToObject<Texture>(inputSerializer);
-                            if (texture != null) {
-                                material.SetTexture(finalPart, texture);
-                                return true;
-                            }
-                        } catch { }
-                    }
-
-                    Debug.LogWarning(
-                        $"[SetNestedProperty] Unsupported or failed conversion for material property '{finalPart}' from value: {value.ToString(Formatting.None)}"
-                    );
-                    return false;
-                }
-
-                // For standard properties (not shader specific)
-                var finalPropInfo = currentType.GetProperty(finalPart, flags);
-                if (finalPropInfo != null && finalPropInfo.CanWrite)
-                {
-                    // Use the inputSerializer for conversion
-                    var convertedValue = ConvertJTokenToType(value, finalPropInfo.PropertyType, inputSerializer);
-                    if (convertedValue != null || value.Type == JTokenType.Null)
-                    {
-                        finalPropInfo.SetValue(currentObject, convertedValue);
-                        return true;
-                    }
-                    else {
-                        Debug.LogWarning($"[SetNestedProperty] Final conversion failed for property '{finalPart}' (Type: {finalPropInfo.PropertyType.Name}) from token: {value.ToString(Formatting.None)}");
-                    }
-                }
-                else
-                {
-                    var finalFieldInfo = currentType.GetField(finalPart, flags);
-                    if (finalFieldInfo != null)
-                    {
-                        // Use the inputSerializer for conversion
-                        var convertedValue = ConvertJTokenToType(value, finalFieldInfo.FieldType, inputSerializer);
-                        if (convertedValue != null || value.Type == JTokenType.Null)
-                        {
-                            finalFieldInfo.SetValue(currentObject, convertedValue);
-                            return true;
-                        }
-                        else {
-                            Debug.LogWarning($"[SetNestedProperty] Final conversion failed for field '{finalPart}' (Type: {finalFieldInfo.FieldType.Name}) from token: {value.ToString(Formatting.None)}");
-                        }
-                    }
-                    else
-                    {
-                        Debug.LogWarning(
-                            $"[SetNestedProperty] Could not find final writable property or field '{finalPart}' on type '{currentType.Name}'"
-                        );
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError(
-                    $"[SetNestedProperty] Error setting nested property '{path}': {ex.Message}\nToken: {value.ToString(Formatting.None)}"
-                );
-            }
-
-            return false;
-        }
-
-
-        /// <summary>
-        /// Split a property path into parts, handling both dot notation and array indexers
-        /// </summary>
-        private static string[] SplitPropertyPath(string path)
-        {
-            // Handle complex paths with both dots and array indexers
-            var parts = new List<string>();
-            var startIndex = 0;
-            var inBrackets = false;
-
-            for (var i = 0; i < path.Length; i++)
-            {
-                var c = path[i];
-
-                if (c == '[')
-                {
-                    inBrackets = true;
-                }
-                else if (c == ']')
-                {
-                    inBrackets = false;
-                }
-                else if (c == '.' && !inBrackets)
-                {
-                    // Found a dot separator outside of brackets
-                    parts.Add(path.Substring(startIndex, i - startIndex));
-                    startIndex = i + 1;
-                }
-            }
-            if (startIndex < path.Length)
-            {
-                parts.Add(path.Substring(startIndex));
-            }
-            return parts.ToArray();
-        }
-
-        /// <summary>
-        /// Simple JToken to Type conversion for common Unity types, using JsonSerializer.
-        /// </summary>
-         // Pass the input serializer
-        private static object ConvertJTokenToType(JToken token, Type targetType, JsonSerializer inputSerializer)
-        {
-            if (token == null || token.Type == JTokenType.Null)
-            {
-                if (targetType.IsValueType && Nullable.GetUnderlyingType(targetType) == null)
-                {
-                    Debug.LogWarning($"Cannot assign null to non-nullable value type {targetType.Name}. Returning default value.");
-                    return Activator.CreateInstance(targetType);
-                }
-                return null;
-            }
-
-            try
-            {
-                // Use the provided serializer instance which includes our custom converters
-                return token.ToObject(targetType, inputSerializer);
-            }
-            catch (JsonSerializationException jsonEx)
-            {
-                 Debug.LogError($"JSON Deserialization Error converting token to {targetType.FullName}: {jsonEx.Message}\nToken: {token.ToString(Formatting.None)}");
-                 // Optionally re-throw or return null/default
-                 // return targetType.IsValueType ? Activator.CreateInstance(targetType) : null;
-                 throw; // Re-throw to indicate failure higher up
-            }
-            catch (ArgumentException argEx)
-            {
-                Debug.LogError($"Argument Error converting token to {targetType.FullName}: {argEx.Message}\nToken: {token.ToString(Formatting.None)}");
-                 throw;
-            }
-            catch (Exception ex)
-            {
-                 Debug.LogError($"Unexpected error converting token to {targetType.FullName}: {ex}\nToken: {token.ToString(Formatting.None)}");
-                 throw;
-            }
-            // If ToObject succeeded, it would have returned. If it threw, we wouldn't reach here.
-             // This fallback logic is likely unreachable if ToObject covers all cases or throws on failure.
-             // Debug.LogWarning($"Conversion failed for token to {targetType.FullName}. Token: {token.ToString(Formatting.None)}");
-             // return targetType.IsValueType ? Activator.CreateInstance(targetType) : null;
-        }
-
-        // --- ParseJTokenTo... helpers are likely redundant now with the serializer approach ---
-        // Keep them temporarily for reference or if specific fallback logic is ever needed.
-
-        private static Vector3 ParseJTokenToVector3(JToken token)
-        {
-            // ... (implementation - likely replaced by Vector3Converter) ...
-            // Consider removing these if the serializer handles them reliably.
-            if (token is JObject obj && obj.ContainsKey("x") && obj.ContainsKey("y") && obj.ContainsKey("z"))
-            {
-                return new Vector3(obj["x"].ToObject<float>(), obj["y"].ToObject<float>(), obj["z"].ToObject<float>());
-            }
-            if (token is JArray arr && arr.Count >= 3)
-            {
-                 return new Vector3(arr[0].ToObject<float>(), arr[1].ToObject<float>(), arr[2].ToObject<float>());
-            }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Vector3 using fallback. Returning Vector3.zero.");
-            return Vector3.zero;
-
-        }
-        private static Vector2 ParseJTokenToVector2(JToken token)
-        {
-            // ... (implementation - likely replaced by Vector2Converter) ...
-             if (token is JObject obj && obj.ContainsKey("x") && obj.ContainsKey("y"))
-            {
-                return new Vector2(obj["x"].ToObject<float>(), obj["y"].ToObject<float>());
-            }
-            if (token is JArray arr && arr.Count >= 2)
-            {
-                 return new Vector2(arr[0].ToObject<float>(), arr[1].ToObject<float>());
-            }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Vector2 using fallback. Returning Vector2.zero.");
-            return Vector2.zero;
-        }
-        private static Quaternion ParseJTokenToQuaternion(JToken token)
-        {
-            // ... (implementation - likely replaced by QuaternionConverter) ...
-            if (token is JObject obj && obj.ContainsKey("x") && obj.ContainsKey("y") && obj.ContainsKey("z") && obj.ContainsKey("w"))
-            {
-                return new Quaternion(obj["x"].ToObject<float>(), obj["y"].ToObject<float>(), obj["z"].ToObject<float>(), obj["w"].ToObject<float>());
-            }
-            if (token is JArray arr && arr.Count >= 4)
-            {
-                 return new Quaternion(arr[0].ToObject<float>(), arr[1].ToObject<float>(), arr[2].ToObject<float>(), arr[3].ToObject<float>());
-            }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Quaternion using fallback. Returning Quaternion.identity.");
-            return Quaternion.identity;
-        }
-        private static Color ParseJTokenToColor(JToken token)
-        {
-             // ... (implementation - likely replaced by ColorConverter) ...
-            if (token is JObject obj && obj.ContainsKey("r") && obj.ContainsKey("g") && obj.ContainsKey("b") && obj.ContainsKey("a"))
-            {
-                return new Color(obj["r"].ToObject<float>(), obj["g"].ToObject<float>(), obj["b"].ToObject<float>(), obj["a"].ToObject<float>());
-            }
-            if (token is JArray arr && arr.Count >= 4)
-            {
-                 return new Color(arr[0].ToObject<float>(), arr[1].ToObject<float>(), arr[2].ToObject<float>(), arr[3].ToObject<float>());
-            }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Color using fallback. Returning Color.white.");
-            return Color.white;
-        }
-        private static Rect ParseJTokenToRect(JToken token)
-        {
-             // ... (implementation - likely replaced by RectConverter) ...
-            if (token is JObject obj && obj.ContainsKey("x") && obj.ContainsKey("y") && obj.ContainsKey("width") && obj.ContainsKey("height"))
-            {
-                return new Rect(obj["x"].ToObject<float>(), obj["y"].ToObject<float>(), obj["width"].ToObject<float>(), obj["height"].ToObject<float>());
-            }
-            if (token is JArray arr && arr.Count >= 4)
-            {
-                 return new Rect(arr[0].ToObject<float>(), arr[1].ToObject<float>(), arr[2].ToObject<float>(), arr[3].ToObject<float>());
-            }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Rect using fallback. Returning Rect.zero.");
-            return Rect.zero;
-        }
-        private static Bounds ParseJTokenToBounds(JToken token)
-        {
-             // ... (implementation - likely replaced by BoundsConverter) ...
-            if (token is JObject obj && obj.ContainsKey("center") && obj.ContainsKey("size"))
-            {
-                // Requires Vector3 conversion, which should ideally use the serializer too
-                 var center = ParseJTokenToVector3(obj["center"]); // Or use obj["center"].ToObject<Vector3>(inputSerializer)
-                 var size = ParseJTokenToVector3(obj["size"]);     // Or use obj["size"].ToObject<Vector3>(inputSerializer)
-                return new Bounds(center, size);
-            }
-            // Array fallback for Bounds is less intuitive, maybe remove?
-            // if (token is JArray arr && arr.Count >= 6)
-            // {
-            //      return new Bounds(new Vector3(arr[0].ToObject<float>(), arr[1].ToObject<float>(), arr[2].ToObject<float>()), new Vector3(arr[3].ToObject<float>(), arr[4].ToObject<float>(), arr[5].ToObject<float>()));
-            // }
-            Debug.LogWarning($"Could not parse JToken '{token}' as Bounds using fallback. Returning new Bounds(Vector3.zero, Vector3.zero).");
-            return new Bounds(Vector3.zero, Vector3.zero);
-        }
-        // --- End Redundant Parse Helpers ---
-
-         /// <summary>
-         /// Finds a specific UnityEngine.Object based on a find instruction JObject.
-         /// Primarily used by UnityEngineObjectConverter during deserialization.
-         /// </summary>
-         // Made public static so UnityEngineObjectConverter can call it. Moved from ConvertJTokenToType.
-         public static UnityEngine.Object FindObjectByInstruction(JObject instruction, Type targetType)
-         {
-             var findTerm = instruction["find"]?.ToString();
-             var method = instruction["method"]?.ToString()?.ToLower();
-             var componentName = instruction["component"]?.ToString(); // Specific component to get
-
-             if (string.IsNullOrEmpty(findTerm))
-             {
-                 Debug.LogWarning("Find instruction missing 'find' term.");
-                 return null;
-             }
-
-             // Use a flexible default search method if none provided
-             var searchMethodToUse = string.IsNullOrEmpty(method) ? "by_id_or_name_or_path" : method;
-
-             // If the target is an asset (Material, Texture, ScriptableObject etc.) try AssetDatabase first
-             if (typeof(Material).IsAssignableFrom(targetType) ||
-                 typeof(Texture).IsAssignableFrom(targetType) ||
-                 typeof(ScriptableObject).IsAssignableFrom(targetType) ||
-                 targetType.FullName.StartsWith("UnityEngine.U2D") || // Sprites etc.
-                 typeof(AudioClip).IsAssignableFrom(targetType) ||
-                 typeof(AnimationClip).IsAssignableFrom(targetType) ||
-                 typeof(Font).IsAssignableFrom(targetType) ||
-                 typeof(Shader).IsAssignableFrom(targetType) ||
-                 typeof(ComputeShader).IsAssignableFrom(targetType) ||
-                 typeof(GameObject).IsAssignableFrom(targetType) && findTerm.StartsWith("Assets/")) // Prefab check
-             {
-                // Try loading directly by path/GUID first
-                var asset = AssetDatabase.LoadAssetAtPath(findTerm, targetType);
-                 if (asset != null) return asset;
-                 asset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(findTerm); // Try generic if type specific failed
-                 if (asset != null && targetType.IsAssignableFrom(asset.GetType())) return asset;
-
-
-                 // If direct path failed, try finding by name/type using FindAssets
-                 var searchFilter = $"t:{targetType.Name} {System.IO.Path.GetFileNameWithoutExtension(findTerm)}"; // Search by type and name
-                 var guids = AssetDatabase.FindAssets(searchFilter);
-
-                 if (guids.Length == 1)
-                 {
-                     asset = AssetDatabase.LoadAssetAtPath(AssetDatabase.GUIDToAssetPath(guids[0]), targetType);
-                     if (asset != null) return asset;
-                 }
-                 else if (guids.Length > 1)
-                 {
-                     Debug.LogWarning($"[FindObjectByInstruction] Ambiguous asset find: Found {guids.Length} assets matching filter '{searchFilter}'. Provide a full path or unique name.");
-                     // Optionally return the first one? Or null? Returning null is safer.
-                     return null;
-                 }
-                 // If still not found, fall through to scene search (though unlikely for assets)
-             }
-
-
-             // --- Scene Object Search ---
-             // Find the GameObject using the internal finder
-             var foundGo = FindObjectInternal(new JValue(findTerm), searchMethodToUse);
-
-             if (foundGo == null)
-             {
-                 // Don't warn yet, could still be an asset not found above
-                 // Debug.LogWarning($"Could not find GameObject using instruction: {instruction}");
-                 return null;
-             }
-
-             // Now, get the target object/component from the found GameObject
-             if (targetType == typeof(GameObject))
-             {
-                 return foundGo; // We were looking for a GameObject
-             }
-             else if (typeof(Component).IsAssignableFrom(targetType))
-             {
-                 var componentToGetType = targetType;
-                 if (!string.IsNullOrEmpty(componentName))
-                 {
-                     var specificCompType = FindType(componentName);
-                     if (specificCompType != null && typeof(Component).IsAssignableFrom(specificCompType))
-                     {
-                         componentToGetType = specificCompType;
-                     }
-                     else
-                     {
-                         Debug.LogWarning($"Could not find component type '{componentName}' specified in find instruction. Falling back to target type '{targetType.Name}'.");
-                     }
-                 }
-
-                 var foundComp = foundGo.GetComponent(componentToGetType);
-                 if (foundComp == null)
-                 {
-                     Debug.LogWarning($"Found GameObject '{foundGo.name}' but could not find component of type '{componentToGetType.Name}'.");
-                 }
-                 return foundComp;
-             }
-             else
-             {
-                  Debug.LogWarning($"Find instruction handling not implemented for target type: {targetType.Name}");
-                  return null;
-             }
-         }
-
-
-        /// <summary>
-        /// Robust component resolver that avoids Assembly.LoadFrom and works with asmdefs.
-        /// Searches already-loaded assemblies, prioritizing runtime script assemblies.
-        /// </summary>
-        private static Type FindType(string typeName)
-        {
-            if (ComponentResolver.TryResolve(typeName, out var resolvedType, out var error))
-            {
-                return resolvedType;
-            }
-            
-            // Log the resolver error if type wasn't found
-            if (!string.IsNullOrEmpty(error))
-            {
-                Debug.LogWarning($"[FindType] {error}");
-            }
-            
-            return null;
-        }
-    }
-
-    /// <summary>
-    /// Robust component resolver that avoids Assembly.LoadFrom and supports assembly definitions.
-    /// Prioritizes runtime (Player) assemblies over Editor assemblies.
-    /// </summary>
-    internal static class ComponentResolver
-    {
-        private static readonly Dictionary<string, Type> CacheByFqn = new(StringComparer.Ordinal);
-        private static readonly Dictionary<string, Type> CacheByName = new(StringComparer.Ordinal);
-
-        /// <summary>
-        /// Resolve a Component/MonoBehaviour type by short or fully-qualified name.
-        /// Prefers runtime (Player) script assemblies; falls back to Editor assemblies.
-        /// Never uses Assembly.LoadFrom.
-        /// </summary>
-        public static bool TryResolve(string nameOrFullName, out Type type, out string error)
-        {
-            error = string.Empty;
-            type = null!;
-
-            // Handle null/empty input
-            if (string.IsNullOrWhiteSpace(nameOrFullName))
-            {
-                error = "Component name cannot be null or empty";
-                return false;
-            }
-
-            // 1) Exact cache hits
-            if (CacheByFqn.TryGetValue(nameOrFullName, out type)) return true;
-            if (!nameOrFullName.Contains(".") && CacheByName.TryGetValue(nameOrFullName, out type)) return true;
-            type = Type.GetType(nameOrFullName, throwOnError: false);
-            if (IsValidComponent(type)) { Cache(type); return true; }
-
-            // 2) Search loaded assemblies (prefer Player assemblies)
-            var candidates = FindCandidates(nameOrFullName);
-            if (candidates.Count == 1) { type = candidates[0]; Cache(type); return true; }
-            if (candidates.Count > 1) { error = Ambiguity(nameOrFullName, candidates); type = null!; return false; }
-
-#if UNITY_EDITOR
-            // 3) Last resort: Editor-only TypeCache (fast index)
-            var tc = TypeCache.GetTypesDerivedFrom<Component>()
-                              .Where(t => NamesMatch(t, nameOrFullName));
-            candidates = PreferPlayer(tc).ToList();
-            if (candidates.Count == 1) { type = candidates[0]; Cache(type); return true; }
-            if (candidates.Count > 1) { error = Ambiguity(nameOrFullName, candidates); type = null!; return false; }
-#endif
-
-            error = $"Component type '{nameOrFullName}' not found in loaded runtime assemblies. " +
-                    "Use a fully-qualified name (Namespace.TypeName) and ensure the script compiled.";
-            type = null!;
-            return false;
-        }
-
-        private static bool NamesMatch(Type t, string q) =>
-            t.Name.Equals(q, StringComparison.Ordinal) ||
-            (t.FullName?.Equals(q, StringComparison.Ordinal) ?? false);
-
-        private static bool IsValidComponent(Type t) =>
-            t != null && typeof(Component).IsAssignableFrom(t);
-
-        private static void Cache(Type t)
-        {
-            if (t.FullName != null) CacheByFqn[t.FullName] = t;
-            CacheByName[t.Name] = t;
-        }
-
-        private static List<Type> FindCandidates(string query)
-        {
-            var isShort = !query.Contains('.');
-            var loaded = AppDomain.CurrentDomain.GetAssemblies();
-
-#if UNITY_EDITOR
-            // Names of Player (runtime) script assemblies (asmdefs + Assembly-CSharp)
-            var playerAsmNames = new HashSet<string>(
-                UnityEditor.Compilation.CompilationPipeline.GetAssemblies(UnityEditor.Compilation.AssembliesType.Player).Select(a => a.name),
-                StringComparer.Ordinal);
-
-            var playerAsms = loaded.Where(a => playerAsmNames.Contains(a.GetName().Name));
-            var editorAsms = loaded.Except(playerAsms);
-#else
-            IEnumerable<System.Reflection.Assembly> playerAsms = loaded;
-            IEnumerable<System.Reflection.Assembly> editorAsms = Array.Empty<System.Reflection.Assembly>();
-#endif
-            static IEnumerable<Type> SafeGetTypes(System.Reflection.Assembly a)
-            {
-                try { return a.GetTypes(); }
-                catch (ReflectionTypeLoadException rtle) { return rtle.Types.Where(t => t != null)!; }
-            }
-
-            Func<Type, bool> match = isShort
-                ? (t => t.Name.Equals(query, StringComparison.Ordinal))
-                : (t => t.FullName!.Equals(query, StringComparison.Ordinal));
-
-            var fromPlayer = playerAsms.SelectMany(SafeGetTypes)
-                                       .Where(IsValidComponent)
-                                       .Where(match);
-            var fromEditor = editorAsms.SelectMany(SafeGetTypes)
-                                       .Where(IsValidComponent)
-                                       .Where(match);
-
-            var list = new List<Type>(fromPlayer);
-            if (list.Count == 0) list.AddRange(fromEditor);
-            return list;
-        }
-
-#if UNITY_EDITOR
-        private static IEnumerable<Type> PreferPlayer(IEnumerable<Type> seq)
-        {
-            var player = new HashSet<string>(
-                UnityEditor.Compilation.CompilationPipeline.GetAssemblies(UnityEditor.Compilation.AssembliesType.Player).Select(a => a.name),
-                StringComparer.Ordinal);
-
-            return seq.OrderBy(t => player.Contains(t.Assembly.GetName().Name) ? 0 : 1);
-        }
-#endif
-
-        private static string Ambiguity(string query, IEnumerable<Type> cands)
-        {
-            var lines = cands.Select(t => $"{t.FullName} (assembly {t.Assembly.GetName().Name})");
-            return $"Multiple component types matched '{query}':\n - " + string.Join("\n - ", lines) +
-                   "\nProvide a fully qualified type name to disambiguate.";
-        }
-
-        /// <summary>
-        /// Gets all accessible property and field names from a component type.
-        /// </summary>
-        public static List<string> GetAllComponentProperties(Type componentType)
-        {
-            if (componentType == null) return new List<string>();
-
-            var properties = componentType.GetProperties(BindingFlags.Public | BindingFlags.Instance)
-                                         .Where(p => p.CanRead && p.CanWrite)
-                                         .Select(p => p.Name);
-
-            var fields = componentType.GetFields(BindingFlags.Public | BindingFlags.Instance)
-                                     .Where(f => !f.IsInitOnly && !f.IsLiteral)
-                                     .Select(f => f.Name);
-
-            // Also include SerializeField private fields (common in Unity)
-            var serializeFields = componentType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance)
-                                              .Where(f => f.GetCustomAttribute<SerializeField>() != null)
-                                              .Select(f => f.Name);
-
-            return properties.Concat(fields).Concat(serializeFields).Distinct().OrderBy(x => x).ToList();
-        }
-
-        /// <summary>
-        /// Uses AI to suggest the most likely property matches for a user's input.
-        /// </summary>
-        public static List<string> GetAIPropertySuggestions(string userInput, List<string> availableProperties)
-        {
-            if (string.IsNullOrWhiteSpace(userInput) || !availableProperties.Any())
-                return new List<string>();
-
-            // Simple caching to avoid repeated AI calls for the same input
-            var cacheKey = $"{userInput.ToLowerInvariant()}:{string.Join(",", availableProperties)}";
-            if (PropertySuggestionCache.TryGetValue(cacheKey, out var cached))
-                return cached;
-
-            try
-            {
-                var prompt = $"A Unity developer is trying to set a component property but used an incorrect name.\n\n" +
-                             $"User requested: \"{userInput}\"\n" +
-                             $"Available properties: [{string.Join(", ", availableProperties)}]\n\n" +
-                             $"Find 1-3 most likely matches considering:\n" +
-                             $"- Unity Inspector display names vs actual field names (e.g., \"Max Reach Distance\" → \"maxReachDistance\")\n" +
-                             $"- camelCase vs PascalCase vs spaces\n" +
-                             $"- Similar meaning/semantics\n" +
-                             $"- Common Unity naming patterns\n\n" +
-                             $"Return ONLY the matching property names, comma-separated, no quotes or explanation.\n" +
-                             $"If confidence is low (<70%), return empty string.\n\n" +
-                             $"Examples:\n" +
-                             $"- \"Max Reach Distance\" → \"maxReachDistance\"\n" +
-                             $"- \"Health Points\" → \"healthPoints, hp\"\n" +
-                             $"- \"Move Speed\" → \"moveSpeed, movementSpeed\"";
-
-                // For now, we'll use a simple rule-based approach that mimics AI behavior
-                // This can be replaced with actual AI calls later
-                var suggestions = GetRuleBasedSuggestions(userInput, availableProperties);
-
-                PropertySuggestionCache[cacheKey] = suggestions;
-                return suggestions;
-            }
-            catch (Exception ex)
-            {
-                Debug.LogWarning($"[AI Property Matching] Error getting suggestions for '{userInput}': {ex.Message}");
-                return new List<string>();
-            }
-        }
-
-        private static readonly Dictionary<string, List<string>> PropertySuggestionCache = new();
-
-        /// <summary>
-        /// Rule-based suggestions that mimic AI behavior for property matching.
-        /// This provides immediate value while we could add real AI integration later.
-        /// </summary>
-        private static List<string> GetRuleBasedSuggestions(string userInput, List<string> availableProperties)
-        {
-            var suggestions = new List<string>();
-            var cleanedInput = userInput.ToLowerInvariant().Replace(" ", "").Replace("-", "").Replace("_", "");
-
-            foreach (var property in availableProperties)
-            {
-                var cleanedProperty = property.ToLowerInvariant().Replace(" ", "").Replace("-", "").Replace("_", "");
-
-                // Exact match after cleaning
-                if (cleanedProperty == cleanedInput)
-                {
-                    suggestions.Add(property);
-                    continue;
-                }
-
-                // Check if property contains all words from input
-                var inputWords = userInput.ToLowerInvariant().Split(new[] { ' ', '-', '_' }, StringSplitOptions.RemoveEmptyEntries);
-                if (inputWords.All(word => cleanedProperty.Contains(word.ToLowerInvariant())))
-                {
-                    suggestions.Add(property);
-                    continue;
-                }
-
-                // Levenshtein distance for close matches
-                if (LevenshteinDistance(cleanedInput, cleanedProperty) <= Math.Max(2, cleanedInput.Length / 4))
-                {
-                    suggestions.Add(property);
-                }
-            }
-
-            // Prioritize exact matches, then by similarity
-            return suggestions.OrderBy(s => LevenshteinDistance(cleanedInput, s.ToLowerInvariant().Replace(" ", "")))
-                             .Take(3)
-                             .ToList();
-        }
-
-        /// <summary>
-        /// Calculates Levenshtein distance between two strings for similarity matching.
-        /// </summary>
-        private static int LevenshteinDistance(string s1, string s2)
-        {
-            if (string.IsNullOrEmpty(s1)) return s2?.Length ?? 0;
-            if (string.IsNullOrEmpty(s2)) return s1.Length;
-
-            var matrix = new int[s1.Length + 1, s2.Length + 1];
-
-            for (var i = 0; i <= s1.Length; i++) matrix[i, 0] = i;
-            for (var j = 0; j <= s2.Length; j++) matrix[0, j] = j;
-
-            for (var i = 1; i <= s1.Length; i++)
-            {
-                for (var j = 1; j <= s2.Length; j++)
-                {
-                    var cost = (s2[j - 1] == s1[i - 1]) ? 0 : 1;
-                    matrix[i, j] = Math.Min(Math.Min(
-                        matrix[i - 1, j] + 1,      // deletion
-                        matrix[i, j - 1] + 1),     // insertion
-                        matrix[i - 1, j - 1] + cost); // substitution
-                }
-            }
-
-            return matrix[s1.Length, s2.Length];
-        }
-
-        // Removed duplicate ParseVector3 - using the one at line 1114
-
-        // Removed GetGameObjectData, GetComponentData, and related private helpers/caching/serializer setup.
-        // They are now in Helpers.GameObjectSerializer
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef
===================================================================
diff --git a/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef b/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Runtime/MCPForUnity.Runtime.asmdef	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,16 +0,0 @@
-{
-    "name": "MCPForUnity.Runtime",
-    "rootNamespace": "MCPForUnity.Runtime",
-    "references": [
-        "GUID:560b04d1a97f54a46a2660c3cc343a6f" 
-    ],
-    "includePlatforms": [],
-    "excludePlatforms": [],
-    "allowUnsafeCode": false,
-    "overrideReferences": false,
-    "precompiledReferences": [],
-    "autoReferenced": true,
-    "defineConstraints": [],
-    "versionDefines": [],
-    "noEngineReferences": false
-} 
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs b/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/OperationQueue.cs	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,432 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Threading;
-using System.Threading.Tasks;
-using Newtonsoft.Json.Linq;
-using UnityEngine;
-
-namespace MCPForUnity.Editor.Helpers
-{
-    /// <summary>
-    /// STUDIO: Operation queuing system for batch execution of MCP commands.
-    /// Allows multiple operations to be queued and executed with proper async support and timeouts.
-    ///
-    /// IMPROVEMENTS:
-    /// - Added async operation support with proper Task handling
-    /// - Implemented operation timeouts to prevent hanging
-    /// - Added progress reporting during batch execution
-    /// - Memory usage controls with auto-cleanup
-    ///
-    /// LIMITATIONS:
-    /// - Queue is not persistent (lost on Unity restart)
-    /// - No true rollback implementation (operations can't be undone)
-    /// </summary>
-    public static class OperationQueue
-    {
-        /// <summary>
-        /// Represents a queued operation
-        /// </summary>
-        public class QueuedOperation
-        {
-            public string Id { get; set; }
-            public string Tool { get; set; }
-            public JObject Parameters { get; set; }
-            public DateTime QueuedAt { get; set; }
-            public string Status { get; set; } = "pending"; // pending, executing, executed, failed, timeout
-            public object Result { get; set; }
-            public Exception Error { get; set; }
-            public DateTime? ExecutionStartTime { get; set; }
-            public DateTime? ExecutionEndTime { get; set; }
-            public int TimeoutMs { get; set; } = 30000; // 30 seconds default timeout
-        }
-
-        private static readonly List<QueuedOperation> _operations = new List<QueuedOperation>();
-        private static readonly object _lockObject = new object();
-        private static int _nextId = 1;
-
-        // STUDIO: Configuration constants for queue management
-        private const int MAX_QUEUE_SIZE = 1000; // Maximum operations in queue
-        private const int AUTO_CLEANUP_THRESHOLD = 500; // Auto-cleanup when exceeded
-        private const int KEEP_COMPLETED_OPERATIONS = 100; // Keep recent completed operations for history
-
-        // STUDIO: Async operation configuration
-        private static readonly HashSet<string> ASYNC_TOOLS = new HashSet<string>
-        {
-            "manage_asset", "execute_menu_item", // Tools that can be long-running
-        };
-
-        /// <summary>
-        /// Add an operation to the queue
-        /// </summary>
-        /// <param name="tool">Tool name (e.g., "manage_script", "manage_asset")</param>
-        /// <param name="parameters">Operation parameters</param>
-        /// <param name="timeoutMs">Operation timeout in milliseconds (default: 30000)</param>
-        /// <returns>Operation ID</returns>
-        public static string AddOperation(string tool, JObject parameters, int timeoutMs = 30000)
-        {
-            lock (_lockObject)
-            {
-                // STUDIO: Enforce queue size limits to prevent memory issues
-                if (_operations.Count >= MAX_QUEUE_SIZE)
-                {
-                    Debug.LogWarning($"STUDIO: Queue size limit reached ({MAX_QUEUE_SIZE}). Cannot add more operations.");
-                    throw new InvalidOperationException($"Queue size limit reached ({MAX_QUEUE_SIZE}). Clear completed operations first.");
-                }
-
-                // STUDIO: Auto-cleanup old completed operations
-                if (_operations.Count >= AUTO_CLEANUP_THRESHOLD)
-                {
-                    AutoCleanupCompletedOperations();
-                }
-
-                var operation = new QueuedOperation
-                {
-                    Id         = $"op_{_nextId++}",
-                    Tool       = tool,
-                    Parameters = parameters ?? new JObject(),
-                    QueuedAt   = DateTime.UtcNow,
-                    Status     = "pending",
-                    TimeoutMs  = Math.Max(1000, timeoutMs), // Minimum 1 second timeout
-                };
-
-                _operations.Add(operation);
-                Debug.Log($"STUDIO: Operation queued - {operation.Id} ({tool}) [Queue size: {_operations.Count}, Timeout: {timeoutMs}ms]");
-                return operation.Id;
-            }
-        }
-
-        /// <summary>
-        /// STUDIO: Auto-cleanup old completed/failed operations to manage memory
-        /// </summary>
-        private static void AutoCleanupCompletedOperations()
-        {
-            var completed = _operations.Where(op => op.Status == "executed" || op.Status == "failed" || op.Status == "timeout")
-                                     .OrderByDescending(op => op.QueuedAt)
-                                     .Skip(KEEP_COMPLETED_OPERATIONS)
-                                     .ToList();
-
-            foreach (var op in completed)
-            {
-                _operations.Remove(op);
-            }
-
-            if (completed.Count > 0)
-            {
-                Debug.Log($"STUDIO: Auto-cleaned {completed.Count} old completed operations from queue");
-            }
-        }
-
-        /// <summary>
-        /// Execute all pending operations in the queue with async support
-        /// </summary>
-        /// <returns>Batch execution results</returns>
-        public static async Task<object> ExecuteBatchAsync()
-        {
-            List<QueuedOperation> pendingOps;
-
-            lock (_lockObject)
-            {
-                pendingOps = _operations.Where(op => op.Status == "pending").ToList();
-
-                if (pendingOps.Count == 0)
-                {
-                    return Response.Success("No pending operations to execute.", new { executed_count = 0 });
-                }
-
-                Debug.Log($"STUDIO: Executing batch of {pendingOps.Count} operations with async support");
-            }
-
-            var results = new List<object>();
-            var successCount = 0;
-            var failedCount = 0;
-            var timeoutCount = 0;
-
-            // Execute operations with proper async handling
-            foreach (var operation in pendingOps)
-            {
-                lock (_lockObject)
-                {
-                    operation.Status = "executing";
-                    operation.ExecutionStartTime = DateTime.UtcNow;
-                }
-
-                try
-                {
-                    object result;
-
-                    if (ASYNC_TOOLS.Contains(operation.Tool.ToLowerInvariant()))
-                    {
-                        // Execute async operation with timeout
-                        result = await ExecuteOperationWithTimeoutAsync(operation);
-                    }
-                    else
-                    {
-                        // Execute synchronous operation
-                        result = ExecuteOperation(operation);
-                    }
-
-                    lock (_lockObject)
-                    {
-                        operation.Result = result;
-                        operation.Status = "executed";
-                        operation.ExecutionEndTime = DateTime.UtcNow;
-                    }
-
-                    successCount++;
-
-                    results.Add(new
-                    {
-                        id = operation.Id,
-                        tool = operation.Tool,
-                        status = "success",
-                        result,
-                        execution_time_ms = operation.ExecutionEndTime.HasValue && operation.ExecutionStartTime.HasValue
-                            ? (operation.ExecutionEndTime.Value - operation.ExecutionStartTime.Value).TotalMilliseconds
-                            : (double?)null,
-                    });
-                }
-                catch (TimeoutException)
-                {
-                    lock (_lockObject)
-                    {
-                        operation.Status = "timeout";
-                        operation.ExecutionEndTime = DateTime.UtcNow;
-                        operation.Error = new TimeoutException($"Operation timed out after {operation.TimeoutMs}ms");
-                    }
-
-                    timeoutCount++;
-
-                    results.Add(new
-                    {
-                        id = operation.Id,
-                        tool = operation.Tool,
-                        status = "timeout",
-                        error = $"Operation timed out after {operation.TimeoutMs}ms",
-                    });
-
-                    Debug.LogError($"STUDIO: Operation {operation.Id} timed out after {operation.TimeoutMs}ms");
-                }
-                catch (Exception ex)
-                {
-                    lock (_lockObject)
-                    {
-                        operation.Error = ex;
-                        operation.Status = "failed";
-                        operation.ExecutionEndTime = DateTime.UtcNow;
-                    }
-
-                    failedCount++;
-
-                    results.Add(new
-                    {
-                        id = operation.Id,
-                        tool = operation.Tool,
-                        status = "failed",
-                        error = ex.Message,
-                    });
-
-                    Debug.LogError($"STUDIO: Operation {operation.Id} failed: {ex.Message}");
-                }
-
-                // Allow UI updates between operations
-                await Task.Yield();
-            }
-
-            var summary = new
-            {
-                total_operations = pendingOps.Count,
-                successful = successCount,
-                failed = failedCount,
-                timeout = timeoutCount,
-                execution_time = DateTime.UtcNow,
-                results,
-            };
-
-            var message = $"Batch executed: {successCount} successful, {failedCount} failed";
-            if (timeoutCount > 0)
-            {
-                message += $", {timeoutCount} timed out";
-            }
-
-            return Response.Success(message, summary);
-        }
-
-        /// <summary>
-        /// Synchronous wrapper for ExecuteBatchAsync for backward compatibility
-        /// </summary>
-        /// <returns>Batch execution results</returns>
-        public static object ExecuteBatch()
-        {
-            try
-            {
-                return ExecuteBatchAsync().GetAwaiter().GetResult();
-            }
-            catch (Exception ex)
-            {
-                Debug.LogError($"STUDIO: Batch execution failed: {ex.Message}");
-                return Response.Error($"Batch execution failed: {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Execute an async operation with timeout support
-        /// </summary>
-        private static async Task<object> ExecuteOperationWithTimeoutAsync(QueuedOperation operation)
-        {
-            var cancellationTokenSource = new CancellationTokenSource(operation.TimeoutMs);
-
-            try
-            {
-                // Execute on Unity's main thread with timeout
-                var task = Task.Run(() => ExecuteOperation(operation), cancellationTokenSource.Token);
-
-                return await task;
-            }
-            catch (OperationCanceledException)
-            {
-                throw new TimeoutException($"Operation {operation.Id} timed out after {operation.TimeoutMs}ms");
-            }
-        }
-
-        /// <summary>
-        /// Execute a single operation by routing to the appropriate tool
-        /// </summary>
-        private static object ExecuteOperation(QueuedOperation operation)
-        {
-            // Route to the appropriate tool handler
-            switch (operation.Tool.ToLowerInvariant())
-            {
-                case "manage_script":
-                    return Tools.ManageScript.HandleCommand(operation.Parameters);
-
-                case "manage_asset":
-                    return Tools.ManageAsset.HandleCommand(operation.Parameters);
-
-                case "manage_scene":
-                    return Tools.ManageScene.HandleCommand(operation.Parameters);
-
-                case "manage_gameobject":
-                    return Tools.ManageGameObject.HandleCommand(operation.Parameters);
-
-                case "manage_shader":
-                    return Tools.ManageShader.HandleCommand(operation.Parameters);
-
-                case "manage_editor":
-                    return Tools.ManageEditor.HandleCommand(operation.Parameters);
-
-                case "read_console":
-                    return Tools.ReadConsole.HandleCommand(operation.Parameters);
-
-                case "execute_menu_item":
-                    return Tools.ExecuteMenuItem.HandleCommand(operation.Parameters);
-
-                default:
-                    throw new ArgumentException($"Unknown tool: {operation.Tool}");
-            }
-        }
-
-        /// <summary>
-        /// Get all operations in the queue
-        /// </summary>
-        /// <param name="statusFilter">Optional status filter (pending, executing, executed, failed, timeout)</param>
-        /// <returns>List of operations</returns>
-        public static List<QueuedOperation> GetOperations(string statusFilter = null)
-        {
-            lock (_lockObject)
-            {
-                var ops = _operations.AsEnumerable();
-
-                if (!string.IsNullOrEmpty(statusFilter))
-                {
-                    ops = ops.Where(op => op.Status.Equals(statusFilter, StringComparison.OrdinalIgnoreCase));
-                }
-
-                return ops.OrderBy(op => op.QueuedAt).ToList();
-            }
-        }
-
-        /// <summary>
-        /// Clear the queue (remove completed/failed operations)
-        /// </summary>
-        /// <param name="statusFilter">Optional: clear only operations with specific status</param>
-        /// <returns>Number of operations removed</returns>
-        public static int ClearQueue(string statusFilter = null)
-        {
-            lock (_lockObject)
-            {
-                var beforeCount = _operations.Count;
-
-                if (string.IsNullOrEmpty(statusFilter))
-                {
-                    // Clear all non-pending operations
-                    _operations.RemoveAll(op => op.Status != "pending");
-                }
-                else
-                {
-                    _operations.RemoveAll(op => op.Status.Equals(statusFilter, StringComparison.OrdinalIgnoreCase));
-                }
-
-                var removedCount = beforeCount - _operations.Count;
-                Debug.Log($"STUDIO: Cleared {removedCount} operations from queue");
-                return removedCount;
-            }
-        }
-
-        /// <summary>
-        /// Get queue statistics
-        /// </summary>
-        public static object GetQueueStats()
-        {
-            lock (_lockObject)
-            {
-                var stats = new
-                {
-                    total_operations = _operations.Count,
-                    pending = _operations.Count(op => op.Status == "pending"),
-                    executing = _operations.Count(op => op.Status == "executing"),
-                    executed = _operations.Count(op => op.Status == "executed"),
-                    failed = _operations.Count(op => op.Status == "failed"),
-                    timeout = _operations.Count(op => op.Status == "timeout"),
-                    oldest_operation = _operations.Count > 0 ? _operations.Min(op => op.QueuedAt) : (DateTime?)null,
-                    newest_operation = _operations.Count > 0 ? _operations.Max(op => op.QueuedAt) : (DateTime?)null,
-                    async_tools_supported = ASYNC_TOOLS.ToArray(),
-                };
-
-                return stats;
-            }
-        }
-
-        /// <summary>
-        /// Remove a specific operation by ID
-        /// </summary>
-        public static bool RemoveOperation(string operationId)
-        {
-            lock (_lockObject)
-            {
-                var removed = _operations.RemoveAll(op => op.Id == operationId);
-                return removed > 0;
-            }
-        }
-
-        /// <summary>
-        /// Cancel a running operation by ID (if it's currently executing)
-        /// </summary>
-        public static bool CancelOperation(string operationId)
-        {
-            lock (_lockObject)
-            {
-                var operation = _operations.FirstOrDefault(op => op.Id == operationId);
-                if (operation != null && operation.Status == "executing")
-                {
-                    operation.Status = "failed";
-                    operation.Error = new OperationCanceledException("Operation was cancelled");
-                    operation.ExecutionEndTime = DateTime.UtcNow;
-                    Debug.Log($"STUDIO: Operation {operationId} was cancelled");
-                    return true;
-                }
-                return false;
-            }
-        }
-    }
-}
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs.meta b/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Helpers/PackageDetector.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: b82eaef548d164ca095f17db64d15af8
\ No newline at end of file
Index: Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs.meta b/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Tools/ManageEditor.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: 43ac60aa36b361b4dbe4a038ae9f35c8
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs.meta
===================================================================
diff --git a/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs.meta b/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs.meta
deleted file mode 100644
--- a/Packages/UnityMcpBridge/Editor/Models/ServerConfig.cs.meta	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ /dev/null	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
@@ -1,11 +0,0 @@
-fileFormatVersion: 2
-guid: e4e45386fcc282249907c2e3c7e5d9c6
-MonoImporter:
-  externalObjects: {}
-  serializedVersion: 2
-  defaultReferences: []
-  executionOrder: 0
-  icon: {instanceID: 0}
-  userData: 
-  assetBundleName: 
-  assetBundleVariant: 
Index: .idea/.idea.BTL-LTM-Plus/.idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"0e4c2a72-4304-4c5d-889f-02afab2639ce\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.claude/settings.local.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.claude/settings.local.json\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategoryLevels.prefab\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategoryLevels.prefab\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCompleteOverlay.prefab\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCompleteOverlay.prefab\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/AnswerResultData.cs\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/AnswerResultData.cs.meta\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/GameStartData.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/GameStartData.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkManager.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkManager.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkMessageType.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkMessageType.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenGame.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenGame.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerMenu.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerMenu.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerRoom.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerRoom.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/ProjectSettings/SceneTemplateSettings.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/ProjectSettings/SceneTemplateSettings.json\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ChangesViewManager\">\r\n    <option name=\"groupingKeys\">\r\n      <option value=\"directory\" />\r\n      <option value=\"repository\" />\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n    <option name=\"UPDATE_TYPE\" value=\"REBASE\" />\r\n  </component>\r\n  <component name=\"HighlightingSettingsPerFile\">\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/.claude/settings.local.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Editor/BoardFileCreatorWindow.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Editor/GameManagerEditor.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens.meta\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scenes/Main.unity\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scenes/Main.unity\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scenes/Main.unity\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scenes/Main.unity\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/Assets/WordGame/Scenes/Main.unity\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scenes/Main.unity\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Game/DailyPuzzleButton.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Game/GameManager.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Game/GameManager.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Game/LetterBoard.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Game/LetterTile.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/MyCombo/CRotate.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Network/MultiplayerGameController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Network/MultiplayerGameController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Network/MultiplayerGameController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Network/MultiplayerGameController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/Network/MultiplayerGameController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCategories.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCategoryLevels.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCategoryLevels.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCategoryLevels.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCompleteOverlay.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenCompleteOverlay.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenController.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenGame.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenGame.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenGame.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenLeaderboard.cs.meta\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenMain.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenMain.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Assets/WordGame/Scripts/UI/UIScreenMultiplayerMenu.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Packages/manifest.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/Packages/packages-lock.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/ProjectSettings/SceneTemplateSettings.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/ProjectSettings/SceneTemplateSettings.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock:///Volumes/TRONGLV/Projects/Games/Unity/Personal/BTL-LTM-Plus/ProjectSettings/SceneTemplateSettings.json\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"mock://diff.cs\" root0=\"SKIP_HIGHLIGHTING\" />\r\n  </component>\r\n  <component name=\"MetaFilesCheckinStateConfiguration\" checkMetaFiles=\"true\" />\r\n  <component name=\"ProblemsViewState\">\r\n    <option name=\"selectedTabId\" value=\"CurrentFile\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"32XLe7UZubhX6ehRPNJso1YpVVO\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"autoscrollFromSource\" value=\"true\" />\r\n    <option name=\"autoscrollToSource\" value=\"true\" />\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"openDirectoriesWithSingleClick\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ModuleVcsDetector.initialDetectionPerformed&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager.252&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.keymap&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Attach to Unity Editor.Attach to Unity Editor\">\r\n    <configuration name=\"Start Unity\" type=\"RunUnityExe\" factoryName=\"Unity Executable\">\r\n      <option name=\"EXE_PATH\" value=\"$PROJECT_DIR$/../../../../../Applications/Unity/Editors/6000.2.2f1/Unity.app/Contents/MacOS/Unity\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"-projectPath $PROJECT_DIR$ -debugCodeOptimization\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"ENV_FILE_PATHS\" value=\"\" />\r\n      <option name=\"REDIRECT_INPUT_PATH\" value=\"\" />\r\n      <option name=\"PTY_MODE\" value=\"Auto\" />\r\n      <option name=\"MIXED_MODE_DEBUG\" value=\"0\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Unit Tests (batch mode)\" type=\"RunUnityExe\" factoryName=\"Unity Executable\">\r\n      <option name=\"EXE_PATH\" value=\"$PROJECT_DIR$/../../../../../Applications/Unity/Editors/6000.2.2f1/Unity.app/Contents/MacOS/Unity\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"-runTests -batchmode -projectPath $PROJECT_DIR$ -testResults Logs/results.xml -logFile Logs/Editor.log -testPlatform EditMode -debugCodeOptimization\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"ENV_FILE_PATHS\" value=\"\" />\r\n      <option name=\"REDIRECT_INPUT_PATH\" value=\"\" />\r\n      <option name=\"PTY_MODE\" value=\"Auto\" />\r\n      <option name=\"MIXED_MODE_DEBUG\" value=\"0\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Attach to Unity Editor &amp; Play\" type=\"UNITY_DEBUG_RUN_CONFIGURATION\" factoryName=\"UNITY_ATTACH_AND_PLAY\" show_console_on_std_err=\"false\" show_console_on_std_out=\"false\" port=\"50000\" address=\"localhost\">\r\n      <option name=\"allowRunningInParallel\" value=\"false\" />\r\n      <option name=\"listenPortForConnections\" value=\"false\" />\r\n      <option name=\"pid\" />\r\n      <option name=\"projectPathOnTarget\" />\r\n      <option name=\"runtimes\">\r\n        <list />\r\n      </option>\r\n      <option name=\"selectedOptions\">\r\n        <list />\r\n      </option>\r\n      <option name=\"useMixedMode\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Attach to Unity Editor\" type=\"UNITY_DEBUG_RUN_CONFIGURATION\" factoryName=\"Unity Debug\" show_console_on_std_err=\"false\" show_console_on_std_out=\"false\" port=\"50000\" address=\"localhost\">\r\n      <option name=\"allowRunningInParallel\" value=\"false\" />\r\n      <option name=\"listenPortForConnections\" value=\"false\" />\r\n      <option name=\"pid\" />\r\n      <option name=\"projectPathOnTarget\" />\r\n      <option name=\"runtimes\">\r\n        <list />\r\n      </option>\r\n      <option name=\"selectedOptions\">\r\n        <list />\r\n      </option>\r\n      <option name=\"useMixedMode\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Attach to Device\" type=\"UnityDevicePlayer\" factoryName=\"UnityAttachToDevicePlayer\">\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"0e4c2a72-4304-4c5d-889f-02afab2639ce\" name=\"Changes\" comment=\"\" />\r\n      <created>1757562075319</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1757562075319</updated>\r\n      <workItem from=\"1757562078991\" duration=\"53000\" />\r\n      <workItem from=\"1757695913765\" duration=\"1195000\" />\r\n      <workItem from=\"1757697305024\" duration=\"2574000\" />\r\n      <workItem from=\"1757700583245\" duration=\"186000\" />\r\n      <workItem from=\"1757701120841\" duration=\"473000\" />\r\n      <workItem from=\"1757701616069\" duration=\"838000\" />\r\n      <workItem from=\"1758938963968\" duration=\"24850000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Add project documentation for multiplayer architecture and client gameplay details\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1757756760544</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1757756760544</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Add metadata files for CLAUDE and CLIENT_GAMEPLAY_DETAILS\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1757817404009</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1757817404009</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Add new metadata and configuration files for TextMesh Pro assets and shaders\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1757820708356</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1757820708356</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Refactor game state management for multiplayer support and reset functionality\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1758962802632</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1758962802632</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"remove func\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1758983172391</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1758983172391</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Add UI components for user input and display, including text fields and buttons\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759021316954</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759021316954</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"update packages-lock.json\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759021471581</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759021471581</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Add metadata and configuration files for multiplayer game components\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759022311290</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759022311290</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Remove unnecessary region #\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759022636313</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759022636313</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"add mcp server\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759029342513</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759029342513</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"update prefab screens\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759030656518</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759030656518</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"Implement multiplayer UI screens and functionality\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759032930031</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759032930031</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"Add multiplayer functionality to UI screens and network management\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1759033181660</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1759033181660</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"14\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"UnityCheckinConfiguration\" checkUnsavedScenes=\"true\" />\r\n  <component name=\"UnityProjectConfiguration\" hasMinimizedUI=\"true\" />\r\n  <component name=\"UnityProjectDiscoverer\">\r\n    <option name=\"hasUnityReference\" value=\"true\" />\r\n    <option name=\"unityProject\" value=\"true\" />\r\n    <option name=\"unityProjectFolder\" value=\"true\" />\r\n  </component>\r\n  <component name=\"UnityUnitTestConfiguration\" currentTestLauncher=\"Both\" />\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\r\n    <MESSAGE value=\"Add project documentation for multiplayer architecture and client gameplay details\" />\r\n    <MESSAGE value=\"Add metadata files for CLAUDE and CLIENT_GAMEPLAY_DETAILS\" />\r\n    <MESSAGE value=\"Add new metadata and configuration files for TextMesh Pro assets and shaders\" />\r\n    <MESSAGE value=\"Refactor game state management for multiplayer support and reset functionality\" />\r\n    <MESSAGE value=\"remove func\" />\r\n    <MESSAGE value=\"Add UI components for user input and display, including text fields and buttons\" />\r\n    <MESSAGE value=\"update packages-lock.json\" />\r\n    <MESSAGE value=\"Add metadata and configuration files for multiplayer game components\" />\r\n    <MESSAGE value=\"Remove unnecessary region #\" />\r\n    <MESSAGE value=\"add mcp server\" />\r\n    <MESSAGE value=\"update prefab screens\" />\r\n    <MESSAGE value=\"Implement multiplayer UI screens and functionality\" />\r\n    <MESSAGE value=\"Add multiplayer functionality to UI screens and network management\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Add multiplayer functionality to UI screens and network management\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <breakpoint enabled=\"true\" type=\"DotNet_Exception_Breakpoints\">\r\n          <properties exception=\"System.OperationCanceledException\" breakIfHandledByOtherCode=\"false\" displayValue=\"System.OperationCanceledException\" />\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </breakpoint>\r\n        <breakpoint enabled=\"true\" type=\"DotNet_Exception_Breakpoints\">\r\n          <properties exception=\"System.Threading.Tasks.TaskCanceledException\" breakIfHandledByOtherCode=\"false\" displayValue=\"System.Threading.Tasks.TaskCanceledException\" />\r\n          <option name=\"timeStamp\" value=\"2\" />\r\n        </breakpoint>\r\n        <breakpoint enabled=\"true\" type=\"DotNet_Exception_Breakpoints\">\r\n          <properties exception=\"System.Threading.ThreadAbortException\" breakIfHandledByOtherCode=\"false\" displayValue=\"System.Threading.ThreadAbortException\" />\r\n          <option name=\"timeStamp\" value=\"3\" />\r\n        </breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml b/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml
--- a/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ b/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml	(date 1759971898673)
@@ -5,20 +5,10 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="0e4c2a72-4304-4c5d-889f-02afab2639ce" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/.claude/settings.local.json" beforeDir="false" afterPath="$PROJECT_DIR$/.claude/settings.local.json" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/.idea.BTL-LTM-Plus/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategories.prefab" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategoryLevels.prefab" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCategoryLevels.prefab" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCompleteOverlay.prefab" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Prefabs/Screens/UIScreenCompleteOverlay.prefab" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/AnswerResultData.cs" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/AnswerResultData.cs.meta" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/GameStartData.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/Models/GameStartData.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkManager.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkManager.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkMessageType.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/Network/NetworkMessageType.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenGame.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenGame.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerMenu.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerMenu.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerRoom.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Scripts/UI/UIScreenMultiplayerRoom.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/ProjectSettings/SceneTemplateSettings.json" beforeDir="false" afterPath="$PROJECT_DIR$/ProjectSettings/SceneTemplateSettings.json" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Assets/WordGame/Sample/Font/MAG_medium_crosspromo SDF.asset" beforeDir="false" afterPath="$PROJECT_DIR$/Assets/WordGame/Sample/Font/MAG_medium_crosspromo SDF.asset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Packages/packages-lock.json" beforeDir="false" afterPath="$PROJECT_DIR$/Packages/packages-lock.json" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ProjectSettings/ProjectVersion.txt" beforeDir="false" afterPath="$PROJECT_DIR$/ProjectSettings/ProjectVersion.txt" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -187,6 +177,7 @@
       <workItem from="1757701120841" duration="473000" />
       <workItem from="1757701616069" duration="838000" />
       <workItem from="1758938963968" duration="24850000" />
+      <workItem from="1759971819581" duration="78000" />
     </task>
     <task id="LOCAL-00001" summary="Add project documentation for multiplayer architecture and client gameplay details">
       <option name="closed" value="true" />
Index: Packages/packages-lock.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"dependencies\": {\r\n    \"com.theonegamestudio.unity-mcp\": {\r\n      \"version\": \"file:UnityMcpBridge\",\r\n      \"depth\": 0,\r\n      \"source\": \"embedded\",\r\n      \"dependencies\": {\r\n        \"com.unity.nuget.newtonsoft-json\": \"3.0.2\"\r\n      }\r\n    },\r\n    \"com.unity.2d.animation\": {\r\n      \"version\": \"12.0.2\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.common\": \"11.0.1\",\r\n        \"com.unity.2d.sprite\": \"1.0.0\",\r\n        \"com.unity.collections\": \"1.2.4\",\r\n        \"com.unity.modules.animation\": \"1.0.0\",\r\n        \"com.unity.modules.uielements\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.aseprite\": {\r\n      \"version\": \"2.0.1\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.common\": \"11.0.1\",\r\n        \"com.unity.2d.sprite\": \"1.0.0\",\r\n        \"com.unity.2d.tilemap\": \"1.0.0\",\r\n        \"com.unity.mathematics\": \"1.2.6\",\r\n        \"com.unity.modules.animation\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.common\": {\r\n      \"version\": \"11.0.1\",\r\n      \"depth\": 2,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.burst\": \"1.8.4\",\r\n        \"com.unity.2d.sprite\": \"1.0.0\",\r\n        \"com.unity.mathematics\": \"1.1.0\",\r\n        \"com.unity.modules.animation\": \"1.0.0\",\r\n        \"com.unity.modules.uielements\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.pixel-perfect\": {\r\n      \"version\": \"5.1.0\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.imgui\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.psdimporter\": {\r\n      \"version\": \"11.0.1\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.common\": \"11.0.1\",\r\n        \"com.unity.2d.sprite\": \"1.0.0\",\r\n        \"com.unity.2d.tilemap\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.sprite\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 1,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.2d.spriteshape\": {\r\n      \"version\": \"12.0.1\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.common\": \"11.0.1\",\r\n        \"com.unity.mathematics\": \"1.1.0\",\r\n        \"com.unity.modules.physics2d\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.2d.tilemap\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 1,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.tilemap\": \"1.0.0\",\r\n        \"com.unity.modules.uielements\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.2d.tilemap.extras\": {\r\n      \"version\": \"5.0.1\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.tilemap\": \"1.0.0\",\r\n        \"com.unity.modules.tilemap\": \"1.0.0\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.burst\": {\r\n      \"version\": \"1.8.24\",\r\n      \"depth\": 3,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.mathematics\": \"1.2.1\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.collections\": {\r\n      \"version\": \"2.5.7\",\r\n      \"depth\": 2,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.burst\": \"1.8.19\",\r\n        \"com.unity.mathematics\": \"1.3.2\",\r\n        \"com.unity.test-framework\": \"1.4.6\",\r\n        \"com.unity.nuget.mono-cecil\": \"1.11.5\",\r\n        \"com.unity.test-framework.performance\": \"3.0.3\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.ext.nunit\": {\r\n      \"version\": \"2.0.5\",\r\n      \"depth\": 1,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.feature.2d\": {\r\n      \"version\": \"2.0.1\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.2d.animation\": \"12.0.2\",\r\n        \"com.unity.2d.pixel-perfect\": \"5.1.0\",\r\n        \"com.unity.2d.psdimporter\": \"11.0.1\",\r\n        \"com.unity.2d.sprite\": \"1.0.0\",\r\n        \"com.unity.2d.spriteshape\": \"12.0.1\",\r\n        \"com.unity.2d.tilemap\": \"1.0.0\",\r\n        \"com.unity.2d.tilemap.extras\": \"5.0.1\",\r\n        \"com.unity.2d.aseprite\": \"2.0.1\"\r\n      }\r\n    },\r\n    \"com.unity.ide.rider\": {\r\n      \"version\": \"3.0.38\",\r\n      \"depth\": 0,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.ext.nunit\": \"1.0.6\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.mathematics\": {\r\n      \"version\": \"1.3.2\",\r\n      \"depth\": 2,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {},\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.multiplayer.center\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.uielements\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.multiplayer.playmode\": {\r\n      \"version\": \"1.6.1\",\r\n      \"depth\": 0,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.nuget.newtonsoft-json\": \"2.0.2\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.nuget.mono-cecil\": {\r\n      \"version\": \"1.11.5\",\r\n      \"depth\": 3,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {},\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.nuget.newtonsoft-json\": {\r\n      \"version\": \"3.2.1\",\r\n      \"depth\": 1,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {},\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.test-framework\": {\r\n      \"version\": \"1.5.1\",\r\n      \"depth\": 3,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.ext.nunit\": \"2.0.3\",\r\n        \"com.unity.modules.imgui\": \"1.0.0\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.test-framework.performance\": {\r\n      \"version\": \"3.1.0\",\r\n      \"depth\": 3,\r\n      \"source\": \"registry\",\r\n      \"dependencies\": {\r\n        \"com.unity.test-framework\": \"1.1.33\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      },\r\n      \"url\": \"https://packages.unity.com\"\r\n    },\r\n    \"com.unity.ugui\": {\r\n      \"version\": \"2.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.ui\": \"1.0.0\",\r\n        \"com.unity.modules.imgui\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.accessibility\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.ai\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.androidjni\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.animation\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.assetbundle\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.audio\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.cloth\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.physics\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.director\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.audio\": \"1.0.0\",\r\n        \"com.unity.modules.animation\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.hierarchycore\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 1,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.imageconversion\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.imgui\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.jsonserialize\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.particlesystem\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.physics\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.physics2d\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.screencapture\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.imageconversion\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.subsystems\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 1,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.terrain\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.terrainphysics\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.physics\": \"1.0.0\",\r\n        \"com.unity.modules.terrain\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.tilemap\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.physics2d\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.ui\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.uielements\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.ui\": \"1.0.0\",\r\n        \"com.unity.modules.imgui\": \"1.0.0\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\",\r\n        \"com.unity.modules.hierarchycore\": \"1.0.0\",\r\n        \"com.unity.modules.physics\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.umbra\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.unityanalytics\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.unitywebrequest\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.unitywebrequestassetbundle\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.assetbundle\": \"1.0.0\",\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.unitywebrequestaudio\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\",\r\n        \"com.unity.modules.audio\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.unitywebrequesttexture\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\",\r\n        \"com.unity.modules.imageconversion\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.unitywebrequestwww\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\",\r\n        \"com.unity.modules.unitywebrequestassetbundle\": \"1.0.0\",\r\n        \"com.unity.modules.unitywebrequestaudio\": \"1.0.0\",\r\n        \"com.unity.modules.audio\": \"1.0.0\",\r\n        \"com.unity.modules.assetbundle\": \"1.0.0\",\r\n        \"com.unity.modules.imageconversion\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.vehicles\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.physics\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.video\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.audio\": \"1.0.0\",\r\n        \"com.unity.modules.ui\": \"1.0.0\",\r\n        \"com.unity.modules.unitywebrequest\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.vr\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\",\r\n        \"com.unity.modules.physics\": \"1.0.0\",\r\n        \"com.unity.modules.xr\": \"1.0.0\"\r\n      }\r\n    },\r\n    \"com.unity.modules.wind\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {}\r\n    },\r\n    \"com.unity.modules.xr\": {\r\n      \"version\": \"1.0.0\",\r\n      \"depth\": 0,\r\n      \"source\": \"builtin\",\r\n      \"dependencies\": {\r\n        \"com.unity.modules.physics\": \"1.0.0\",\r\n        \"com.unity.modules.jsonserialize\": \"1.0.0\",\r\n        \"com.unity.modules.subsystems\": \"1.0.0\"\r\n      }\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Packages/packages-lock.json b/Packages/packages-lock.json
--- a/Packages/packages-lock.json	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ b/Packages/packages-lock.json	(date 1759972142459)
@@ -1,13 +1,5 @@
 {
   "dependencies": {
-    "com.theonegamestudio.unity-mcp": {
-      "version": "file:UnityMcpBridge",
-      "depth": 0,
-      "source": "embedded",
-      "dependencies": {
-        "com.unity.nuget.newtonsoft-json": "3.0.2"
-      }
-    },
     "com.unity.2d.animation": {
       "version": "12.0.2",
       "depth": 1,
@@ -196,7 +188,7 @@
       "url": "https://packages.unity.com"
     },
     "com.unity.test-framework": {
-      "version": "1.5.1",
+      "version": "1.6.0",
       "depth": 3,
       "source": "builtin",
       "dependencies": {
Index: ProjectSettings/ProjectVersion.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>m_EditorVersion: 6000.2.2f1\r\nm_EditorVersionWithRevision: 6000.2.2f1 (ea398eefe1c2)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ProjectSettings/ProjectVersion.txt b/ProjectSettings/ProjectVersion.txt
--- a/ProjectSettings/ProjectVersion.txt	(revision c5b0886772c21c1dd2fbd68fffcb98b3898bb01d)
+++ b/ProjectSettings/ProjectVersion.txt	(date 1759971308137)
@@ -1,2 +1,2 @@
-m_EditorVersion: 6000.2.2f1
-m_EditorVersionWithRevision: 6000.2.2f1 (ea398eefe1c2)
+m_EditorVersion: 6000.2.6f2
+m_EditorVersionWithRevision: 6000.2.6f2 (4a4dcaec6541)
